// Generated by dedot cli

import type {
  Phase,
  H256,
  DispatchError,
  AccountId32,
  FixedBytes,
  Result,
  FixedArray,
  Bytes,
  Percent,
  Perbill,
  FixedU128,
  BytesLike,
  AccountId32Like,
  MultiAddress,
  MultiAddressLike,
  Era,
  Header,
  UncheckedExtrinsic,
} from "dedot/codecs";

export type FrameSystemAccountInfo = {
  nonce: number;
  consumers: number;
  providers: number;
  sufficients: number;
  data: PalletBalancesAccountData;
};

export type PalletBalancesAccountData = {
  free: bigint;
  reserved: bigint;
  frozen: bigint;
  flags: PalletBalancesExtraFlags;
};

export type PalletBalancesExtraFlags = bigint;

export type FrameSupportDispatchPerDispatchClass = {
  normal: SpWeightsWeightV2Weight;
  operational: SpWeightsWeightV2Weight;
  mandatory: SpWeightsWeightV2Weight;
};

export type SpWeightsWeightV2Weight = { refTime: bigint; proofSize: bigint };

export type FrameSystemEventRecord = {
  phase: Phase;
  event: PolimecRuntimeRuntimeEvent;
  topics: Array<H256>;
};

export type PolimecRuntimeRuntimeEvent =
  | { pallet: "System"; palletEvent: FrameSystemEvent }
  | {
      pallet: "ParachainSystem";
      palletEvent: CumulusPalletParachainSystemEvent;
    }
  | { pallet: "Utility"; palletEvent: PalletUtilityEvent }
  | { pallet: "Multisig"; palletEvent: PalletMultisigEvent }
  | { pallet: "Proxy"; palletEvent: PalletProxyEvent }
  | { pallet: "SkipFeelessPayment"; palletEvent: PalletSkipFeelessPaymentEvent }
  | { pallet: "Balances"; palletEvent: PalletBalancesEvent }
  | { pallet: "TransactionPayment"; palletEvent: PalletTransactionPaymentEvent }
  | { pallet: "Vesting"; palletEvent: PalletVestingEvent }
  | { pallet: "ContributionTokens"; palletEvent: PalletAssetsEvent }
  | { pallet: "ForeignAssets"; palletEvent: PalletAssetsEvent002 }
  | { pallet: "Dispenser"; palletEvent: PalletDispenserEvent }
  | {
      pallet: "AssetTransactionPayment";
      palletEvent: PalletAssetTxPaymentEvent;
    }
  | { pallet: "Session"; palletEvent: PalletSessionEvent }
  | { pallet: "ParachainStaking"; palletEvent: PalletParachainStakingEvent }
  | { pallet: "XcmpQueue"; palletEvent: CumulusPalletXcmpQueueEvent }
  | { pallet: "PolkadotXcm"; palletEvent: PalletXcmEvent }
  | { pallet: "CumulusXcm"; palletEvent: CumulusPalletXcmEvent }
  | { pallet: "MessageQueue"; palletEvent: PalletMessageQueueEvent }
  | { pallet: "Treasury"; palletEvent: PalletTreasuryEvent }
  | { pallet: "Democracy"; palletEvent: PalletDemocracyEvent }
  | { pallet: "Council"; palletEvent: PalletCollectiveEvent }
  | { pallet: "TechnicalCommittee"; palletEvent: PalletCollectiveEvent }
  | { pallet: "Elections"; palletEvent: PalletElectionsPhragmenEvent }
  | { pallet: "Preimage"; palletEvent: PalletPreimageEvent }
  | { pallet: "Scheduler"; palletEvent: PalletSchedulerEvent }
  | { pallet: "Oracle"; palletEvent: OrmlOracleModuleEvent }
  | { pallet: "OracleProvidersMembership"; palletEvent: PalletMembershipEvent }
  | { pallet: "OracleOffchainWorker"; palletEvent: PalletOracleOcwEvent }
  | { pallet: "Funding"; palletEvent: PalletFundingEvent }
  | { pallet: "LinearRelease"; palletEvent: PalletLinearReleaseEvent }
  | { pallet: "ProxyBonding"; palletEvent: PalletProxyBondingEvent };

/**
 * Event for the System pallet.
 **/
export type FrameSystemEvent =
  /**
   * An extrinsic completed successfully.
   **/
  | {
      name: "ExtrinsicSuccess";
      data: { dispatchInfo: FrameSystemDispatchEventInfo };
    }
  /**
   * An extrinsic failed.
   **/
  | {
      name: "ExtrinsicFailed";
      data: {
        dispatchError: DispatchError;
        dispatchInfo: FrameSystemDispatchEventInfo;
      };
    }
  /**
   * `:code` was updated.
   **/
  | { name: "CodeUpdated" }
  /**
   * A new account was created.
   **/
  | { name: "NewAccount"; data: { account: AccountId32 } }
  /**
   * An account was reaped.
   **/
  | { name: "KilledAccount"; data: { account: AccountId32 } }
  /**
   * On on-chain remark happened.
   **/
  | { name: "Remarked"; data: { sender: AccountId32; hash: H256 } }
  /**
   * An upgrade was authorized.
   **/
  | {
      name: "UpgradeAuthorized";
      data: { codeHash: H256; checkVersion: boolean };
    };

export type FrameSystemDispatchEventInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  paysFee: FrameSupportDispatchPays;
};

export type FrameSupportDispatchDispatchClass =
  | "Normal"
  | "Operational"
  | "Mandatory";

export type FrameSupportDispatchPays = "Yes" | "No";

export type SpRuntimeProvingTrieTrieError =
  | "InvalidStateRoot"
  | "IncompleteDatabase"
  | "ValueAtIncompleteKey"
  | "DecoderError"
  | "InvalidHash"
  | "DuplicateKey"
  | "ExtraneousNode"
  | "ExtraneousValue"
  | "ExtraneousHashReference"
  | "InvalidChildReference"
  | "ValueMismatch"
  | "IncompleteProof"
  | "RootMismatch"
  | "DecodeError";

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletParachainSystemEvent =
  /**
   * The validation function has been scheduled to apply.
   **/
  | { name: "ValidationFunctionStored" }
  /**
   * The validation function was applied as of the contained relay chain block number.
   **/
  | { name: "ValidationFunctionApplied"; data: { relayChainBlockNum: number } }
  /**
   * The relay-chain aborted the upgrade process.
   **/
  | { name: "ValidationFunctionDiscarded" }
  /**
   * Some downward messages have been received and will be processed.
   **/
  | { name: "DownwardMessagesReceived"; data: { count: number } }
  /**
   * Downward messages were processed using the given weight.
   **/
  | {
      name: "DownwardMessagesProcessed";
      data: { weightUsed: SpWeightsWeightV2Weight; dmqHead: H256 };
    }
  /**
   * An upward message was sent to the relay chain.
   **/
  | {
      name: "UpwardMessageSent";
      data: { messageHash?: FixedBytes<32> | undefined };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletUtilityEvent =
  /**
   * Batch of dispatches did not complete fully. Index of first failing dispatch given, as
   * well as the error.
   **/
  | { name: "BatchInterrupted"; data: { index: number; error: DispatchError } }
  /**
   * Batch of dispatches completed fully with no error.
   **/
  | { name: "BatchCompleted" }
  /**
   * Batch of dispatches completed but has errors.
   **/
  | { name: "BatchCompletedWithErrors" }
  /**
   * A single item within a Batch of dispatches has completed with no error.
   **/
  | { name: "ItemCompleted" }
  /**
   * A single item within a Batch of dispatches has completed with error.
   **/
  | { name: "ItemFailed"; data: { error: DispatchError } }
  /**
   * A call was dispatched.
   **/
  | { name: "DispatchedAs"; data: { result: Result<[], DispatchError> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMultisigEvent =
  /**
   * A new multisig operation has begun.
   **/
  | {
      name: "NewMultisig";
      data: {
        approving: AccountId32;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been approved by someone.
   **/
  | {
      name: "MultisigApproval";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    }
  /**
   * A multisig operation has been executed.
   **/
  | {
      name: "MultisigExecuted";
      data: {
        approving: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * A multisig operation has been cancelled.
   **/
  | {
      name: "MultisigCancelled";
      data: {
        cancelling: AccountId32;
        timepoint: PalletMultisigTimepoint;
        multisig: AccountId32;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigTimepoint = { height: number; index: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyEvent =
  /**
   * A proxy was executed correctly, with the given.
   **/
  | { name: "ProxyExecuted"; data: { result: Result<[], DispatchError> } }
  /**
   * A pure account has been created by new proxy with given
   * disambiguation index and proxy type.
   **/
  | {
      name: "PureCreated";
      data: {
        pure: AccountId32;
        who: AccountId32;
        proxyType: SharedConfigurationProxyType;
        disambiguationIndex: number;
      };
    }
  /**
   * An announcement was placed to make a call in the future.
   **/
  | {
      name: "Announced";
      data: { real: AccountId32; proxy: AccountId32; callHash: H256 };
    }
  /**
   * A proxy was added.
   **/
  | {
      name: "ProxyAdded";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    }
  /**
   * A proxy was removed.
   **/
  | {
      name: "ProxyRemoved";
      data: {
        delegator: AccountId32;
        delegatee: AccountId32;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    };

export type SharedConfigurationProxyType =
  | "Any"
  | "NonTransfer"
  | "Governance"
  | "Staking";

/**
 * The `Event` enum of this pallet
 **/
export type PalletSkipFeelessPaymentEvent =
  /**
   * A transaction fee was skipped.
   **/
  { name: "FeeSkipped"; data: { origin: PolimecRuntimeOriginCaller } };

export type PolimecRuntimeOriginCaller =
  | { type: "System"; value: FrameSupportDispatchRawOrigin }
  | { type: "PolkadotXcm"; value: PalletXcmOrigin }
  | { type: "CumulusXcm"; value: CumulusPalletXcmOrigin }
  | { type: "Council"; value: PalletCollectiveRawOrigin }
  | { type: "TechnicalCommittee"; value: PalletCollectiveRawOrigin };

export type FrameSupportDispatchRawOrigin =
  | { type: "Root" }
  | { type: "Signed"; value: AccountId32 }
  | { type: "None" };

export type PalletXcmOrigin =
  | { type: "Xcm"; value: StagingXcmV5Location }
  | { type: "Response"; value: StagingXcmV5Location };

export type StagingXcmV5Location = {
  parents: number;
  interior: StagingXcmV5Junctions;
};

export type StagingXcmV5Junctions =
  | { type: "Here" }
  | { type: "X1"; value: FixedArray<StagingXcmV5Junction, 1> }
  | { type: "X2"; value: FixedArray<StagingXcmV5Junction, 2> }
  | { type: "X3"; value: FixedArray<StagingXcmV5Junction, 3> }
  | { type: "X4"; value: FixedArray<StagingXcmV5Junction, 4> }
  | { type: "X5"; value: FixedArray<StagingXcmV5Junction, 5> }
  | { type: "X6"; value: FixedArray<StagingXcmV5Junction, 6> }
  | { type: "X7"; value: FixedArray<StagingXcmV5Junction, 7> }
  | { type: "X8"; value: FixedArray<StagingXcmV5Junction, 8> };

export type StagingXcmV5Junction =
  | { type: "Parachain"; value: number }
  | {
      type: "AccountId32";
      value: {
        network?: StagingXcmV5JunctionNetworkId | undefined;
        id: FixedBytes<32>;
      };
    }
  | {
      type: "AccountIndex64";
      value: {
        network?: StagingXcmV5JunctionNetworkId | undefined;
        index: bigint;
      };
    }
  | {
      type: "AccountKey20";
      value: {
        network?: StagingXcmV5JunctionNetworkId | undefined;
        key: FixedBytes<20>;
      };
    }
  | { type: "PalletInstance"; value: number }
  | { type: "GeneralIndex"; value: bigint }
  | { type: "GeneralKey"; value: { length: number; data: FixedBytes<32> } }
  | { type: "OnlyChild" }
  | {
      type: "Plurality";
      value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart };
    }
  | { type: "GlobalConsensus"; value: StagingXcmV5JunctionNetworkId };

export type StagingXcmV5JunctionNetworkId =
  | { type: "ByGenesis"; value: FixedBytes<32> }
  | {
      type: "ByFork";
      value: { blockNumber: bigint; blockHash: FixedBytes<32> };
    }
  | { type: "Polkadot" }
  | { type: "Kusama" }
  | { type: "Ethereum"; value: { chainId: bigint } }
  | { type: "BitcoinCore" }
  | { type: "BitcoinCash" }
  | { type: "PolkadotBulletin" };

export type XcmV3JunctionBodyId =
  | { type: "Unit" }
  | { type: "Moniker"; value: FixedBytes<4> }
  | { type: "Index"; value: number }
  | { type: "Executive" }
  | { type: "Technical" }
  | { type: "Legislative" }
  | { type: "Judicial" }
  | { type: "Defense" }
  | { type: "Administration" }
  | { type: "Treasury" };

export type XcmV3JunctionBodyPart =
  | { type: "Voice" }
  | { type: "Members"; value: { count: number } }
  | { type: "Fraction"; value: { nom: number; denom: number } }
  | { type: "AtLeastProportion"; value: { nom: number; denom: number } }
  | { type: "MoreThanProportion"; value: { nom: number; denom: number } };

export type CumulusPalletXcmOrigin =
  | { type: "Relay" }
  | {
      type: "SiblingParachain";
      value: PolkadotParachainPrimitivesPrimitivesId;
    };

export type PolkadotParachainPrimitivesPrimitivesId = number;

export type PalletCollectiveRawOrigin =
  | { type: "Members"; value: [number, number] }
  | { type: "Member"; value: AccountId32 }
  | { type: "Phantom" };

/**
 * The `Event` enum of this pallet
 **/
export type PalletBalancesEvent =
  /**
   * An account was created with some free balance.
   **/
  | { name: "Endowed"; data: { account: AccountId32; freeBalance: bigint } }
  /**
   * An account was removed whose balance was non-zero but below ExistentialDeposit,
   * resulting in an outright loss.
   **/
  | { name: "DustLost"; data: { account: AccountId32; amount: bigint } }
  /**
   * Transfer succeeded.
   **/
  | {
      name: "Transfer";
      data: { from: AccountId32; to: AccountId32; amount: bigint };
    }
  /**
   * A balance was set by root.
   **/
  | { name: "BalanceSet"; data: { who: AccountId32; free: bigint } }
  /**
   * Some balance was reserved (moved from free to reserved).
   **/
  | { name: "Reserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unreserved (moved from reserved to free).
   **/
  | { name: "Unreserved"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was moved from the reserve of the first account to the second account.
   * Final argument indicates the destination balance type.
   **/
  | {
      name: "ReserveRepatriated";
      data: {
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
        destinationStatus: FrameSupportTokensMiscBalanceStatus;
      };
    }
  /**
   * Some amount was deposited (e.g. for transaction fees).
   **/
  | { name: "Deposit"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was withdrawn from the account (e.g. for transaction fees).
   **/
  | { name: "Withdraw"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was removed from the account (e.g. for misbehavior).
   **/
  | { name: "Slashed"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was minted into an account.
   **/
  | { name: "Minted"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was burned from an account.
   **/
  | { name: "Burned"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was suspended from an account (it can be restored later).
   **/
  | { name: "Suspended"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some amount was restored into an account.
   **/
  | { name: "Restored"; data: { who: AccountId32; amount: bigint } }
  /**
   * An account was upgraded.
   **/
  | { name: "Upgraded"; data: { who: AccountId32 } }
  /**
   * Total issuance was increased by `amount`, creating a credit to be balanced.
   **/
  | { name: "Issued"; data: { amount: bigint } }
  /**
   * Total issuance was decreased by `amount`, creating a debt to be balanced.
   **/
  | { name: "Rescinded"; data: { amount: bigint } }
  /**
   * Some balance was locked.
   **/
  | { name: "Locked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was unlocked.
   **/
  | { name: "Unlocked"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was frozen.
   **/
  | { name: "Frozen"; data: { who: AccountId32; amount: bigint } }
  /**
   * Some balance was thawed.
   **/
  | { name: "Thawed"; data: { who: AccountId32; amount: bigint } }
  /**
   * The `TotalIssuance` was forcefully changed.
   **/
  | { name: "TotalIssuanceForced"; data: { old: bigint; new: bigint } };

export type FrameSupportTokensMiscBalanceStatus = "Free" | "Reserved";

/**
 * The `Event` enum of this pallet
 **/
export type PalletTransactionPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who`.
   **/
  {
    name: "TransactionFeePaid";
    data: { who: AccountId32; actualFee: bigint; tip: bigint };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletVestingEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: "VestingUpdated"; data: { account: AccountId32; unvested: bigint } }
  /**
   * An \[account\] has become fully vested.
   **/
  | { name: "VestingCompleted"; data: { account: AccountId32 } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent =
  /**
   * Some asset class was created.
   **/
  | {
      name: "Created";
      data: { assetId: number; creator: AccountId32; owner: AccountId32 };
    }
  /**
   * Some assets were issued.
   **/
  | {
      name: "Issued";
      data: { assetId: number; owner: AccountId32; amount: bigint };
    }
  /**
   * Some assets were transferred.
   **/
  | {
      name: "Transferred";
      data: {
        assetId: number;
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
      };
    }
  /**
   * Some assets were destroyed.
   **/
  | {
      name: "Burned";
      data: { assetId: number; owner: AccountId32; balance: bigint };
    }
  /**
   * The management team changed.
   **/
  | {
      name: "TeamChanged";
      data: {
        assetId: number;
        issuer: AccountId32;
        admin: AccountId32;
        freezer: AccountId32;
      };
    }
  /**
   * The owner changed.
   **/
  | { name: "OwnerChanged"; data: { assetId: number; owner: AccountId32 } }
  /**
   * Some account `who` was frozen.
   **/
  | { name: "Frozen"; data: { assetId: number; who: AccountId32 } }
  /**
   * Some account `who` was thawed.
   **/
  | { name: "Thawed"; data: { assetId: number; who: AccountId32 } }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: "AssetFrozen"; data: { assetId: number } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: "AssetThawed"; data: { assetId: number } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | {
      name: "AccountsDestroyed";
      data: {
        assetId: number;
        accountsDestroyed: number;
        accountsRemaining: number;
      };
    }
  /**
   * Approvals were destroyed for given asset.
   **/
  | {
      name: "ApprovalsDestroyed";
      data: {
        assetId: number;
        approvalsDestroyed: number;
        approvalsRemaining: number;
      };
    }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: "DestructionStarted"; data: { assetId: number } }
  /**
   * An asset class was destroyed.
   **/
  | { name: "Destroyed"; data: { assetId: number } }
  /**
   * Some asset class was force-created.
   **/
  | { name: "ForceCreated"; data: { assetId: number; owner: AccountId32 } }
  /**
   * New metadata has been set for an asset.
   **/
  | {
      name: "MetadataSet";
      data: {
        assetId: number;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: "MetadataCleared"; data: { assetId: number } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | {
      name: "ApprovedTransfer";
      data: {
        assetId: number;
        source: AccountId32;
        delegate: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | {
      name: "ApprovalCancelled";
      data: { assetId: number; owner: AccountId32; delegate: AccountId32 };
    }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: "TransferredApproved";
      data: {
        assetId: number;
        owner: AccountId32;
        delegate: AccountId32;
        destination: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: "AssetStatusChanged"; data: { assetId: number } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | {
      name: "AssetMinBalanceChanged";
      data: { assetId: number; newMinBalance: bigint };
    }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | {
      name: "Touched";
      data: { assetId: number; who: AccountId32; depositor: AccountId32 };
    }
  /**
   * Some account `who` was blocked.
   **/
  | { name: "Blocked"; data: { assetId: number; who: AccountId32 } }
  /**
   * Some assets were deposited (e.g. for transaction fees).
   **/
  | {
      name: "Deposited";
      data: { assetId: number; who: AccountId32; amount: bigint };
    }
  /**
   * Some assets were withdrawn from the account (e.g. for transaction fees).
   **/
  | {
      name: "Withdrawn";
      data: { assetId: number; who: AccountId32; amount: bigint };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetsEvent002 =
  /**
   * Some asset class was created.
   **/
  | {
      name: "Created";
      data: {
        assetId: StagingXcmV4Location;
        creator: AccountId32;
        owner: AccountId32;
      };
    }
  /**
   * Some assets were issued.
   **/
  | {
      name: "Issued";
      data: {
        assetId: StagingXcmV4Location;
        owner: AccountId32;
        amount: bigint;
      };
    }
  /**
   * Some assets were transferred.
   **/
  | {
      name: "Transferred";
      data: {
        assetId: StagingXcmV4Location;
        from: AccountId32;
        to: AccountId32;
        amount: bigint;
      };
    }
  /**
   * Some assets were destroyed.
   **/
  | {
      name: "Burned";
      data: {
        assetId: StagingXcmV4Location;
        owner: AccountId32;
        balance: bigint;
      };
    }
  /**
   * The management team changed.
   **/
  | {
      name: "TeamChanged";
      data: {
        assetId: StagingXcmV4Location;
        issuer: AccountId32;
        admin: AccountId32;
        freezer: AccountId32;
      };
    }
  /**
   * The owner changed.
   **/
  | {
      name: "OwnerChanged";
      data: { assetId: StagingXcmV4Location; owner: AccountId32 };
    }
  /**
   * Some account `who` was frozen.
   **/
  | {
      name: "Frozen";
      data: { assetId: StagingXcmV4Location; who: AccountId32 };
    }
  /**
   * Some account `who` was thawed.
   **/
  | {
      name: "Thawed";
      data: { assetId: StagingXcmV4Location; who: AccountId32 };
    }
  /**
   * Some asset `asset_id` was frozen.
   **/
  | { name: "AssetFrozen"; data: { assetId: StagingXcmV4Location } }
  /**
   * Some asset `asset_id` was thawed.
   **/
  | { name: "AssetThawed"; data: { assetId: StagingXcmV4Location } }
  /**
   * Accounts were destroyed for given asset.
   **/
  | {
      name: "AccountsDestroyed";
      data: {
        assetId: StagingXcmV4Location;
        accountsDestroyed: number;
        accountsRemaining: number;
      };
    }
  /**
   * Approvals were destroyed for given asset.
   **/
  | {
      name: "ApprovalsDestroyed";
      data: {
        assetId: StagingXcmV4Location;
        approvalsDestroyed: number;
        approvalsRemaining: number;
      };
    }
  /**
   * An asset class is in the process of being destroyed.
   **/
  | { name: "DestructionStarted"; data: { assetId: StagingXcmV4Location } }
  /**
   * An asset class was destroyed.
   **/
  | { name: "Destroyed"; data: { assetId: StagingXcmV4Location } }
  /**
   * Some asset class was force-created.
   **/
  | {
      name: "ForceCreated";
      data: { assetId: StagingXcmV4Location; owner: AccountId32 };
    }
  /**
   * New metadata has been set for an asset.
   **/
  | {
      name: "MetadataSet";
      data: {
        assetId: StagingXcmV4Location;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Metadata has been cleared for an asset.
   **/
  | { name: "MetadataCleared"; data: { assetId: StagingXcmV4Location } }
  /**
   * (Additional) funds have been approved for transfer to a destination account.
   **/
  | {
      name: "ApprovedTransfer";
      data: {
        assetId: StagingXcmV4Location;
        source: AccountId32;
        delegate: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An approval for account `delegate` was cancelled by `owner`.
   **/
  | {
      name: "ApprovalCancelled";
      data: {
        assetId: StagingXcmV4Location;
        owner: AccountId32;
        delegate: AccountId32;
      };
    }
  /**
   * An `amount` was transferred in its entirety from `owner` to `destination` by
   * the approved `delegate`.
   **/
  | {
      name: "TransferredApproved";
      data: {
        assetId: StagingXcmV4Location;
        owner: AccountId32;
        delegate: AccountId32;
        destination: AccountId32;
        amount: bigint;
      };
    }
  /**
   * An asset has had its attributes changed by the `Force` origin.
   **/
  | { name: "AssetStatusChanged"; data: { assetId: StagingXcmV4Location } }
  /**
   * The min_balance of an asset has been updated by the asset owner.
   **/
  | {
      name: "AssetMinBalanceChanged";
      data: { assetId: StagingXcmV4Location; newMinBalance: bigint };
    }
  /**
   * Some account `who` was created with a deposit from `depositor`.
   **/
  | {
      name: "Touched";
      data: {
        assetId: StagingXcmV4Location;
        who: AccountId32;
        depositor: AccountId32;
      };
    }
  /**
   * Some account `who` was blocked.
   **/
  | {
      name: "Blocked";
      data: { assetId: StagingXcmV4Location; who: AccountId32 };
    }
  /**
   * Some assets were deposited (e.g. for transaction fees).
   **/
  | {
      name: "Deposited";
      data: { assetId: StagingXcmV4Location; who: AccountId32; amount: bigint };
    }
  /**
   * Some assets were withdrawn from the account (e.g. for transaction fees).
   **/
  | {
      name: "Withdrawn";
      data: { assetId: StagingXcmV4Location; who: AccountId32; amount: bigint };
    };

export type StagingXcmV4Location = {
  parents: number;
  interior: StagingXcmV4Junctions;
};

export type StagingXcmV4Junctions =
  | { type: "Here" }
  | { type: "X1"; value: FixedArray<StagingXcmV4Junction, 1> }
  | { type: "X2"; value: FixedArray<StagingXcmV4Junction, 2> }
  | { type: "X3"; value: FixedArray<StagingXcmV4Junction, 3> }
  | { type: "X4"; value: FixedArray<StagingXcmV4Junction, 4> }
  | { type: "X5"; value: FixedArray<StagingXcmV4Junction, 5> }
  | { type: "X6"; value: FixedArray<StagingXcmV4Junction, 6> }
  | { type: "X7"; value: FixedArray<StagingXcmV4Junction, 7> }
  | { type: "X8"; value: FixedArray<StagingXcmV4Junction, 8> };

export type StagingXcmV4Junction =
  | { type: "Parachain"; value: number }
  | {
      type: "AccountId32";
      value: {
        network?: StagingXcmV4JunctionNetworkId | undefined;
        id: FixedBytes<32>;
      };
    }
  | {
      type: "AccountIndex64";
      value: {
        network?: StagingXcmV4JunctionNetworkId | undefined;
        index: bigint;
      };
    }
  | {
      type: "AccountKey20";
      value: {
        network?: StagingXcmV4JunctionNetworkId | undefined;
        key: FixedBytes<20>;
      };
    }
  | { type: "PalletInstance"; value: number }
  | { type: "GeneralIndex"; value: bigint }
  | { type: "GeneralKey"; value: { length: number; data: FixedBytes<32> } }
  | { type: "OnlyChild" }
  | {
      type: "Plurality";
      value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart };
    }
  | { type: "GlobalConsensus"; value: StagingXcmV4JunctionNetworkId };

export type StagingXcmV4JunctionNetworkId =
  | { type: "ByGenesis"; value: FixedBytes<32> }
  | {
      type: "ByFork";
      value: { blockNumber: bigint; blockHash: FixedBytes<32> };
    }
  | { type: "Polkadot" }
  | { type: "Kusama" }
  | { type: "Westend" }
  | { type: "Rococo" }
  | { type: "Wococo" }
  | { type: "Ethereum"; value: { chainId: bigint } }
  | { type: "BitcoinCore" }
  | { type: "BitcoinCash" }
  | { type: "PolkadotBulletin" };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDispenserEvent =
  | {
      name: "Dispensed";
      data: { dispensedToDid: Bytes; dispensedTo: AccountId32; amount: bigint };
    }
  | { name: "DispenseAmountChanged"; data: bigint };

/**
 * The `Event` enum of this pallet
 **/
export type PalletAssetTxPaymentEvent =
  /**
   * A transaction fee `actual_fee`, of which `tip` was added to the minimum inclusion fee,
   * has been paid by `who` in an asset `asset_id`.
   **/
  {
    name: "AssetTxFeePaid";
    data: {
      who: AccountId32;
      actualFee: bigint;
      tip: bigint;
      assetId?: StagingXcmV3MultilocationMultiLocation | undefined;
    };
  };

export type StagingXcmV3MultilocationMultiLocation = {
  parents: number;
  interior: XcmV3Junctions;
};

export type XcmV3Junctions =
  | { type: "Here" }
  | { type: "X1"; value: XcmV3Junction }
  | { type: "X2"; value: [XcmV3Junction, XcmV3Junction] }
  | { type: "X3"; value: [XcmV3Junction, XcmV3Junction, XcmV3Junction] }
  | {
      type: "X4";
      value: [XcmV3Junction, XcmV3Junction, XcmV3Junction, XcmV3Junction];
    }
  | {
      type: "X5";
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    }
  | {
      type: "X6";
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    }
  | {
      type: "X7";
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    }
  | {
      type: "X8";
      value: [
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
        XcmV3Junction,
      ];
    };

export type XcmV3Junction =
  | { type: "Parachain"; value: number }
  | {
      type: "AccountId32";
      value: {
        network?: XcmV3JunctionNetworkId | undefined;
        id: FixedBytes<32>;
      };
    }
  | {
      type: "AccountIndex64";
      value: { network?: XcmV3JunctionNetworkId | undefined; index: bigint };
    }
  | {
      type: "AccountKey20";
      value: {
        network?: XcmV3JunctionNetworkId | undefined;
        key: FixedBytes<20>;
      };
    }
  | { type: "PalletInstance"; value: number }
  | { type: "GeneralIndex"; value: bigint }
  | { type: "GeneralKey"; value: { length: number; data: FixedBytes<32> } }
  | { type: "OnlyChild" }
  | {
      type: "Plurality";
      value: { id: XcmV3JunctionBodyId; part: XcmV3JunctionBodyPart };
    }
  | { type: "GlobalConsensus"; value: XcmV3JunctionNetworkId };

export type XcmV3JunctionNetworkId =
  | { type: "ByGenesis"; value: FixedBytes<32> }
  | {
      type: "ByFork";
      value: { blockNumber: bigint; blockHash: FixedBytes<32> };
    }
  | { type: "Polkadot" }
  | { type: "Kusama" }
  | { type: "Westend" }
  | { type: "Rococo" }
  | { type: "Wococo" }
  | { type: "Ethereum"; value: { chainId: bigint } }
  | { type: "BitcoinCore" }
  | { type: "BitcoinCash" }
  | { type: "PolkadotBulletin" };

/**
 * The `Event` enum of this pallet
 **/
export type PalletSessionEvent =
  /**
   * New session has happened. Note that the argument is the session index, not the
   * block number as the type might suggest.
   **/
  { name: "NewSession"; data: { sessionIndex: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletParachainStakingEvent =
  /**
   * Started new round.
   **/
  | {
      name: "NewRound";
      data: {
        startingBlock: number;
        round: number;
        selectedCollatorsNumber: number;
        totalBalance: bigint;
      };
    }
  /**
   * Account joined the set of collator candidates.
   **/
  | {
      name: "JoinedCollatorCandidates";
      data: {
        account: AccountId32;
        amountLocked: bigint;
        newTotalAmtLocked: bigint;
      };
    }
  /**
   * Candidate selected for collators. Total Exposed Amount includes all delegations.
   **/
  | {
      name: "CollatorChosen";
      data: {
        round: number;
        collatorAccount: AccountId32;
        totalExposedAmount: bigint;
      };
    }
  /**
   * Candidate requested to decrease a self bond.
   **/
  | {
      name: "CandidateBondLessRequested";
      data: {
        candidate: AccountId32;
        amountToDecrease: bigint;
        executeRound: number;
      };
    }
  /**
   * Candidate has increased a self bond.
   **/
  | {
      name: "CandidateBondedMore";
      data: { candidate: AccountId32; amount: bigint; newTotalBond: bigint };
    }
  /**
   * Candidate has decreased a self bond.
   **/
  | {
      name: "CandidateBondedLess";
      data: { candidate: AccountId32; amount: bigint; newBond: bigint };
    }
  /**
   * Candidate temporarily leave the set of collator candidates without unbonding.
   **/
  | { name: "CandidateWentOffline"; data: { candidate: AccountId32 } }
  /**
   * Candidate rejoins the set of collator candidates.
   **/
  | { name: "CandidateBackOnline"; data: { candidate: AccountId32 } }
  /**
   * Candidate has requested to leave the set of candidates.
   **/
  | {
      name: "CandidateScheduledExit";
      data: {
        exitAllowedRound: number;
        candidate: AccountId32;
        scheduledExit: number;
      };
    }
  /**
   * Cancelled request to leave the set of candidates.
   **/
  | { name: "CancelledCandidateExit"; data: { candidate: AccountId32 } }
  /**
   * Cancelled request to decrease candidate's bond.
   **/
  | {
      name: "CancelledCandidateBondLess";
      data: { candidate: AccountId32; amount: bigint; executeRound: number };
    }
  /**
   * Candidate has left the set of candidates.
   **/
  | {
      name: "CandidateLeft";
      data: {
        exCandidate: AccountId32;
        unlockedAmount: bigint;
        newTotalAmtLocked: bigint;
      };
    }
  /**
   * Delegator requested to decrease a bond for the collator candidate.
   **/
  | {
      name: "DelegationDecreaseScheduled";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        amountToDecrease: bigint;
        executeRound: number;
      };
    }
  | {
      name: "DelegationIncreased";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        amount: bigint;
        inTop: boolean;
      };
    }
  | {
      name: "DelegationDecreased";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        amount: bigint;
        inTop: boolean;
      };
    }
  /**
   * Delegator requested to leave the set of delegators.
   **/
  | {
      name: "DelegatorExitScheduled";
      data: { round: number; delegator: AccountId32; scheduledExit: number };
    }
  /**
   * Delegator requested to revoke delegation.
   **/
  | {
      name: "DelegationRevocationScheduled";
      data: {
        round: number;
        delegator: AccountId32;
        candidate: AccountId32;
        scheduledExit: number;
      };
    }
  /**
   * Delegator has left the set of delegators.
   **/
  | {
      name: "DelegatorLeft";
      data: { delegator: AccountId32; unstakedAmount: bigint };
    }
  /**
   * Delegation revoked.
   **/
  | {
      name: "DelegationRevoked";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        unstakedAmount: bigint;
      };
    }
  /**
   * Delegation kicked.
   **/
  | {
      name: "DelegationKicked";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        unstakedAmount: bigint;
      };
    }
  /**
   * Cancelled a pending request to exit the set of delegators.
   **/
  | { name: "DelegatorExitCancelled"; data: { delegator: AccountId32 } }
  /**
   * Cancelled request to change an existing delegation.
   **/
  | {
      name: "CancelledDelegationRequest";
      data: {
        delegator: AccountId32;
        cancelledRequest: PalletParachainStakingDelegationRequestsCancelledScheduledRequest;
        collator: AccountId32;
      };
    }
  /**
   * New delegation (increase of the existing one).
   **/
  | {
      name: "Delegation";
      data: {
        delegator: AccountId32;
        lockedAmount: bigint;
        candidate: AccountId32;
        delegatorPosition: PalletParachainStakingDelegatorAdded;
        autoCompound: Percent;
      };
    }
  /**
   * Delegation from candidate state has been remove.
   **/
  | {
      name: "DelegatorLeftCandidate";
      data: {
        delegator: AccountId32;
        candidate: AccountId32;
        unstakedAmount: bigint;
        totalCandidateStaked: bigint;
      };
    }
  /**
   * Paid the account (delegator or collator) the balance as liquid rewards.
   **/
  | { name: "Rewarded"; data: { account: AccountId32; rewards: bigint } }
  /**
   * Transferred to account which holds funds reserved for parachain bond.
   **/
  | {
      name: "ReservedForParachainBond";
      data: { account: AccountId32; value: bigint };
    }
  /**
   * Account (re)set for parachain bond treasury.
   **/
  | {
      name: "ParachainBondAccountSet";
      data: { old: AccountId32; new: AccountId32 };
    }
  /**
   * Percent of inflation reserved for parachain bond (re)set.
   **/
  | {
      name: "ParachainBondReservePercentSet";
      data: { old: Percent; new: Percent };
    }
  /**
   * Annual inflation input (first 3) was used to derive new per-round inflation (last 3)
   **/
  | {
      name: "InflationSet";
      data: {
        annualMin: Perbill;
        annualIdeal: Perbill;
        annualMax: Perbill;
        roundMin: Perbill;
        roundIdeal: Perbill;
        roundMax: Perbill;
      };
    }
  /**
   * Staking expectations set.
   **/
  | {
      name: "StakeExpectationsSet";
      data: { expectMin: bigint; expectIdeal: bigint; expectMax: bigint };
    }
  /**
   * Set total selected candidates to this value.
   **/
  | { name: "TotalSelectedSet"; data: { old: number; new: number } }
  /**
   * Set collator commission to this value.
   **/
  | { name: "CollatorCommissionSet"; data: { old: Perbill; new: Perbill } }
  /**
   * Set blocks per round
   **/
  | {
      name: "BlocksPerRoundSet";
      data: {
        currentRound: number;
        firstBlock: number;
        old: number;
        new: number;
        newPerRoundInflationMin: Perbill;
        newPerRoundInflationIdeal: Perbill;
        newPerRoundInflationMax: Perbill;
      };
    }
  /**
   * Auto-compounding reward percent was set for a delegation.
   **/
  | {
      name: "AutoCompoundSet";
      data: { candidate: AccountId32; delegator: AccountId32; value: Percent };
    }
  /**
   * Compounded a portion of rewards towards the delegation.
   **/
  | {
      name: "Compounded";
      data: { candidate: AccountId32; delegator: AccountId32; amount: bigint };
    };

export type PalletParachainStakingDelegationRequestsCancelledScheduledRequest =
  {
    whenExecutable: number;
    action: PalletParachainStakingDelegationRequestsDelegationAction;
  };

export type PalletParachainStakingDelegationRequestsDelegationAction =
  | { type: "Revoke"; value: bigint }
  | { type: "Decrease"; value: bigint };

export type PalletParachainStakingDelegatorAdded =
  | { type: "AddedToTop"; value: { newTotal: bigint } }
  | { type: "AddedToBottom" };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmpQueueEvent =
  /**
   * An HRMP message was sent to a sibling parachain.
   **/
  { name: "XcmpMessageSent"; data: { messageHash: FixedBytes<32> } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletXcmEvent =
  /**
   * Execution of an XCM message was attempted.
   **/
  | { name: "Attempted"; data: { outcome: StagingXcmV5TraitsOutcome } }
  /**
   * A XCM message was sent.
   **/
  | {
      name: "Sent";
      data: {
        origin: StagingXcmV5Location;
        destination: StagingXcmV5Location;
        message: StagingXcmV5Xcm;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Query response received which does not match a registered query. This may be because a
   * matching query was never registered, it may be because it is a duplicate response, or
   * because the query timed out.
   **/
  | {
      name: "UnexpectedResponse";
      data: { origin: StagingXcmV5Location; queryId: bigint };
    }
  /**
   * Query response has been received and is ready for taking with `take_response`. There is
   * no registered notification call.
   **/
  | {
      name: "ResponseReady";
      data: { queryId: bigint; response: StagingXcmV5Response };
    }
  /**
   * Query response has been received and query is removed. The registered notification has
   * been dispatched and executed successfully.
   **/
  | {
      name: "Notified";
      data: { queryId: bigint; palletIndex: number; callIndex: number };
    }
  /**
   * Query response has been received and query is removed. The registered notification
   * could not be dispatched because the dispatch weight is greater than the maximum weight
   * originally budgeted by this runtime for the query result.
   **/
  | {
      name: "NotifyOverweight";
      data: {
        queryId: bigint;
        palletIndex: number;
        callIndex: number;
        actualWeight: SpWeightsWeightV2Weight;
        maxBudgetedWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Query response has been received and query is removed. There was a general error with
   * dispatching the notification call.
   **/
  | {
      name: "NotifyDispatchError";
      data: { queryId: bigint; palletIndex: number; callIndex: number };
    }
  /**
   * Query response has been received and query is removed. The dispatch was unable to be
   * decoded into a `Call`; this might be due to dispatch function having a signature which
   * is not `(origin, QueryId, Response)`.
   **/
  | {
      name: "NotifyDecodeFailed";
      data: { queryId: bigint; palletIndex: number; callIndex: number };
    }
  /**
   * Expected query response has been received but the origin location of the response does
   * not match that expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: "InvalidResponder";
      data: {
        origin: StagingXcmV5Location;
        queryId: bigint;
        expectedLocation?: StagingXcmV5Location | undefined;
      };
    }
  /**
   * Expected query response has been received but the expected origin location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | {
      name: "InvalidResponderVersion";
      data: { origin: StagingXcmV5Location; queryId: bigint };
    }
  /**
   * Received query response has been read and removed.
   **/
  | { name: "ResponseTaken"; data: { queryId: bigint } }
  /**
   * Some assets have been placed in an asset trap.
   **/
  | {
      name: "AssetsTrapped";
      data: {
        hash: H256;
        origin: StagingXcmV5Location;
        assets: XcmVersionedAssets;
      };
    }
  /**
   * An XCM version change notification message has been attempted to be sent.
   *
   * The cost of sending it (borne by the chain) is included.
   **/
  | {
      name: "VersionChangeNotified";
      data: {
        destination: StagingXcmV5Location;
        result: number;
        cost: StagingXcmV5AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * The supported version of a location has been changed. This might be through an
   * automatic notification or a manual intervention.
   **/
  | {
      name: "SupportedVersionChanged";
      data: { location: StagingXcmV5Location; version: number };
    }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * sending the notification to it.
   **/
  | {
      name: "NotifyTargetSendFail";
      data: {
        location: StagingXcmV5Location;
        queryId: bigint;
        error: XcmV5TraitsError;
      };
    }
  /**
   * A given location which had a version change subscription was dropped owing to an error
   * migrating the location to our new XCM format.
   **/
  | {
      name: "NotifyTargetMigrationFail";
      data: { location: XcmVersionedLocation; queryId: bigint };
    }
  /**
   * Expected query response has been received but the expected querier location placed in
   * storage by this runtime previously cannot be decoded. The query remains registered.
   *
   * This is unexpected (since a location placed in storage in a previously executing
   * runtime should be readable prior to query timeout) and dangerous since the possibly
   * valid response will be dropped. Manual governance intervention is probably going to be
   * needed.
   **/
  | {
      name: "InvalidQuerierVersion";
      data: { origin: StagingXcmV5Location; queryId: bigint };
    }
  /**
   * Expected query response has been received but the querier location of the response does
   * not match the expected. The query remains registered for a later, valid, response to
   * be received and acted upon.
   **/
  | {
      name: "InvalidQuerier";
      data: {
        origin: StagingXcmV5Location;
        queryId: bigint;
        expectedQuerier: StagingXcmV5Location;
        maybeActualQuerier?: StagingXcmV5Location | undefined;
      };
    }
  /**
   * A remote has requested XCM version change notification from us and we have honored it.
   * A version information message is sent to them and its cost is included.
   **/
  | {
      name: "VersionNotifyStarted";
      data: {
        destination: StagingXcmV5Location;
        cost: StagingXcmV5AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain send us XCM version change notifications.
   **/
  | {
      name: "VersionNotifyRequested";
      data: {
        destination: StagingXcmV5Location;
        cost: StagingXcmV5AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * We have requested that a remote chain stops sending us XCM version change
   * notifications.
   **/
  | {
      name: "VersionNotifyUnrequested";
      data: {
        destination: StagingXcmV5Location;
        cost: StagingXcmV5AssetAssets;
        messageId: FixedBytes<32>;
      };
    }
  /**
   * Fees were paid from a location for an operation (often for using `SendXcm`).
   **/
  | {
      name: "FeesPaid";
      data: { paying: StagingXcmV5Location; fees: StagingXcmV5AssetAssets };
    }
  /**
   * Some assets have been claimed from an asset trap
   **/
  | {
      name: "AssetsClaimed";
      data: {
        hash: H256;
        origin: StagingXcmV5Location;
        assets: XcmVersionedAssets;
      };
    }
  /**
   * A XCM version migration finished.
   **/
  | { name: "VersionMigrationFinished"; data: { version: number } };

export type StagingXcmV5TraitsOutcome =
  | { type: "Complete"; value: { used: SpWeightsWeightV2Weight } }
  | {
      type: "Incomplete";
      value: { used: SpWeightsWeightV2Weight; error: XcmV5TraitsError };
    }
  | { type: "Error"; value: { error: XcmV5TraitsError } };

export type XcmV5TraitsError =
  | { type: "Overflow" }
  | { type: "Unimplemented" }
  | { type: "UntrustedReserveLocation" }
  | { type: "UntrustedTeleportLocation" }
  | { type: "LocationFull" }
  | { type: "LocationNotInvertible" }
  | { type: "BadOrigin" }
  | { type: "InvalidLocation" }
  | { type: "AssetNotFound" }
  | { type: "FailedToTransactAsset" }
  | { type: "NotWithdrawable" }
  | { type: "LocationCannotHold" }
  | { type: "ExceedsMaxMessageSize" }
  | { type: "DestinationUnsupported" }
  | { type: "Transport" }
  | { type: "Unroutable" }
  | { type: "UnknownClaim" }
  | { type: "FailedToDecode" }
  | { type: "MaxWeightInvalid" }
  | { type: "NotHoldingFees" }
  | { type: "TooExpensive" }
  | { type: "Trap"; value: bigint }
  | { type: "ExpectationFalse" }
  | { type: "PalletNotFound" }
  | { type: "NameMismatch" }
  | { type: "VersionIncompatible" }
  | { type: "HoldingWouldOverflow" }
  | { type: "ExportError" }
  | { type: "ReanchorFailed" }
  | { type: "NoDeal" }
  | { type: "FeesNotMet" }
  | { type: "LockError" }
  | { type: "NoPermission" }
  | { type: "Unanchored" }
  | { type: "NotDepositable" }
  | { type: "TooManyAssets" }
  | { type: "UnhandledXcmVersion" }
  | { type: "WeightLimitReached"; value: SpWeightsWeightV2Weight }
  | { type: "Barrier" }
  | { type: "WeightNotComputable" }
  | { type: "ExceedsStackLimit" };

export type StagingXcmV5Xcm = Array<StagingXcmV5Instruction>;

export type StagingXcmV5Instruction =
  | { type: "WithdrawAsset"; value: StagingXcmV5AssetAssets }
  | { type: "ReserveAssetDeposited"; value: StagingXcmV5AssetAssets }
  | { type: "ReceiveTeleportedAsset"; value: StagingXcmV5AssetAssets }
  | {
      type: "QueryResponse";
      value: {
        queryId: bigint;
        response: StagingXcmV5Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV5Location | undefined;
      };
    }
  | {
      type: "TransferAsset";
      value: {
        assets: StagingXcmV5AssetAssets;
        beneficiary: StagingXcmV5Location;
      };
    }
  | {
      type: "TransferReserveAsset";
      value: {
        assets: StagingXcmV5AssetAssets;
        dest: StagingXcmV5Location;
        xcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "Transact";
      value: {
        originKind: XcmV3OriginKind;
        fallbackMaxWeight?: SpWeightsWeightV2Weight | undefined;
        call: XcmDoubleEncoded;
      };
    }
  | {
      type: "HrmpNewChannelOpenRequest";
      value: { sender: number; maxMessageSize: number; maxCapacity: number };
    }
  | { type: "HrmpChannelAccepted"; value: { recipient: number } }
  | {
      type: "HrmpChannelClosing";
      value: { initiator: number; sender: number; recipient: number };
    }
  | { type: "ClearOrigin" }
  | { type: "DescendOrigin"; value: StagingXcmV5Junctions }
  | { type: "ReportError"; value: StagingXcmV5QueryResponseInfo }
  | {
      type: "DepositAsset";
      value: {
        assets: StagingXcmV5AssetAssetFilter;
        beneficiary: StagingXcmV5Location;
      };
    }
  | {
      type: "DepositReserveAsset";
      value: {
        assets: StagingXcmV5AssetAssetFilter;
        dest: StagingXcmV5Location;
        xcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "ExchangeAsset";
      value: {
        give: StagingXcmV5AssetAssetFilter;
        want: StagingXcmV5AssetAssets;
        maximal: boolean;
      };
    }
  | {
      type: "InitiateReserveWithdraw";
      value: {
        assets: StagingXcmV5AssetAssetFilter;
        reserve: StagingXcmV5Location;
        xcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "InitiateTeleport";
      value: {
        assets: StagingXcmV5AssetAssetFilter;
        dest: StagingXcmV5Location;
        xcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "ReportHolding";
      value: {
        responseInfo: StagingXcmV5QueryResponseInfo;
        assets: StagingXcmV5AssetAssetFilter;
      };
    }
  | {
      type: "BuyExecution";
      value: { fees: StagingXcmV5Asset; weightLimit: XcmV3WeightLimit };
    }
  | { type: "RefundSurplus" }
  | { type: "SetErrorHandler"; value: StagingXcmV5Xcm }
  | { type: "SetAppendix"; value: StagingXcmV5Xcm }
  | { type: "ClearError" }
  | {
      type: "ClaimAsset";
      value: { assets: StagingXcmV5AssetAssets; ticket: StagingXcmV5Location };
    }
  | { type: "Trap"; value: bigint }
  | {
      type: "SubscribeVersion";
      value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight };
    }
  | { type: "UnsubscribeVersion" }
  | { type: "BurnAsset"; value: StagingXcmV5AssetAssets }
  | { type: "ExpectAsset"; value: StagingXcmV5AssetAssets }
  | { type: "ExpectOrigin"; value?: StagingXcmV5Location | undefined }
  | { type: "ExpectError"; value?: [number, XcmV5TraitsError] | undefined }
  | { type: "ExpectTransactStatus"; value: XcmV3MaybeErrorCode }
  | {
      type: "QueryPallet";
      value: { moduleName: Bytes; responseInfo: StagingXcmV5QueryResponseInfo };
    }
  | {
      type: "ExpectPallet";
      value: {
        index: number;
        name: Bytes;
        moduleName: Bytes;
        crateMajor: number;
        minCrateMinor: number;
      };
    }
  | { type: "ReportTransactStatus"; value: StagingXcmV5QueryResponseInfo }
  | { type: "ClearTransactStatus" }
  | { type: "UniversalOrigin"; value: StagingXcmV5Junction }
  | {
      type: "ExportMessage";
      value: {
        network: StagingXcmV5JunctionNetworkId;
        destination: StagingXcmV5Junctions;
        xcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "LockAsset";
      value: { asset: StagingXcmV5Asset; unlocker: StagingXcmV5Location };
    }
  | {
      type: "UnlockAsset";
      value: { asset: StagingXcmV5Asset; target: StagingXcmV5Location };
    }
  | {
      type: "NoteUnlockable";
      value: { asset: StagingXcmV5Asset; owner: StagingXcmV5Location };
    }
  | {
      type: "RequestUnlock";
      value: { asset: StagingXcmV5Asset; locker: StagingXcmV5Location };
    }
  | { type: "SetFeesMode"; value: { jitWithdraw: boolean } }
  | { type: "SetTopic"; value: FixedBytes<32> }
  | { type: "ClearTopic" }
  | { type: "AliasOrigin"; value: StagingXcmV5Location }
  | {
      type: "UnpaidExecution";
      value: {
        weightLimit: XcmV3WeightLimit;
        checkOrigin?: StagingXcmV5Location | undefined;
      };
    }
  | { type: "PayFees"; value: { asset: StagingXcmV5Asset } }
  | {
      type: "InitiateTransfer";
      value: {
        destination: StagingXcmV5Location;
        remoteFees?: StagingXcmV5AssetAssetTransferFilter | undefined;
        preserveOrigin: boolean;
        assets: Array<StagingXcmV5AssetAssetTransferFilter>;
        remoteXcm: StagingXcmV5Xcm;
      };
    }
  | {
      type: "ExecuteWithOrigin";
      value: {
        descendantOrigin?: StagingXcmV5Junctions | undefined;
        xcm: StagingXcmV5Xcm;
      };
    }
  | { type: "SetHints"; value: { hints: Array<StagingXcmV5Hint> } };

export type StagingXcmV5AssetAssets = Array<StagingXcmV5Asset>;

export type StagingXcmV5Asset = {
  id: StagingXcmV5AssetAssetId;
  fun: StagingXcmV5AssetFungibility;
};

export type StagingXcmV5AssetAssetId = StagingXcmV5Location;

export type StagingXcmV5AssetFungibility =
  | { type: "Fungible"; value: bigint }
  | { type: "NonFungible"; value: StagingXcmV5AssetAssetInstance };

export type StagingXcmV5AssetAssetInstance =
  | { type: "Undefined" }
  | { type: "Index"; value: bigint }
  | { type: "Array4"; value: FixedBytes<4> }
  | { type: "Array8"; value: FixedBytes<8> }
  | { type: "Array16"; value: FixedBytes<16> }
  | { type: "Array32"; value: FixedBytes<32> };

export type StagingXcmV5Response =
  | { type: "Null" }
  | { type: "Assets"; value: StagingXcmV5AssetAssets }
  | { type: "ExecutionResult"; value?: [number, XcmV5TraitsError] | undefined }
  | { type: "Version"; value: number }
  | { type: "PalletsInfo"; value: Array<StagingXcmV5PalletInfo> }
  | { type: "DispatchResult"; value: XcmV3MaybeErrorCode };

export type StagingXcmV5PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3MaybeErrorCode =
  | { type: "Success" }
  | { type: "Error"; value: Bytes }
  | { type: "TruncatedError"; value: Bytes };

export type XcmV3OriginKind =
  | "Native"
  | "SovereignAccount"
  | "Superuser"
  | "Xcm";

export type XcmDoubleEncoded = { encoded: Bytes };

export type StagingXcmV5QueryResponseInfo = {
  destination: StagingXcmV5Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV5AssetAssetFilter =
  | { type: "Definite"; value: StagingXcmV5AssetAssets }
  | { type: "Wild"; value: StagingXcmV5AssetWildAsset };

export type StagingXcmV5AssetWildAsset =
  | { type: "All" }
  | {
      type: "AllOf";
      value: {
        id: StagingXcmV5AssetAssetId;
        fun: StagingXcmV5AssetWildFungibility;
      };
    }
  | { type: "AllCounted"; value: number }
  | {
      type: "AllOfCounted";
      value: {
        id: StagingXcmV5AssetAssetId;
        fun: StagingXcmV5AssetWildFungibility;
        count: number;
      };
    };

export type StagingXcmV5AssetWildFungibility = "Fungible" | "NonFungible";

export type XcmV3WeightLimit =
  | { type: "Unlimited" }
  | { type: "Limited"; value: SpWeightsWeightV2Weight };

export type StagingXcmV5AssetAssetTransferFilter =
  | { type: "Teleport"; value: StagingXcmV5AssetAssetFilter }
  | { type: "ReserveDeposit"; value: StagingXcmV5AssetAssetFilter }
  | { type: "ReserveWithdraw"; value: StagingXcmV5AssetAssetFilter };

export type StagingXcmV5Hint = {
  type: "AssetClaimer";
  value: { location: StagingXcmV5Location };
};

export type XcmVersionedAssets =
  | { type: "V3"; value: XcmV3MultiassetMultiAssets }
  | { type: "V4"; value: StagingXcmV4AssetAssets }
  | { type: "V5"; value: StagingXcmV5AssetAssets };

export type XcmV3MultiassetMultiAssets = Array<XcmV3MultiassetMultiAsset>;

export type XcmV3MultiassetMultiAsset = {
  id: XcmV3MultiassetAssetId;
  fun: XcmV3MultiassetFungibility;
};

export type XcmV3MultiassetAssetId =
  | { type: "Concrete"; value: StagingXcmV3MultilocationMultiLocation }
  | { type: "Abstract"; value: FixedBytes<32> };

export type XcmV3MultiassetFungibility =
  | { type: "Fungible"; value: bigint }
  | { type: "NonFungible"; value: XcmV3MultiassetAssetInstance };

export type XcmV3MultiassetAssetInstance =
  | { type: "Undefined" }
  | { type: "Index"; value: bigint }
  | { type: "Array4"; value: FixedBytes<4> }
  | { type: "Array8"; value: FixedBytes<8> }
  | { type: "Array16"; value: FixedBytes<16> }
  | { type: "Array32"; value: FixedBytes<32> };

export type StagingXcmV4AssetAssets = Array<StagingXcmV4Asset>;

export type StagingXcmV4Asset = {
  id: StagingXcmV4AssetAssetId;
  fun: StagingXcmV4AssetFungibility;
};

export type StagingXcmV4AssetAssetId = StagingXcmV4Location;

export type StagingXcmV4AssetFungibility =
  | { type: "Fungible"; value: bigint }
  | { type: "NonFungible"; value: StagingXcmV4AssetAssetInstance };

export type StagingXcmV4AssetAssetInstance =
  | { type: "Undefined" }
  | { type: "Index"; value: bigint }
  | { type: "Array4"; value: FixedBytes<4> }
  | { type: "Array8"; value: FixedBytes<8> }
  | { type: "Array16"; value: FixedBytes<16> }
  | { type: "Array32"; value: FixedBytes<32> };

export type XcmVersionedLocation =
  | { type: "V3"; value: StagingXcmV3MultilocationMultiLocation }
  | { type: "V4"; value: StagingXcmV4Location }
  | { type: "V5"; value: StagingXcmV5Location };

/**
 * The `Event` enum of this pallet
 **/
export type CumulusPalletXcmEvent =
  /**
   * Downward message is invalid XCM.
   * \[ id \]
   **/
  | { name: "InvalidFormat"; data: FixedBytes<32> }
  /**
   * Downward message is unsupported version of XCM.
   * \[ id \]
   **/
  | { name: "UnsupportedVersion"; data: FixedBytes<32> }
  /**
   * Downward message executed with the given outcome.
   * \[ id, outcome \]
   **/
  | {
      name: "ExecutedDownward";
      data: [FixedBytes<32>, StagingXcmV5TraitsOutcome];
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMessageQueueEvent =
  /**
   * Message discarded due to an error in the `MessageProcessor` (usually a format error).
   **/
  | {
      name: "ProcessingFailed";
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The error that occurred.
         *
         * This error is pretty opaque. More fine-grained errors need to be emitted as events
         * by the `MessageProcessor`.
         **/
        error: FrameSupportMessagesProcessMessageError;
      };
    }
  /**
   * Message is processed.
   **/
  | {
      name: "Processed";
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: H256;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * How much weight was used to process the message.
         **/
        weightUsed: SpWeightsWeightV2Weight;

        /**
         * Whether the message was processed.
         *
         * Note that this does not mean that the underlying `MessageProcessor` was internally
         * successful. It *solely* means that the MQ pallet will treat this as a success
         * condition and discard the message. Any internal error needs to be emitted as events
         * by the `MessageProcessor`.
         **/
        success: boolean;
      };
    }
  /**
   * Message placed in overweight queue.
   **/
  | {
      name: "OverweightEnqueued";
      data: {
        /**
         * The `blake2_256` hash of the message.
         **/
        id: FixedBytes<32>;

        /**
         * The queue of the message.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The page of the message.
         **/
        pageIndex: number;

        /**
         * The index of the message within the page.
         **/
        messageIndex: number;
      };
    }
  /**
   * This page was reaped.
   **/
  | {
      name: "PageReaped";
      data: {
        /**
         * The queue of the page.
         **/
        origin: CumulusPrimitivesCoreAggregateMessageOrigin;

        /**
         * The index of the page.
         **/
        index: number;
      };
    };

export type CumulusPrimitivesCoreAggregateMessageOrigin =
  | { type: "Here" }
  | { type: "Parent" }
  | { type: "Sibling"; value: PolkadotParachainPrimitivesPrimitivesId };

export type FrameSupportMessagesProcessMessageError =
  | { type: "BadFormat" }
  | { type: "Corrupt" }
  | { type: "Unsupported" }
  | { type: "Overweight"; value: SpWeightsWeightV2Weight }
  | { type: "Yield" }
  | { type: "StackLimitReached" };

/**
 * The `Event` enum of this pallet
 **/
export type PalletTreasuryEvent =
  /**
   * We have ended a spend period and will now allocate funds.
   **/
  | { name: "Spending"; data: { budgetRemaining: bigint } }
  /**
   * Some funds have been allocated.
   **/
  | {
      name: "Awarded";
      data: { proposalIndex: number; award: bigint; account: AccountId32 };
    }
  /**
   * Some of our funds have been burnt.
   **/
  | { name: "Burnt"; data: { burntFunds: bigint } }
  /**
   * Spending has finished; this is the amount that rolls over until next spend.
   **/
  | { name: "Rollover"; data: { rolloverBalance: bigint } }
  /**
   * Some funds have been deposited.
   **/
  | { name: "Deposit"; data: { value: bigint } }
  /**
   * A new spend proposal has been approved.
   **/
  | {
      name: "SpendApproved";
      data: { proposalIndex: number; amount: bigint; beneficiary: AccountId32 };
    }
  /**
   * The inactive funds of the pallet have been updated.
   **/
  | {
      name: "UpdatedInactive";
      data: { reactivated: bigint; deactivated: bigint };
    }
  /**
   * A new asset spend proposal has been approved.
   **/
  | {
      name: "AssetSpendApproved";
      data: {
        index: number;
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom: number;
        expireAt: number;
      };
    }
  /**
   * An approved spend was voided.
   **/
  | { name: "AssetSpendVoided"; data: { index: number } }
  /**
   * A payment happened.
   **/
  | { name: "Paid"; data: { index: number; paymentId: [] } }
  /**
   * A payment failed and can be retried.
   **/
  | { name: "PaymentFailed"; data: { index: number; paymentId: [] } }
  /**
   * A spend was processed and removed from the storage. It might have been successfully
   * paid or it may have expired.
   **/
  | { name: "SpendProcessed"; data: { index: number } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletDemocracyEvent =
  /**
   * A motion has been proposed by a public account.
   **/
  | { name: "Proposed"; data: { proposalIndex: number; deposit: bigint } }
  /**
   * A public proposal has been tabled for referendum vote.
   **/
  | { name: "Tabled"; data: { proposalIndex: number; deposit: bigint } }
  /**
   * An external proposal has been tabled.
   **/
  | { name: "ExternalTabled" }
  /**
   * A referendum has begun.
   **/
  | {
      name: "Started";
      data: { refIndex: number; threshold: PalletDemocracyVoteThreshold };
    }
  /**
   * A proposal has been approved by referendum.
   **/
  | { name: "Passed"; data: { refIndex: number } }
  /**
   * A proposal has been rejected by referendum.
   **/
  | { name: "NotPassed"; data: { refIndex: number } }
  /**
   * A referendum has been cancelled.
   **/
  | { name: "Cancelled"; data: { refIndex: number } }
  /**
   * An account has delegated their vote to another account.
   **/
  | { name: "Delegated"; data: { who: AccountId32; target: AccountId32 } }
  /**
   * An account has cancelled a previous delegation operation.
   **/
  | { name: "Undelegated"; data: { account: AccountId32 } }
  /**
   * An external proposal has been vetoed.
   **/
  | {
      name: "Vetoed";
      data: { who: AccountId32; proposalHash: H256; until: number };
    }
  /**
   * A proposal_hash has been blacklisted permanently.
   **/
  | { name: "Blacklisted"; data: { proposalHash: H256 } }
  /**
   * An account has voted in a referendum
   **/
  | {
      name: "Voted";
      data: {
        voter: AccountId32;
        refIndex: number;
        vote: PalletDemocracyVoteAccountVote;
      };
    }
  /**
   * An account has secconded a proposal
   **/
  | { name: "Seconded"; data: { seconder: AccountId32; propIndex: number } }
  /**
   * A proposal got canceled.
   **/
  | { name: "ProposalCanceled"; data: { propIndex: number } }
  /**
   * Metadata for a proposal or a referendum has been set.
   **/
  | {
      name: "MetadataSet";
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata for a proposal or a referendum has been cleared.
   **/
  | {
      name: "MetadataCleared";
      data: {
        /**
         * Metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    }
  /**
   * Metadata has been transferred to new owner.
   **/
  | {
      name: "MetadataTransferred";
      data: {
        /**
         * Previous metadata owner.
         **/
        prevOwner: PalletDemocracyMetadataOwner;

        /**
         * New metadata owner.
         **/
        owner: PalletDemocracyMetadataOwner;

        /**
         * Preimage hash.
         **/
        hash: H256;
      };
    };

export type PalletDemocracyVoteThreshold =
  | "SuperMajorityApprove"
  | "SuperMajorityAgainst"
  | "SimpleMajority";

export type PalletDemocracyVoteAccountVote =
  | { type: "Standard"; value: { vote: PalletDemocracyVote; balance: bigint } }
  | { type: "Split"; value: { aye: bigint; nay: bigint } };

export type PalletDemocracyVote = number;

export type PalletDemocracyMetadataOwner =
  | { type: "External" }
  | { type: "Proposal"; value: number }
  | { type: "Referendum"; value: number };

/**
 * The `Event` enum of this pallet
 **/
export type PalletCollectiveEvent =
  /**
   * A motion (given hash) has been proposed (by given account) with a threshold (given
   * `MemberCount`).
   **/
  | {
      name: "Proposed";
      data: {
        account: AccountId32;
        proposalIndex: number;
        proposalHash: H256;
        threshold: number;
      };
    }
  /**
   * A motion (given hash) has been voted on by given account, leaving
   * a tally (yes votes and no votes given respectively as `MemberCount`).
   **/
  | {
      name: "Voted";
      data: {
        account: AccountId32;
        proposalHash: H256;
        voted: boolean;
        yes: number;
        no: number;
      };
    }
  /**
   * A motion was approved by the required threshold.
   **/
  | { name: "Approved"; data: { proposalHash: H256 } }
  /**
   * A motion was not approved by the required threshold.
   **/
  | { name: "Disapproved"; data: { proposalHash: H256 } }
  /**
   * A motion was executed; result will be `Ok` if it returned without error.
   **/
  | {
      name: "Executed";
      data: { proposalHash: H256; result: Result<[], DispatchError> };
    }
  /**
   * A single member did some action; result will be `Ok` if it returned without error.
   **/
  | {
      name: "MemberExecuted";
      data: { proposalHash: H256; result: Result<[], DispatchError> };
    }
  /**
   * A proposal was closed because its threshold was reached or after its duration was up.
   **/
  | { name: "Closed"; data: { proposalHash: H256; yes: number; no: number } }
  /**
   * A proposal was killed.
   **/
  | { name: "Killed"; data: { proposalHash: H256 } }
  /**
   * Some cost for storing a proposal was burned.
   **/
  | {
      name: "ProposalCostBurned";
      data: { proposalHash: H256; who: AccountId32 };
    }
  /**
   * Some cost for storing a proposal was released.
   **/
  | {
      name: "ProposalCostReleased";
      data: { proposalHash: H256; who: AccountId32 };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletElectionsPhragmenEvent =
  /**
   * A new term with new_members. This indicates that enough candidates existed to run
   * the election, not that enough have has been elected. The inner value must be examined
   * for this purpose. A `NewTerm(\[\])` indicates that some candidates got their bond
   * slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to
   * begin with.
   **/
  | { name: "NewTerm"; data: { newMembers: Array<[AccountId32, bigint]> } }
  /**
   * No (or not enough) candidates existed for this round. This is different from
   * `NewTerm(\[\])`. See the description of `NewTerm`.
   **/
  | { name: "EmptyTerm" }
  /**
   * Internal error happened while trying to perform election.
   **/
  | { name: "ElectionError" }
  /**
   * A member has been removed. This should always be followed by either `NewTerm` or
   * `EmptyTerm`.
   **/
  | { name: "MemberKicked"; data: { member: AccountId32 } }
  /**
   * Someone has renounced their candidacy.
   **/
  | { name: "Renounced"; data: { candidate: AccountId32 } }
  /**
   * A candidate was slashed by amount due to failing to obtain a seat as member or
   * runner-up.
   *
   * Note that old members and runners-up are also candidates.
   **/
  | {
      name: "CandidateSlashed";
      data: { candidate: AccountId32; amount: bigint };
    }
  /**
   * A seat holder was slashed by amount by being forcefully removed from the set.
   **/
  | {
      name: "SeatHolderSlashed";
      data: { seatHolder: AccountId32; amount: bigint };
    };

/**
 * The `Event` enum of this pallet
 **/
export type PalletPreimageEvent =
  /**
   * A preimage has been noted.
   **/
  | { name: "Noted"; data: { hash: H256 } }
  /**
   * A preimage has been requested.
   **/
  | { name: "Requested"; data: { hash: H256 } }
  /**
   * A preimage has ben cleared.
   **/
  | { name: "Cleared"; data: { hash: H256 } };

/**
 * Events type.
 **/
export type PalletSchedulerEvent =
  /**
   * Scheduled some task.
   **/
  | { name: "Scheduled"; data: { when: number; index: number } }
  /**
   * Canceled some task.
   **/
  | { name: "Canceled"; data: { when: number; index: number } }
  /**
   * Dispatched some task.
   **/
  | {
      name: "Dispatched";
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        result: Result<[], DispatchError>;
      };
    }
  /**
   * Set a retry configuration for some task.
   **/
  | {
      name: "RetrySet";
      data: {
        task: [number, number];
        id?: FixedBytes<32> | undefined;
        period: number;
        retries: number;
      };
    }
  /**
   * Cancel a retry configuration for some task.
   **/
  | {
      name: "RetryCancelled";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The call for the provided hash was not found so the task has been aborted.
   **/
  | {
      name: "CallUnavailable";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be renewed since the agenda is full at that block.
   **/
  | {
      name: "PeriodicFailed";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task was unable to be retried since the agenda is full at that block or there
   * was not enough weight to reschedule it.
   **/
  | {
      name: "RetryFailed";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    }
  /**
   * The given task can never be executed since it is overweight.
   **/
  | {
      name: "PermanentlyOverweight";
      data: { task: [number, number]; id?: FixedBytes<32> | undefined };
    };

/**
 * The `Event` enum of this pallet
 **/
export type OrmlOracleModuleEvent =
  /**
   * New feed data is submitted.
   **/
  {
    name: "NewFeedData";
    data: {
      sender: AccountId32;
      values: Array<[StagingXcmV4Location, FixedU128]>;
    };
  };

/**
 * The `Event` enum of this pallet
 **/
export type PalletMembershipEvent =
  /**
   * The given member was added; see the transaction for who.
   **/
  | "MemberAdded"
  /**
   * The given member was removed; see the transaction for who.
   **/
  | "MemberRemoved"
  /**
   * Two members were swapped; see the transaction for who.
   **/
  | "MembersSwapped"
  /**
   * The membership was reset; see the transaction for who the new set is.
   **/
  | "MembersReset"
  /**
   * One of the members' keys changed.
   **/
  | "KeyChanged"
  /**
   * Phantom member, never used.
   **/
  | "Dummy";

/**
 * The `Event` enum of this pallet
 **/
export type PalletOracleOcwEvent = null;

/**
 * The `Event` enum of this pallet
 **/
export type PalletFundingEvent =
  /**
   * A project was created.
   **/
  | {
      name: "ProjectCreated";
      data: {
        projectId: number;
        issuer: AccountId32;
        metadata: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * An issuer removed the project before the evaluation started
   **/
  | { name: "ProjectRemoved"; data: { projectId: number; issuer: AccountId32 } }
  /**
   * The metadata of a project was modified.
   **/
  | {
      name: "MetadataEdited";
      data: {
        projectId: number;
        metadata: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * Project transitioned to a new phase.
   **/
  | {
      name: "ProjectPhaseTransition";
      data: { projectId: number; phase: PalletFundingInnerProjectStatus };
    }
  /**
   * A `bonder` bonded an `amount` of PLMC for `project_id`.
   **/
  | {
      name: "Evaluation";
      data: {
        projectId: number;
        evaluator: AccountId32;
        id: number;
        plmcAmount: bigint;
      };
    }
  /**
   * A bid was made for a project
   **/
  | {
      name: "Bid";
      data: {
        projectId: number;
        bidder: AccountId32;
        id: number;
        ctAmount: bigint;
        ctPrice: FixedU128;
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
        fundingAmount: bigint;
        plmcBond: bigint;
        mode: PalletFundingInnerParticipationMode;
      };
    }
  /**
   * An oversubscribed bid has been marked as rejected, and can now be settled early and release the funds back to the user.
   **/
  | {
      name: "OversubscribedBidProcessed";
      data: { projectId: number; bidId: number };
    }
  /**
   * An evaluation was settled. PLMC has been unbonded with either a CT reward or a PLMC slash depending on the project outcome.
   **/
  | {
      name: "EvaluationSettled";
      data: {
        projectId: number;
        account: AccountId32;
        id: number;
        ctRewarded: bigint;
        plmcReleased: bigint;
      };
    }
  /**
   * A bid was settled. On Funding Success the PLMC has been unbonded/locked with a vesting schedule and the funding assets have been transferred to the issuer.
   * Some funds and PLMC might have been returned to the bidder if they paid a higher price than the final CT price.
   * If Funding Failed, the PLMC has been unbonded and the funds have been returned to the bidder.
   **/
  | {
      name: "BidSettled";
      data: {
        projectId: number;
        account: AccountId32;
        id: number;
        status: PalletFundingInnerBidStatus;
        finalCtAmount: bigint;
      };
    }
  /**
   * Issuer started the CT migration to mainnet tokens using the pallet migration method
   **/
  | {
      name: "PalletMigrationStarted";
      data: {
        projectId: number;
        paraId: PolkadotParachainPrimitivesPrimitivesId;
      };
    }
  /**
   * A channel was accepted from a parachain to Polimec belonging to a project. A request has been sent to the relay for a Polimec->project channel
   **/
  | {
      name: "HrmpChannelAccepted";
      data: {
        projectId: number;
        paraId: PolkadotParachainPrimitivesPrimitivesId;
      };
    }
  /**
   * A channel was established from Polimec to a project. The relay has notified us of their acceptance of our request
   **/
  | {
      name: "HrmpChannelEstablished";
      data: {
        projectId: number;
        paraId: PolkadotParachainPrimitivesPrimitivesId;
      };
    }
  /**
   * Started a migration readiness check
   **/
  | {
      name: "MigrationReadinessCheckStarted";
      data: { projectId: number; caller: AccountId32 };
    }
  /**
   * Migration readiness check was accepted
   **/
  | {
      name: "MigrationCheckResponseAccepted";
      data: {
        projectId: number;
        queryId: bigint;
        response: StagingXcmV4Response;
      };
    }
  /**
   * Migration readiness check was rejected
   **/
  | {
      name: "MigrationCheckResponseRejected";
      data: {
        projectId: number;
        queryId: bigint;
        response: StagingXcmV4Response;
      };
    }
  /**
   * A user's CT migrations status was updated
   **/
  | {
      name: "MigrationStatusUpdated";
      data: {
        projectId: number;
        account: AccountId32;
        status: PolimecCommonMigrationTypesMigrationStatus;
      };
    }
  /**
   * The CT migration of a project has been completed. All CTs were converted to mainnet tokens.
   **/
  | { name: "CtMigrationFinished"; data: { projectId: number } };

export type PalletFundingStorageProjectMetadata = {
  tokenInformation: PalletFundingInnerCurrencyMetadata;
  mainnetTokenMaxSupply: bigint;
  totalAllocationSize: bigint;
  minimumPrice: FixedU128;
  biddingTicketSizes: PalletFundingInnerBiddingTicketSizes;
  participationCurrencies: Array<PolimecCommonAssetsAcceptedFundingAsset>;
  fundingDestinationAccount: AccountId32;
  policyIpfsCid?: Bytes | undefined;
  participantsAccountType: PalletFundingInnerParticipantsAccountType;
};

export type PalletFundingInnerCurrencyMetadata = {
  name: Bytes;
  symbol: Bytes;
  decimals: number;
};

export type PalletFundingInnerBiddingTicketSizes = {
  professional: PalletFundingInnerTicketSize;
  institutional: PalletFundingInnerTicketSize;
  retail: PalletFundingInnerTicketSize;
};

export type PalletFundingInnerTicketSize = {
  usdMinimumPerParticipation: bigint;
  usdMaximumPerDid?: bigint | undefined;
};

export type PolimecCommonAssetsAcceptedFundingAsset =
  | "Usdt"
  | "Usdc"
  | "Dot"
  | "Eth";

export type PalletFundingInnerParticipantsAccountType = "Polkadot" | "Ethereum";

export type PalletFundingInnerProjectStatus =
  | { type: "Application" }
  | { type: "EvaluationRound" }
  | { type: "AuctionRound" }
  | { type: "FundingFailed" }
  | { type: "FundingSuccessful" }
  | { type: "SettlementStarted"; value: PalletFundingInnerFundingOutcome }
  | { type: "SettlementFinished"; value: PalletFundingInnerFundingOutcome }
  | { type: "CtMigrationStarted" }
  | { type: "CtMigrationFinished" };

export type PalletFundingInnerFundingOutcome = "Success" | "Failure";

export type PalletFundingInnerParticipationMode =
  | { type: "Otm" }
  | { type: "Classic"; value: number };

export type PalletFundingInnerBidStatus =
  | { type: "YetUnknown" }
  | { type: "Accepted" }
  | { type: "Rejected" }
  | { type: "PartiallyAccepted"; value: bigint };

export type StagingXcmV4Response =
  | { type: "Null" }
  | { type: "Assets"; value: StagingXcmV4AssetAssets }
  | { type: "ExecutionResult"; value?: [number, XcmV3TraitsError] | undefined }
  | { type: "Version"; value: number }
  | { type: "PalletsInfo"; value: Array<StagingXcmV4PalletInfo> }
  | { type: "DispatchResult"; value: XcmV3MaybeErrorCode };

export type XcmV3TraitsError =
  | { type: "Overflow" }
  | { type: "Unimplemented" }
  | { type: "UntrustedReserveLocation" }
  | { type: "UntrustedTeleportLocation" }
  | { type: "LocationFull" }
  | { type: "LocationNotInvertible" }
  | { type: "BadOrigin" }
  | { type: "InvalidLocation" }
  | { type: "AssetNotFound" }
  | { type: "FailedToTransactAsset" }
  | { type: "NotWithdrawable" }
  | { type: "LocationCannotHold" }
  | { type: "ExceedsMaxMessageSize" }
  | { type: "DestinationUnsupported" }
  | { type: "Transport" }
  | { type: "Unroutable" }
  | { type: "UnknownClaim" }
  | { type: "FailedToDecode" }
  | { type: "MaxWeightInvalid" }
  | { type: "NotHoldingFees" }
  | { type: "TooExpensive" }
  | { type: "Trap"; value: bigint }
  | { type: "ExpectationFalse" }
  | { type: "PalletNotFound" }
  | { type: "NameMismatch" }
  | { type: "VersionIncompatible" }
  | { type: "HoldingWouldOverflow" }
  | { type: "ExportError" }
  | { type: "ReanchorFailed" }
  | { type: "NoDeal" }
  | { type: "FeesNotMet" }
  | { type: "LockError" }
  | { type: "NoPermission" }
  | { type: "Unanchored" }
  | { type: "NotDepositable" }
  | { type: "UnhandledXcmVersion" }
  | { type: "WeightLimitReached"; value: SpWeightsWeightV2Weight }
  | { type: "Barrier" }
  | { type: "WeightNotComputable" }
  | { type: "ExceedsStackLimit" };

export type StagingXcmV4PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type PolimecCommonMigrationTypesMigrationStatus =
  | "NotStarted"
  | "Confirmed";

/**
 * The `Event` enum of this pallet
 **/
export type PalletLinearReleaseEvent =
  /**
   * The amount vested has been updated. This could indicate a change in funds available.
   * The balance given is the amount which is left unvested (and thus locked).
   **/
  | { name: "VestingUpdated"; data: { account: AccountId32; unvested: bigint } }
  /**
   * An `account` has become fully vested.
   **/
  | { name: "VestingCompleted"; data: { account: AccountId32 } }
  | { name: "VestingTransferred"; data: { to: AccountId32; amount: bigint } };

/**
 * The `Event` enum of this pallet
 **/
export type PalletProxyBondingEvent =
  | { name: "BondsTransferredBackToTreasury"; data: { bondAmount: bigint } }
  | {
      name: "FeesTransferredToFeeRecipient";
      data: { feeAsset: StagingXcmV4Location; feeAmount: bigint };
    };

export type FrameSystemLastRuntimeUpgradeInfo = {
  specVersion: number;
  specName: string;
};

export type FrameSystemCodeUpgradeAuthorization = {
  codeHash: H256;
  checkVersion: boolean;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type FrameSystemCall =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: "Remark"; params: { remark: Bytes } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: "SetCode"; params: { code: Bytes } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: Bytes } }
  /**
   * Set some items of storage.
   **/
  | { name: "SetStorage"; params: { items: Array<[Bytes, Bytes]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: "KillStorage"; params: { keys: Array<Bytes> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: "KillPrefix"; params: { prefix: Bytes; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: "RemarkWithEvent"; params: { remark: Bytes } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: Bytes } };

export type FrameSystemCallLike =
  /**
   * Make some on-chain remark.
   *
   * Can be executed by every `origin`.
   **/
  | { name: "Remark"; params: { remark: BytesLike } }
  /**
   * Set the number of pages in the WebAssembly environment's heap.
   **/
  | { name: "SetHeapPages"; params: { pages: bigint } }
  /**
   * Set the new runtime code.
   **/
  | { name: "SetCode"; params: { code: BytesLike } }
  /**
   * Set the new runtime code without doing any checks of the given `code`.
   *
   * Note that runtime upgrades will not run if this is called with a not-increasing spec
   * version!
   **/
  | { name: "SetCodeWithoutChecks"; params: { code: BytesLike } }
  /**
   * Set some items of storage.
   **/
  | { name: "SetStorage"; params: { items: Array<[BytesLike, BytesLike]> } }
  /**
   * Kill some items from storage.
   **/
  | { name: "KillStorage"; params: { keys: Array<BytesLike> } }
  /**
   * Kill all storage items with a key that starts with the given prefix.
   *
   * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
   * the prefix we are removing to accurately calculate the weight of this function.
   **/
  | { name: "KillPrefix"; params: { prefix: BytesLike; subkeys: number } }
  /**
   * Make some on-chain remark and emit event.
   **/
  | { name: "RemarkWithEvent"; params: { remark: BytesLike } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgrade"; params: { codeHash: H256 } }
  /**
   * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
   * later.
   *
   * WARNING: This authorizes an upgrade that will take place without any safety checks, for
   * example that the spec name remains the same and that the version number increases. Not
   * recommended for normal use. Use `authorize_upgrade` instead.
   *
   * This call requires Root origin.
   **/
  | { name: "AuthorizeUpgradeWithoutChecks"; params: { codeHash: H256 } }
  /**
   * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
   *
   * If the authorization required a version check, this call will ensure the spec name
   * remains unchanged and that the spec version has increased.
   *
   * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
   * the new `code` in the same block or attempt to schedule the upgrade.
   *
   * All origins are allowed.
   **/
  | { name: "ApplyAuthorizedUpgrade"; params: { code: BytesLike } };

export type FrameSystemLimitsBlockWeights = {
  baseBlock: SpWeightsWeightV2Weight;
  maxBlock: SpWeightsWeightV2Weight;
  perClass: FrameSupportDispatchPerDispatchClassWeightsPerClass;
};

export type FrameSupportDispatchPerDispatchClassWeightsPerClass = {
  normal: FrameSystemLimitsWeightsPerClass;
  operational: FrameSystemLimitsWeightsPerClass;
  mandatory: FrameSystemLimitsWeightsPerClass;
};

export type FrameSystemLimitsWeightsPerClass = {
  baseExtrinsic: SpWeightsWeightV2Weight;
  maxExtrinsic?: SpWeightsWeightV2Weight | undefined;
  maxTotal?: SpWeightsWeightV2Weight | undefined;
  reserved?: SpWeightsWeightV2Weight | undefined;
};

export type FrameSystemLimitsBlockLength = {
  max: FrameSupportDispatchPerDispatchClassU32;
};

export type FrameSupportDispatchPerDispatchClassU32 = {
  normal: number;
  operational: number;
  mandatory: number;
};

export type SpWeightsRuntimeDbWeight = { read: bigint; write: bigint };

/**
 * Error for the System pallet
 **/
export type FrameSystemError =
  /**
   * The name of specification does not match between the current runtime
   * and the new runtime.
   **/
  | "InvalidSpecName"
  /**
   * The specification version is not allowed to decrease between the current runtime
   * and the new runtime.
   **/
  | "SpecVersionNeedsToIncrease"
  /**
   * Failed to extract the runtime version from the new runtime.
   *
   * Either calling `Core_version` or decoding `RuntimeVersion` failed.
   **/
  | "FailedToExtractRuntimeVersion"
  /**
   * Suicide called when the account has non-default composite data.
   **/
  | "NonDefaultComposite"
  /**
   * There is a non-zero reference count preventing the account from being purged.
   **/
  | "NonZeroRefCount"
  /**
   * The origin filter prevent the call to be dispatched.
   **/
  | "CallFiltered"
  /**
   * A multi-block migration is ongoing and prevents the current code from being replaced.
   **/
  | "MultiBlockMigrationsOngoing"
  /**
   * No upgrade authorized.
   **/
  | "NothingAuthorized"
  /**
   * The submitted code is not authorized.
   **/
  | "Unauthorized";

export type CumulusPalletParachainSystemUnincludedSegmentAncestor = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  paraHeadHash?: H256 | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV8UpgradeGoAhead | undefined;
};

export type CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth = {
  umpMsgCount: number;
  umpTotalBytes: number;
  hrmpOutgoing: Array<
    [
      PolkadotParachainPrimitivesPrimitivesId,
      CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate,
    ]
  >;
};

export type CumulusPalletParachainSystemUnincludedSegmentHrmpChannelUpdate = {
  msgCount: number;
  totalBytes: number;
};

export type PolkadotPrimitivesV8UpgradeGoAhead = "Abort" | "GoAhead";

export type CumulusPalletParachainSystemUnincludedSegmentSegmentTracker = {
  usedBandwidth: CumulusPalletParachainSystemUnincludedSegmentUsedBandwidth;
  hrmpWatermark?: number | undefined;
  consumedGoAheadSignal?: PolkadotPrimitivesV8UpgradeGoAhead | undefined;
};

export type PolkadotPrimitivesV8PersistedValidationData = {
  parentHead: PolkadotParachainPrimitivesPrimitivesHeadData;
  relayParentNumber: number;
  relayParentStorageRoot: H256;
  maxPovSize: number;
};

export type PolkadotParachainPrimitivesPrimitivesHeadData = Bytes;

export type PolkadotPrimitivesV8UpgradeRestriction = "Present";

export type SpTrieStorageProof = { trieNodes: Array<Bytes> };

export type CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot =
  {
    dmqMqcHead: H256;
    relayDispatchQueueRemainingCapacity: CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity;
    ingressChannels: Array<
      [
        PolkadotParachainPrimitivesPrimitivesId,
        PolkadotPrimitivesV8AbridgedHrmpChannel,
      ]
    >;
    egressChannels: Array<
      [
        PolkadotParachainPrimitivesPrimitivesId,
        PolkadotPrimitivesV8AbridgedHrmpChannel,
      ]
    >;
  };

export type CumulusPalletParachainSystemRelayStateSnapshotRelayDispatchQueueRemainingCapacity =
  { remainingCount: number; remainingSize: number };

export type PolkadotPrimitivesV8AbridgedHrmpChannel = {
  maxCapacity: number;
  maxTotalSize: number;
  maxMessageSize: number;
  msgCount: number;
  totalSize: number;
  mqcHead?: H256 | undefined;
};

export type PolkadotPrimitivesV8AbridgedHostConfiguration = {
  maxCodeSize: number;
  maxHeadDataSize: number;
  maxUpwardQueueCount: number;
  maxUpwardQueueSize: number;
  maxUpwardMessageSize: number;
  maxUpwardMessageNumPerCandidate: number;
  hrmpMaxMessageNumPerCandidate: number;
  validationUpgradeCooldown: number;
  validationUpgradeDelay: number;
  asyncBackingParams: PolkadotPrimitivesV8AsyncBackingAsyncBackingParams;
};

export type PolkadotPrimitivesV8AsyncBackingAsyncBackingParams = {
  maxCandidateDepth: number;
  allowedAncestryLen: number;
};

export type CumulusPrimitivesParachainInherentMessageQueueChain = H256;

export type PolkadotCorePrimitivesOutboundHrmpMessage = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  data: Bytes;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletParachainSystemCall =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | {
      name: "SetValidationData";
      params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
    }
  | { name: "SudoSendUpwardMessage"; params: { message: Bytes } };

export type CumulusPalletParachainSystemCallLike =
  /**
   * Set the current validation data.
   *
   * This should be invoked exactly once per block. It will panic at the finalization
   * phase if the call was not invoked.
   *
   * The dispatch origin for this call must be `Inherent`
   *
   * As a side effect, this function upgrades the current validation function
   * if the appropriate time has come.
   **/
  | {
      name: "SetValidationData";
      params: { data: CumulusPrimitivesParachainInherentParachainInherentData };
    }
  | { name: "SudoSendUpwardMessage"; params: { message: BytesLike } };

export type CumulusPrimitivesParachainInherentParachainInherentData = {
  validationData: PolkadotPrimitivesV8PersistedValidationData;
  relayChainState: SpTrieStorageProof;
  downwardMessages: Array<PolkadotCorePrimitivesInboundDownwardMessage>;
  horizontalMessages: Array<
    [
      PolkadotParachainPrimitivesPrimitivesId,
      Array<PolkadotCorePrimitivesInboundHrmpMessage>,
    ]
  >;
};

export type PolkadotCorePrimitivesInboundDownwardMessage = {
  sentAt: number;
  msg: Bytes;
};

export type PolkadotCorePrimitivesInboundHrmpMessage = {
  sentAt: number;
  data: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletParachainSystemError =
  /**
   * Attempt to upgrade validation function while existing upgrade pending.
   **/
  | "OverlappingUpgrades"
  /**
   * Polkadot currently prohibits this parachain from upgrading its validation function.
   **/
  | "ProhibitedByPolkadot"
  /**
   * The supplied validation function has compiled into a blob larger than Polkadot is
   * willing to run.
   **/
  | "TooBig"
  /**
   * The inherent which supplies the validation data did not run this block.
   **/
  | "ValidationDataNotAvailable"
  /**
   * The inherent which supplies the host configuration did not run this block.
   **/
  | "HostConfigurationNotAvailable"
  /**
   * No validation function upgrade is currently scheduled.
   **/
  | "NotScheduled"
  /**
   * No code upgrade has been authorized.
   **/
  | "NothingAuthorized"
  /**
   * The given code upgrade has not been authorized.
   **/
  | "Unauthorized";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTimestampCall =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: "Set"; params: { now: bigint } };

export type PalletTimestampCallLike =
  /**
   * Set the current time.
   *
   * This call should be invoked exactly once per block. It will panic at the finalization
   * phase, if this call hasn't been invoked by that time.
   *
   * The timestamp should be greater than the previous one by the amount specified by
   * [`Config::MinimumPeriod`].
   *
   * The dispatch origin for this call must be _None_.
   *
   * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
   * that changing the complexity of this call could result exhausting the resources in a
   * block to execute any other calls.
   *
   * ## Complexity
   * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
   * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
   * `on_finalize`)
   * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
   **/
  { name: "Set"; params: { now: bigint } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type StagingParachainInfoCall = null;

export type StagingParachainInfoCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletUtilityCall =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: "Batch"; params: { calls: Array<PolimecRuntimeRuntimeCall> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: PolimecRuntimeRuntimeCall };
    }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: "BatchAll"; params: { calls: Array<PolimecRuntimeRuntimeCall> } }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "DispatchAs";
      params: {
        asOrigin: PolimecRuntimeOriginCaller;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | { name: "ForceBatch"; params: { calls: Array<PolimecRuntimeRuntimeCall> } }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | {
      name: "WithWeight";
      params: {
        call: PolimecRuntimeRuntimeCall;
        weight: SpWeightsWeightV2Weight;
      };
    };

export type PalletUtilityCallLike =
  /**
   * Send a batch of dispatch calls.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   *
   * This will return `Ok` in all circumstances. To determine the success of the batch, an
   * event is deposited. If a call failed and the batch was interrupted, then the
   * `BatchInterrupted` event is deposited, along with the number of successful calls made
   * and the error of the failed call. If all were successful, then the `BatchCompleted`
   * event is deposited.
   **/
  | { name: "Batch"; params: { calls: Array<PolimecRuntimeRuntimeCallLike> } }
  /**
   * Send a call through an indexed pseudonym of the sender.
   *
   * Filter from origin are passed along. The call will be dispatched with an origin which
   * use the same filter as the origin of this call.
   *
   * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
   * because you expect `proxy` to have been used prior in the call stack and you do not want
   * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
   * in the Multisig pallet instead.
   *
   * NOTE: Prior to version *12, this was called `as_limited_sub`.
   *
   * The dispatch origin for this call must be _Signed_.
   **/
  | {
      name: "AsDerivative";
      params: { index: number; call: PolimecRuntimeRuntimeCallLike };
    }
  /**
   * Send a batch of dispatch calls and atomically execute them.
   * The whole transaction will rollback and fail if any of the calls failed.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatched without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "BatchAll";
      params: { calls: Array<PolimecRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatches a function call with a provided origin.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * ## Complexity
   * - O(1).
   **/
  | {
      name: "DispatchAs";
      params: {
        asOrigin: PolimecRuntimeOriginCaller;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Send a batch of dispatch calls.
   * Unlike `batch`, it allows errors and won't interrupt.
   *
   * May be called from any origin except `None`.
   *
   * - `calls`: The calls to be dispatched from the same origin. The number of call must not
   * exceed the constant: `batched_calls_limit` (available in constant metadata).
   *
   * If origin is root then the calls are dispatch without checking origin filter. (This
   * includes bypassing `frame_system::Config::BaseCallFilter`).
   *
   * ## Complexity
   * - O(C) where C is the number of calls to be batched.
   **/
  | {
      name: "ForceBatch";
      params: { calls: Array<PolimecRuntimeRuntimeCallLike> };
    }
  /**
   * Dispatch a function call with a specified weight.
   *
   * This function does not check the weight of the call, and instead allows the
   * Root origin to specify the weight of the call.
   *
   * The dispatch origin for this call must be _Root_.
   **/
  | {
      name: "WithWeight";
      params: {
        call: PolimecRuntimeRuntimeCallLike;
        weight: SpWeightsWeightV2Weight;
      };
    };

export type PolimecRuntimeRuntimeCall =
  | { pallet: "System"; palletCall: FrameSystemCall }
  | { pallet: "ParachainSystem"; palletCall: CumulusPalletParachainSystemCall }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCall }
  | { pallet: "ParachainInfo"; palletCall: StagingParachainInfoCall }
  | { pallet: "Utility"; palletCall: PalletUtilityCall }
  | { pallet: "Multisig"; palletCall: PalletMultisigCall }
  | { pallet: "Proxy"; palletCall: PalletProxyCall }
  | { pallet: "Balances"; palletCall: PalletBalancesCall }
  | { pallet: "Vesting"; palletCall: PalletVestingCall }
  | { pallet: "ContributionTokens"; palletCall: PalletAssetsCall }
  | { pallet: "ForeignAssets"; palletCall: PalletAssetsCall002 }
  | { pallet: "Dispenser"; palletCall: PalletDispenserCall }
  | { pallet: "Session"; palletCall: PalletSessionCall }
  | { pallet: "ParachainStaking"; palletCall: PalletParachainStakingCall }
  | { pallet: "XcmpQueue"; palletCall: CumulusPalletXcmpQueueCall }
  | { pallet: "PolkadotXcm"; palletCall: PalletXcmCall }
  | { pallet: "CumulusXcm"; palletCall: CumulusPalletXcmCall }
  | { pallet: "MessageQueue"; palletCall: PalletMessageQueueCall }
  | { pallet: "Treasury"; palletCall: PalletTreasuryCall }
  | { pallet: "Democracy"; palletCall: PalletDemocracyCall }
  | { pallet: "Council"; palletCall: PalletCollectiveCall }
  | { pallet: "TechnicalCommittee"; palletCall: PalletCollectiveCall }
  | { pallet: "Elections"; palletCall: PalletElectionsPhragmenCall }
  | { pallet: "Preimage"; palletCall: PalletPreimageCall }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCall }
  | { pallet: "Oracle"; palletCall: OrmlOracleModuleCall }
  | { pallet: "OracleProvidersMembership"; palletCall: PalletMembershipCall }
  | { pallet: "Funding"; palletCall: PalletFundingCall }
  | { pallet: "LinearRelease"; palletCall: PalletLinearReleaseCall }
  | { pallet: "ProxyBonding"; palletCall: PalletProxyBondingCall };

export type PolimecRuntimeRuntimeCallLike =
  | { pallet: "System"; palletCall: FrameSystemCallLike }
  | {
      pallet: "ParachainSystem";
      palletCall: CumulusPalletParachainSystemCallLike;
    }
  | { pallet: "Timestamp"; palletCall: PalletTimestampCallLike }
  | { pallet: "ParachainInfo"; palletCall: StagingParachainInfoCallLike }
  | { pallet: "Utility"; palletCall: PalletUtilityCallLike }
  | { pallet: "Multisig"; palletCall: PalletMultisigCallLike }
  | { pallet: "Proxy"; palletCall: PalletProxyCallLike }
  | { pallet: "Balances"; palletCall: PalletBalancesCallLike }
  | { pallet: "Vesting"; palletCall: PalletVestingCallLike }
  | { pallet: "ContributionTokens"; palletCall: PalletAssetsCallLike }
  | { pallet: "ForeignAssets"; palletCall: PalletAssetsCallLike002 }
  | { pallet: "Dispenser"; palletCall: PalletDispenserCallLike }
  | { pallet: "Session"; palletCall: PalletSessionCallLike }
  | { pallet: "ParachainStaking"; palletCall: PalletParachainStakingCallLike }
  | { pallet: "XcmpQueue"; palletCall: CumulusPalletXcmpQueueCallLike }
  | { pallet: "PolkadotXcm"; palletCall: PalletXcmCallLike }
  | { pallet: "CumulusXcm"; palletCall: CumulusPalletXcmCallLike }
  | { pallet: "MessageQueue"; palletCall: PalletMessageQueueCallLike }
  | { pallet: "Treasury"; palletCall: PalletTreasuryCallLike }
  | { pallet: "Democracy"; palletCall: PalletDemocracyCallLike }
  | { pallet: "Council"; palletCall: PalletCollectiveCallLike }
  | { pallet: "TechnicalCommittee"; palletCall: PalletCollectiveCallLike }
  | { pallet: "Elections"; palletCall: PalletElectionsPhragmenCallLike }
  | { pallet: "Preimage"; palletCall: PalletPreimageCallLike }
  | { pallet: "Scheduler"; palletCall: PalletSchedulerCallLike }
  | { pallet: "Oracle"; palletCall: OrmlOracleModuleCallLike }
  | {
      pallet: "OracleProvidersMembership";
      palletCall: PalletMembershipCallLike;
    }
  | { pallet: "Funding"; palletCall: PalletFundingCallLike }
  | { pallet: "LinearRelease"; palletCall: PalletLinearReleaseCallLike }
  | { pallet: "ProxyBonding"; palletCall: PalletProxyBondingCallLike };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMultisigCall =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32>;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: PolimecRuntimeRuntimeCall;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

export type PalletMultisigCallLike =
  /**
   * Immediately dispatch a multi-signature call using a single approval from the caller.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `other_signatories`: The accounts (other than the sender) who are part of the
   * multi-signature, but do not participate in the approval process.
   * - `call`: The call to be executed.
   *
   * Result is equivalent to the dispatched result.
   *
   * ## Complexity
   * O(Z + C) where Z is the length of the call and C its execution weight.
   **/
  | {
      name: "AsMultiThreshold1";
      params: {
        otherSignatories: Array<AccountId32Like>;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * If there are enough, then dispatch the call.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call`: The call to be executed.
   *
   * NOTE: Unless this is the final approval, you will generally want to use
   * `approve_as_multi` instead, since it only requires a hash of the call.
   *
   * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
   * on success, result is `Ok` and the result from the interior call, if it was executed,
   * may be found in the deposited `MultisigExecuted` event.
   *
   * ## Complexity
   * - `O(S + Z + Call)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - The weight of the `call`.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "AsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        call: PolimecRuntimeRuntimeCallLike;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Register approval for a dispatch to be made from a deterministic composite account if
   * approved by a total of `threshold - 1` of `other_signatories`.
   *
   * Payment: `DepositBase` will be reserved if this is the first approval, plus
   * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
   * is cancelled.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
   * not the first approval, then it must be `Some`, with the timepoint (block number and
   * transaction index) of the first approval transaction.
   * - `call_hash`: The hash of the call to be executed.
   *
   * NOTE: If this is the final approval, you will want to use `as_multi` instead.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - Up to one binary search and insert (`O(logS + S)`).
   * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
   * - One event.
   * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
   * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
   **/
  | {
      name: "ApproveAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        maybeTimepoint?: PalletMultisigTimepoint | undefined;
        callHash: FixedBytes<32>;
        maxWeight: SpWeightsWeightV2Weight;
      };
    }
  /**
   * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
   * for this operation will be unreserved on success.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `threshold`: The total number of approvals for this dispatch before it is executed.
   * - `other_signatories`: The accounts (other than the sender) who can approve this
   * dispatch. May not be empty.
   * - `timepoint`: The timepoint (block number and transaction index) of the first approval
   * transaction for this dispatch.
   * - `call_hash`: The hash of the call to be executed.
   *
   * ## Complexity
   * - `O(S)`.
   * - Up to one balance-reserve or unreserve operation.
   * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
   * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
   * - One encode & hash, both of complexity `O(S)`.
   * - One event.
   * - I/O: 1 read `O(S)`, one remove.
   * - Storage: removes one item.
   **/
  | {
      name: "CancelAsMulti";
      params: {
        threshold: number;
        otherSignatories: Array<AccountId32Like>;
        timepoint: PalletMultisigTimepoint;
        callHash: FixedBytes<32>;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyCall =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddress;
        forceProxyType?: SharedConfigurationProxyType | undefined;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddress;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddress;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: "RemoveProxies" }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: SharedConfigurationProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddress;
        proxyType: SharedConfigurationProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: "Announce"; params: { real: MultiAddress; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddress; callHash: H256 };
    }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddress; callHash: H256 };
    }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddress;
        real: MultiAddress;
        forceProxyType?: SharedConfigurationProxyType | undefined;
        call: PolimecRuntimeRuntimeCall;
      };
    };

export type PalletProxyCallLike =
  /**
   * Dispatch the given `call` from an account that the sender is authorised for through
   * `add_proxy`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "Proxy";
      params: {
        real: MultiAddressLike;
        forceProxyType?: SharedConfigurationProxyType | undefined;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Register a proxy account for the sender that is able to make calls on its behalf.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to make a proxy.
   * - `proxy_type`: The permissions allowed for this proxy account.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   **/
  | {
      name: "AddProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    }
  /**
   * Unregister a proxy account for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `proxy`: The account that the `caller` would like to remove as a proxy.
   * - `proxy_type`: The permissions currently enabled for the removed proxy account.
   **/
  | {
      name: "RemoveProxy";
      params: {
        delegate: MultiAddressLike;
        proxyType: SharedConfigurationProxyType;
        delay: number;
      };
    }
  /**
   * Unregister all proxy accounts for the sender.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * WARNING: This may be called on accounts created by `pure`, however if done, then
   * the unreserved fees will be inaccessible. **All access to this account will be lost.**
   **/
  | { name: "RemoveProxies" }
  /**
   * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
   * initialize it with a proxy of `proxy_type` for `origin` sender.
   *
   * Requires a `Signed` origin.
   *
   * - `proxy_type`: The type of the proxy that the sender will be registered as over the
   * new account. This will almost always be the most permissive `ProxyType` possible to
   * allow for maximum flexibility.
   * - `index`: A disambiguation index, in case this is called multiple times in the same
   * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
   * want to use `0`.
   * - `delay`: The announcement period required of the initial proxy. Will generally be
   * zero.
   *
   * Fails with `Duplicate` if this has already been called in this transaction, from the
   * same sender, with the same parameters.
   *
   * Fails if there are insufficient funds to pay for deposit.
   **/
  | {
      name: "CreatePure";
      params: {
        proxyType: SharedConfigurationProxyType;
        delay: number;
        index: number;
      };
    }
  /**
   * Removes a previously spawned pure proxy.
   *
   * WARNING: **All access to this account will be lost.** Any funds held in it will be
   * inaccessible.
   *
   * Requires a `Signed` origin, and the sender account must have been created by a call to
   * `pure` with corresponding parameters.
   *
   * - `spawner`: The account that originally called `pure` to create this account.
   * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
   * - `proxy_type`: The proxy type originally passed to `pure`.
   * - `height`: The height of the chain when the call to `pure` was processed.
   * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
   *
   * Fails with `NoPermission` in case the caller is not a previously created pure
   * account whose `pure` call has corresponding parameters.
   **/
  | {
      name: "KillPure";
      params: {
        spawner: MultiAddressLike;
        proxyType: SharedConfigurationProxyType;
        index: number;
        height: number;
        extIndex: number;
      };
    }
  /**
   * Publish the hash of a proxy-call that will be made in the future.
   *
   * This must be called some number of blocks before the corresponding `proxy` is attempted
   * if the delay associated with the proxy relationship is greater than zero.
   *
   * No more than `MaxPending` announcements may be made at any one time.
   *
   * This will take a deposit of `AnnouncementDepositFactor` as well as
   * `AnnouncementDepositBase` if there are no other pending announcements.
   *
   * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | { name: "Announce"; params: { real: MultiAddressLike; callHash: H256 } }
  /**
   * Remove a given announcement.
   *
   * May be called by a proxy account to remove a call they previously announced and return
   * the deposit.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `call_hash`: The hash of the call to be made by the `real` account.
   **/
  | {
      name: "RemoveAnnouncement";
      params: { real: MultiAddressLike; callHash: H256 };
    }
  /**
   * Remove the given announcement of a delegate.
   *
   * May be called by a target (proxied) account to remove a call that one of their delegates
   * (`delegate`) has announced they want to execute. The deposit is returned.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `delegate`: The account that previously announced the call.
   * - `call_hash`: The hash of the call to be made.
   **/
  | {
      name: "RejectAnnouncement";
      params: { delegate: MultiAddressLike; callHash: H256 };
    }
  /**
   * Dispatch the given `call` from an account that the sender is authorized for through
   * `add_proxy`.
   *
   * Removes any corresponding announcement(s).
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * Parameters:
   * - `real`: The account that the proxy will make a call on behalf of.
   * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
   * - `call`: The call to be made by the `real` account.
   **/
  | {
      name: "ProxyAnnounced";
      params: {
        delegate: MultiAddressLike;
        real: MultiAddressLike;
        forceProxyType?: SharedConfigurationProxyType | undefined;
        call: PolimecRuntimeRuntimeCallLike;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletBalancesCall =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddress; value: bigint };
    }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | {
      name: "ForceTransfer";
      params: { source: MultiAddress; dest: MultiAddress; value: bigint };
    }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | { name: "TransferKeepAlive"; params: { dest: MultiAddress; value: bigint } }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | { name: "TransferAll"; params: { dest: MultiAddress; keepAlive: boolean } }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | { name: "ForceUnreserve"; params: { who: MultiAddress; amount: bigint } }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | { name: "ForceSetBalance"; params: { who: MultiAddress; newFree: bigint } }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: "Burn"; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesCallLike =
  /**
   * Transfer some liquid free balance to another account.
   *
   * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
   * If the sender's account is below the existential deposit as a result
   * of the transfer, the account will be reaped.
   *
   * The dispatch origin for this call must be `Signed` by the transactor.
   **/
  | {
      name: "TransferAllowDeath";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Exactly as `transfer_allow_death`, except the origin must be root and the source account
   * may be specified.
   **/
  | {
      name: "ForceTransfer";
      params: {
        source: MultiAddressLike;
        dest: MultiAddressLike;
        value: bigint;
      };
    }
  /**
   * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
   * kill the origin account.
   *
   * 99% of the time you want [`transfer_allow_death`] instead.
   *
   * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
   **/
  | {
      name: "TransferKeepAlive";
      params: { dest: MultiAddressLike; value: bigint };
    }
  /**
   * Transfer the entire transferable balance from the caller account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the account has, causing the sender account to be killed (false), or
   * transfer everything except at least the existential deposit, which will guarantee to
   * keep the sender account alive (true).
   **/
  | {
      name: "TransferAll";
      params: { dest: MultiAddressLike; keepAlive: boolean };
    }
  /**
   * Unreserve some balance from a user by force.
   *
   * Can only be called by ROOT.
   **/
  | {
      name: "ForceUnreserve";
      params: { who: MultiAddressLike; amount: bigint };
    }
  /**
   * Upgrade a specified account.
   *
   * - `origin`: Must be `Signed`.
   * - `who`: The account to be upgraded.
   *
   * This will waive the transaction fee if at least all but 10% of the accounts needed to
   * be upgraded. (We let some not have to be upgraded just in order to allow for the
   * possibility of churn).
   **/
  | { name: "UpgradeAccounts"; params: { who: Array<AccountId32Like> } }
  /**
   * Set the regular balance of a given account.
   *
   * The dispatch origin for this call is `root`.
   **/
  | {
      name: "ForceSetBalance";
      params: { who: MultiAddressLike; newFree: bigint };
    }
  /**
   * Adjust the total issuance in a saturating way.
   *
   * Can only be called by root and always needs a positive `delta`.
   *
   * # Example
   **/
  | {
      name: "ForceAdjustTotalIssuance";
      params: { direction: PalletBalancesAdjustmentDirection; delta: bigint };
    }
  /**
   * Burn the specified liquid free balance from the origin account.
   *
   * If the origin's account ends up below the existential deposit as a result
   * of the burn and `keep_alive` is false, the account will be reaped.
   *
   * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
   * this `burn` operation will reduce total issuance by the amount _burned_.
   **/
  | { name: "Burn"; params: { value: bigint; keepAlive: boolean } };

export type PalletBalancesAdjustmentDirection = "Increase" | "Decrease";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletVestingCall =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "Vest" }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestOther"; params: { target: MultiAddress } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestedTransfer";
      params: { target: MultiAddress; schedule: PalletVestingVestingInfo };
    }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "ForceVestedTransfer";
      params: {
        source: MultiAddress;
        target: MultiAddress;
        schedule: PalletVestingVestingInfo;
      };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | {
      name: "MergeSchedules";
      params: { schedule1Index: number; schedule2Index: number };
    }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | {
      name: "ForceRemoveVestingSchedule";
      params: { target: MultiAddress; scheduleIndex: number };
    };

export type PalletVestingCallLike =
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "Vest" }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestOther"; params: { target: MultiAddressLike } }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestedTransfer";
      params: { target: MultiAddressLike; schedule: PalletVestingVestingInfo };
    }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "ForceVestedTransfer";
      params: {
        source: MultiAddressLike;
        target: MultiAddressLike;
        schedule: PalletVestingVestingInfo;
      };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | {
      name: "MergeSchedules";
      params: { schedule1Index: number; schedule2Index: number };
    }
  /**
   * Force remove a vesting schedule
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `target`: An account that has a vesting schedule
   * - `schedule_index`: The vesting schedule index that should be removed
   **/
  | {
      name: "ForceRemoveVestingSchedule";
      params: { target: MultiAddressLike; scheduleIndex: number };
    };

export type PalletVestingVestingInfo = {
  locked: bigint;
  perBlock: bigint;
  startingBlock: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Create";
      params: { id: number; admin: MultiAddress; minBalance: bigint };
    }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCreate";
      params: {
        id: number;
        owner: MultiAddress;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   **/
  | { name: "StartDestroy"; params: { id: number } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: "DestroyAccounts"; params: { id: number } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: "DestroyApprovals"; params: { id: number } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: "FinishDestroy"; params: { id: number } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | {
      name: "Mint";
      params: { id: number; beneficiary: MultiAddress; amount: bigint };
    }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | { name: "Burn"; params: { id: number; who: MultiAddress; amount: bigint } }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "Transfer";
      params: { id: number; target: MultiAddress; amount: bigint };
    }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "TransferKeepAlive";
      params: { id: number; target: MultiAddress; amount: bigint };
    }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | {
      name: "ForceTransfer";
      params: {
        id: number;
        source: MultiAddress;
        dest: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Freeze"; params: { id: number; who: MultiAddress } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Thaw"; params: { id: number; who: MultiAddress } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "FreezeAsset"; params: { id: number } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ThawAsset"; params: { id: number } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | { name: "TransferOwnership"; params: { id: number; owner: MultiAddress } }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetTeam";
      params: {
        id: number;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
      };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetMetadata";
      params: { id: number; name: Bytes; symbol: Bytes; decimals: number };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ClearMetadata"; params: { id: number } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: "ForceSetMetadata";
      params: {
        id: number;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ForceClearMetadata"; params: { id: number } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceAssetStatus";
      params: {
        id: number;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ApproveTransfer";
      params: { id: number; delegate: MultiAddress; amount: bigint };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | { name: "CancelApproval"; params: { id: number; delegate: MultiAddress } }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCancelApproval";
      params: { id: number; owner: MultiAddress; delegate: MultiAddress };
    }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferApproved";
      params: {
        id: number;
        owner: MultiAddress;
        destination: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "Touch"; params: { id: number } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "Refund"; params: { id: number; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: "SetMinBalance"; params: { id: number; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "TouchOther"; params: { id: number; who: MultiAddress } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "RefundOther"; params: { id: number; who: MultiAddress } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Block"; params: { id: number; who: MultiAddress } }
  /**
   * Transfer the entire transferable balance from the caller asset account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the asset account has, causing the sender asset account to be killed
   * (false), or transfer everything except at least the minimum balance, which will
   * guarantee to keep the sender asset account alive (true).
   **/
  | {
      name: "TransferAll";
      params: { id: number; dest: MultiAddress; keepAlive: boolean };
    };

export type PalletAssetsCallLike =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Create";
      params: { id: number; admin: MultiAddressLike; minBalance: bigint };
    }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCreate";
      params: {
        id: number;
        owner: MultiAddressLike;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   **/
  | { name: "StartDestroy"; params: { id: number } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: "DestroyAccounts"; params: { id: number } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: "DestroyApprovals"; params: { id: number } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: "FinishDestroy"; params: { id: number } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | {
      name: "Mint";
      params: { id: number; beneficiary: MultiAddressLike; amount: bigint };
    }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | {
      name: "Burn";
      params: { id: number; who: MultiAddressLike; amount: bigint };
    }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "Transfer";
      params: { id: number; target: MultiAddressLike; amount: bigint };
    }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "TransferKeepAlive";
      params: { id: number; target: MultiAddressLike; amount: bigint };
    }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | {
      name: "ForceTransfer";
      params: {
        id: number;
        source: MultiAddressLike;
        dest: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Freeze"; params: { id: number; who: MultiAddressLike } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Thaw"; params: { id: number; who: MultiAddressLike } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "FreezeAsset"; params: { id: number } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ThawAsset"; params: { id: number } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferOwnership";
      params: { id: number; owner: MultiAddressLike };
    }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetTeam";
      params: {
        id: number;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
      };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetMetadata";
      params: {
        id: number;
        name: BytesLike;
        symbol: BytesLike;
        decimals: number;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ClearMetadata"; params: { id: number } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: "ForceSetMetadata";
      params: {
        id: number;
        name: BytesLike;
        symbol: BytesLike;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ForceClearMetadata"; params: { id: number } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceAssetStatus";
      params: {
        id: number;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ApproveTransfer";
      params: { id: number; delegate: MultiAddressLike; amount: bigint };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "CancelApproval";
      params: { id: number; delegate: MultiAddressLike };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCancelApproval";
      params: {
        id: number;
        owner: MultiAddressLike;
        delegate: MultiAddressLike;
      };
    }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferApproved";
      params: {
        id: number;
        owner: MultiAddressLike;
        destination: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "Touch"; params: { id: number } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "Refund"; params: { id: number; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | { name: "SetMinBalance"; params: { id: number; minBalance: bigint } }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "TouchOther"; params: { id: number; who: MultiAddressLike } }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "RefundOther"; params: { id: number; who: MultiAddressLike } }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Block"; params: { id: number; who: MultiAddressLike } }
  /**
   * Transfer the entire transferable balance from the caller asset account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the asset account has, causing the sender asset account to be killed
   * (false), or transfer everything except at least the minimum balance, which will
   * guarantee to keep the sender asset account alive (true).
   **/
  | {
      name: "TransferAll";
      params: { id: number; dest: MultiAddressLike; keepAlive: boolean };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletAssetsCall002 =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Create";
      params: {
        id: StagingXcmV4Location;
        admin: MultiAddress;
        minBalance: bigint;
      };
    }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCreate";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddress;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   **/
  | { name: "StartDestroy"; params: { id: StagingXcmV4Location } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: "DestroyAccounts"; params: { id: StagingXcmV4Location } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: "DestroyApprovals"; params: { id: StagingXcmV4Location } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: "FinishDestroy"; params: { id: StagingXcmV4Location } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | {
      name: "Mint";
      params: {
        id: StagingXcmV4Location;
        beneficiary: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | {
      name: "Burn";
      params: { id: StagingXcmV4Location; who: MultiAddress; amount: bigint };
    }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "Transfer";
      params: {
        id: StagingXcmV4Location;
        target: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "TransferKeepAlive";
      params: {
        id: StagingXcmV4Location;
        target: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | {
      name: "ForceTransfer";
      params: {
        id: StagingXcmV4Location;
        source: MultiAddress;
        dest: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Freeze"; params: { id: StagingXcmV4Location; who: MultiAddress } }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Thaw"; params: { id: StagingXcmV4Location; who: MultiAddress } }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "FreezeAsset"; params: { id: StagingXcmV4Location } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ThawAsset"; params: { id: StagingXcmV4Location } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferOwnership";
      params: { id: StagingXcmV4Location; owner: MultiAddress };
    }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetTeam";
      params: {
        id: StagingXcmV4Location;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
      };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetMetadata";
      params: {
        id: StagingXcmV4Location;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ClearMetadata"; params: { id: StagingXcmV4Location } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: "ForceSetMetadata";
      params: {
        id: StagingXcmV4Location;
        name: Bytes;
        symbol: Bytes;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ForceClearMetadata"; params: { id: StagingXcmV4Location } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceAssetStatus";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddress;
        issuer: MultiAddress;
        admin: MultiAddress;
        freezer: MultiAddress;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ApproveTransfer";
      params: {
        id: StagingXcmV4Location;
        delegate: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "CancelApproval";
      params: { id: StagingXcmV4Location; delegate: MultiAddress };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCancelApproval";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddress;
        delegate: MultiAddress;
      };
    }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferApproved";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddress;
        destination: MultiAddress;
        amount: bigint;
      };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "Touch"; params: { id: StagingXcmV4Location } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "Refund"; params: { id: StagingXcmV4Location; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | {
      name: "SetMinBalance";
      params: { id: StagingXcmV4Location; minBalance: bigint };
    }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | {
      name: "TouchOther";
      params: { id: StagingXcmV4Location; who: MultiAddress };
    }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | {
      name: "RefundOther";
      params: { id: StagingXcmV4Location; who: MultiAddress };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | { name: "Block"; params: { id: StagingXcmV4Location; who: MultiAddress } }
  /**
   * Transfer the entire transferable balance from the caller asset account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the asset account has, causing the sender asset account to be killed
   * (false), or transfer everything except at least the minimum balance, which will
   * guarantee to keep the sender asset account alive (true).
   **/
  | {
      name: "TransferAll";
      params: {
        id: StagingXcmV4Location;
        dest: MultiAddress;
        keepAlive: boolean;
      };
    };

export type PalletAssetsCallLike002 =
  /**
   * Issue a new class of fungible assets from a public origin.
   *
   * This new asset class has no assets initially and its owner is the origin.
   *
   * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
   *
   * Funds of sender are reserved by `AssetDeposit`.
   *
   * Parameters:
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `admin`: The admin of this class of assets. The admin is the initial address of each
   * member of the asset class's admin team.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `Created` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Create";
      params: {
        id: StagingXcmV4Location;
        admin: MultiAddressLike;
        minBalance: bigint;
      };
    }
  /**
   * Issue a new class of fungible assets from a privileged origin.
   *
   * This new asset class has no assets initially.
   *
   * The origin must conform to `ForceOrigin`.
   *
   * Unlike `create`, no funds are reserved.
   *
   * - `id`: The identifier of the new asset. This must not be currently in use to identify
   * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
   * - `owner`: The owner of this class of assets. The owner has full superuser permissions
   * over this asset, but may later change and configure the permissions using
   * `transfer_ownership` and `set_team`.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   *
   * Emits `ForceCreated` event when successful.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCreate";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddressLike;
        isSufficient: boolean;
        minBalance: bigint;
      };
    }
  /**
   * Start the process of destroying a fungible asset class.
   *
   * `start_destroy` is the first in a series of extrinsics that should be called, to allow
   * destruction of an asset class.
   *
   * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   **/
  | { name: "StartDestroy"; params: { id: StagingXcmV4Location } }
  /**
   * Destroy all accounts associated with a given asset.
   *
   * `destroy_accounts` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedAccounts` event.
   **/
  | { name: "DestroyAccounts"; params: { id: StagingXcmV4Location } }
  /**
   * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
   *
   * `destroy_approvals` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state.
   *
   * Due to weight restrictions, this function may need to be called multiple times to fully
   * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each call emits the `Event::DestroyedApprovals` event.
   **/
  | { name: "DestroyApprovals"; params: { id: StagingXcmV4Location } }
  /**
   * Complete destroying asset and unreserve currency.
   *
   * `finish_destroy` should only be called after `start_destroy` has been called, and the
   * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
   * hand.
   *
   * - `id`: The identifier of the asset to be destroyed. This must identify an existing
   * asset.
   *
   * Each successful call emits the `Event::Destroyed` event.
   **/
  | { name: "FinishDestroy"; params: { id: StagingXcmV4Location } }
  /**
   * Mint assets of a particular class.
   *
   * The origin must be Signed and the sender must be the Issuer of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount minted.
   * - `beneficiary`: The account to be credited with the minted assets.
   * - `amount`: The amount of the asset to be minted.
   *
   * Emits `Issued` event when successful.
   *
   * Weight: `O(1)`
   * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
   **/
  | {
      name: "Mint";
      params: {
        id: StagingXcmV4Location;
        beneficiary: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
   *
   * Origin must be Signed and the sender should be the Manager of the asset `id`.
   *
   * Bails with `NoAccount` if the `who` is already dead.
   *
   * - `id`: The identifier of the asset to have some amount burned.
   * - `who`: The account to be debited from.
   * - `amount`: The maximum amount by which `who`'s balance should be reduced.
   *
   * Emits `Burned` with the actual amount burned. If this takes the balance to below the
   * minimum for the asset, then the amount burned is increased to take it to zero.
   *
   * Weight: `O(1)`
   * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
   **/
  | {
      name: "Burn";
      params: {
        id: StagingXcmV4Location;
        who: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Move some assets from the sender account to another.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "Transfer";
      params: {
        id: StagingXcmV4Location;
        target: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Move some assets from the sender account to another, keeping the sender account alive.
   *
   * Origin must be Signed.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `target`: The account to be credited.
   * - `amount`: The amount by which the sender's balance of assets should be reduced and
   * `target`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the sender balance above zero but below
   * the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
   * `target`.
   **/
  | {
      name: "TransferKeepAlive";
      params: {
        id: StagingXcmV4Location;
        target: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Move some assets from one account to another.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to have some amount transferred.
   * - `source`: The account to be debited.
   * - `dest`: The account to be credited.
   * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
   * `dest`'s balance increased. The amount actually transferred may be slightly greater in
   * the case that the transfer would otherwise take the `source` balance above zero but
   * below the minimum balance. Must be greater than zero.
   *
   * Emits `Transferred` with the actual amount transferred. If this takes the source balance
   * to below the minimum for the asset, then the amount transferred is increased to take it
   * to zero.
   *
   * Weight: `O(1)`
   * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
   * `dest`.
   **/
  | {
      name: "ForceTransfer";
      params: {
        id: StagingXcmV4Location;
        source: MultiAddressLike;
        dest: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
   * must already exist as an entry in `Account`s of the asset. If you want to freeze an
   * account that does not have an entry, use `touch_other` first.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Freeze";
      params: { id: StagingXcmV4Location; who: MultiAddressLike };
    }
  /**
   * Allow unprivileged transfers to and from an account again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `who`: The account to be unfrozen.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Thaw";
      params: { id: StagingXcmV4Location; who: MultiAddressLike };
    }
  /**
   * Disallow further unprivileged transfers for the asset class.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   *
   * Emits `Frozen`.
   *
   * Weight: `O(1)`
   **/
  | { name: "FreezeAsset"; params: { id: StagingXcmV4Location } }
  /**
   * Allow unprivileged transfers for the asset again.
   *
   * Origin must be Signed and the sender should be the Admin of the asset `id`.
   *
   * - `id`: The identifier of the asset to be thawed.
   *
   * Emits `Thawed`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ThawAsset"; params: { id: StagingXcmV4Location } }
  /**
   * Change the Owner of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   *
   * Emits `OwnerChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferOwnership";
      params: { id: StagingXcmV4Location; owner: MultiAddressLike };
    }
  /**
   * Change the Issuer, Admin and Freezer of an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * - `id`: The identifier of the asset to be frozen.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   *
   * Emits `TeamChanged`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetTeam";
      params: {
        id: StagingXcmV4Location;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
      };
    }
  /**
   * Set the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Funds of sender are reserved according to the formula:
   * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
   * account any already reserved funds.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "SetMetadata";
      params: {
        id: StagingXcmV4Location;
        name: BytesLike;
        symbol: BytesLike;
        decimals: number;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be Signed and the sender should be the Owner of the asset `id`.
   *
   * Any deposit is freed for the asset owner.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ClearMetadata"; params: { id: StagingXcmV4Location } }
  /**
   * Force the metadata for an asset to some value.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is left alone.
   *
   * - `id`: The identifier of the asset to update.
   * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
   * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
   * - `decimals`: The number of decimals this asset uses to represent one unit.
   *
   * Emits `MetadataSet`.
   *
   * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
   **/
  | {
      name: "ForceSetMetadata";
      params: {
        id: StagingXcmV4Location;
        name: BytesLike;
        symbol: BytesLike;
        decimals: number;
        isFrozen: boolean;
      };
    }
  /**
   * Clear the metadata for an asset.
   *
   * Origin must be ForceOrigin.
   *
   * Any deposit is returned.
   *
   * - `id`: The identifier of the asset to clear.
   *
   * Emits `MetadataCleared`.
   *
   * Weight: `O(1)`
   **/
  | { name: "ForceClearMetadata"; params: { id: StagingXcmV4Location } }
  /**
   * Alter the attributes of a given asset.
   *
   * Origin must be `ForceOrigin`.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The new Owner of this asset.
   * - `issuer`: The new Issuer of this asset.
   * - `admin`: The new Admin of this asset.
   * - `freezer`: The new Freezer of this asset.
   * - `min_balance`: The minimum balance of this new asset that any single account must
   * have. If an account's balance is reduced below this, then it collapses to zero.
   * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
   * value to account for the state bloat associated with its balance storage. If set to
   * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
   * an ED in the Balances pallet or whatever else is used to control user-account state
   * growth).
   * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
   * instructions.
   *
   * Emits `AssetStatusChanged` with the identity of the asset.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceAssetStatus";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddressLike;
        issuer: MultiAddressLike;
        admin: MultiAddressLike;
        freezer: MultiAddressLike;
        minBalance: bigint;
        isSufficient: boolean;
        isFrozen: boolean;
      };
    }
  /**
   * Approve an amount of asset for transfer by a delegated third-party account.
   *
   * Origin must be Signed.
   *
   * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
   * for the purpose of holding the approval. If some non-zero amount of assets is already
   * approved from signing account to `delegate`, then it is topped up or unreserved to
   * meet the right value.
   *
   * NOTE: The signing account does not need to own `amount` of assets at the point of
   * making this call.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account to delegate permission to transfer asset.
   * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
   * already an approval in place, then this acts additively.
   *
   * Emits `ApprovedTransfer` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ApproveTransfer";
      params: {
        id: StagingXcmV4Location;
        delegate: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be Signed and there must be an approval in place between signer and
   * `delegate`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "CancelApproval";
      params: { id: StagingXcmV4Location; delegate: MultiAddressLike };
    }
  /**
   * Cancel all of some asset approved for delegated transfer by a third-party account.
   *
   * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
   * account of the asset `id`.
   *
   * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
   *
   * - `id`: The identifier of the asset.
   * - `delegate`: The account delegated permission to transfer asset.
   *
   * Emits `ApprovalCancelled` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ForceCancelApproval";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddressLike;
        delegate: MultiAddressLike;
      };
    }
  /**
   * Transfer some asset balance from a previously delegated account to some third-party
   * account.
   *
   * Origin must be Signed and there must be an approval in place by the `owner` to the
   * signer.
   *
   * If the entire amount approved for transfer is transferred, then any deposit previously
   * reserved by `approve_transfer` is unreserved.
   *
   * - `id`: The identifier of the asset.
   * - `owner`: The account which previously approved for a transfer of at least `amount` and
   * from which the asset balance will be withdrawn.
   * - `destination`: The account to which the asset balance of `amount` will be transferred.
   * - `amount`: The amount of assets to transfer.
   *
   * Emits `TransferredApproved` on success.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "TransferApproved";
      params: {
        id: StagingXcmV4Location;
        owner: MultiAddressLike;
        destination: MultiAddressLike;
        amount: bigint;
      };
    }
  /**
   * Create an asset account for non-provider assets.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
   * to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | { name: "Touch"; params: { id: StagingXcmV4Location } }
  /**
   * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
   * account.
   *
   * The origin must be Signed.
   *
   * - `id`: The identifier of the asset for which the caller would like the deposit
   * refunded.
   * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | { name: "Refund"; params: { id: StagingXcmV4Location; allowBurn: boolean } }
  /**
   * Sets the minimum balance of an asset.
   *
   * Only works if there aren't any accounts that are holding the asset or if
   * the new value of `min_balance` is less than the old one.
   *
   * Origin must be Signed and the sender has to be the Owner of the
   * asset `id`.
   *
   * - `id`: The identifier of the asset.
   * - `min_balance`: The new value of `min_balance`.
   *
   * Emits `AssetMinBalanceChanged` event when successful.
   **/
  | {
      name: "SetMinBalance";
      params: { id: StagingXcmV4Location; minBalance: bigint };
    }
  /**
   * Create an asset account for `who`.
   *
   * A deposit will be taken from the signer account.
   *
   * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
   * must have sufficient funds for a deposit to be taken.
   * - `id`: The identifier of the asset for the account to be created.
   * - `who`: The account to be created.
   *
   * Emits `Touched` event when successful.
   **/
  | {
      name: "TouchOther";
      params: { id: StagingXcmV4Location; who: MultiAddressLike };
    }
  /**
   * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
   *
   * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
   * order to burn a non-zero balance of the asset, the caller must be the account and should
   * use `refund`.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `who`: The account to refund.
   *
   * Emits `Refunded` event when successful.
   **/
  | {
      name: "RefundOther";
      params: { id: StagingXcmV4Location; who: MultiAddressLike };
    }
  /**
   * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
   *
   * Origin must be Signed and the sender should be the Freezer of the asset `id`.
   *
   * - `id`: The identifier of the account's asset.
   * - `who`: The account to be unblocked.
   *
   * Emits `Blocked`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "Block";
      params: { id: StagingXcmV4Location; who: MultiAddressLike };
    }
  /**
   * Transfer the entire transferable balance from the caller asset account.
   *
   * NOTE: This function only attempts to transfer _transferable_ balances. This means that
   * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
   * transferred by this function. To ensure that this function results in a killed account,
   * you might need to prepare the account by removing any reference counters, storage
   * deposits, etc...
   *
   * The dispatch origin of this call must be Signed.
   *
   * - `id`: The identifier of the asset for the account holding a deposit.
   * - `dest`: The recipient of the transfer.
   * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
   * of the funds the asset account has, causing the sender asset account to be killed
   * (false), or transfer everything except at least the minimum balance, which will
   * guarantee to keep the sender asset account alive (true).
   **/
  | {
      name: "TransferAll";
      params: {
        id: StagingXcmV4Location;
        dest: MultiAddressLike;
        keepAlive: boolean;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDispenserCall =
  | { name: "Dispense"; params: { jwt: JwtCompactFrameTokenUntrustedToken } }
  | { name: "SetDispenseAmount"; params: { amount: bigint } };

export type PalletDispenserCallLike =
  | { name: "Dispense"; params: { jwt: JwtCompactFrameTokenUntrustedToken } }
  | { name: "SetDispenseAmount"; params: { amount: bigint } };

export type JwtCompactFrameTokenUntrustedToken = {
  signedData: Bytes;
  header: JwtCompactFrameTokenHeader;
  algorithm: Bytes;
  contentType: JwtCompactFrameTokenContentType;
  serializedClaims: Bytes;
  signature: Bytes;
};

export type JwtCompactFrameClaimsEmpty = {};

export type JwtCompactFrameTokenHeader = {
  keySetUrl?: string | undefined;
  keyId?: string | undefined;
  certificateUrl?: string | undefined;
  certificateSha1Thumbprint?: JwtCompactFrameTokenThumbprint | undefined;
  certificateThumbprint?: JwtCompactFrameTokenThumbprint002 | undefined;
  tokenType?: string | undefined;
  otherFields: JwtCompactFrameClaimsEmpty;
};

export type JwtCompactFrameTokenThumbprint =
  | { type: "Bytes"; value: FixedBytes<20> }
  | { type: "String"; value: string };

export type JwtCompactFrameTokenThumbprint002 =
  | { type: "Bytes"; value: FixedBytes<32> }
  | { type: "String"; value: string };

export type JwtCompactFrameTokenContentType = "Json";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSessionCall =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | {
      name: "SetKeys";
      params: { keys: PolimecRuntimeSessionKeys; proof: Bytes };
    }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: "PurgeKeys" };

export type PalletSessionCallLike =
  /**
   * Sets the session key(s) of the function caller to `keys`.
   * Allows an account to set its session key prior to becoming a validator.
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be signed.
   *
   * ## Complexity
   * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
   * fixed.
   **/
  | {
      name: "SetKeys";
      params: { keys: PolimecRuntimeSessionKeys; proof: BytesLike };
    }
  /**
   * Removes any session key(s) of the function caller.
   *
   * This doesn't take effect until the next session.
   *
   * The dispatch origin of this function must be Signed and the account must be either be
   * convertible to a validator ID using the chain's typical addressing system (this usually
   * means being a controller account) or directly convertible into a validator ID (which
   * usually means being a stash account).
   *
   * ## Complexity
   * - `O(1)` in number of key types. Actual cost depends on the number of length of
   * `T::Keys::key_ids()` which is fixed.
   **/
  | { name: "PurgeKeys" };

export type PolimecRuntimeSessionKeys = {
  aura: SpConsensusAuraSr25519AppSr25519Public;
};

export type SpConsensusAuraSr25519AppSr25519Public = FixedBytes<32>;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletParachainStakingCall =
  /**
   * Set the expectations for total staked. These expectations determine the issuance for
   * the round according to logic in `fn compute_issuance`
   **/
  | {
      name: "SetStakingExpectations";
      params: { expectations: { min: bigint; ideal: bigint; max: bigint } };
    }
  /**
   * Set the annual inflation rate to derive per-round inflation
   **/
  | {
      name: "SetInflation";
      params: { schedule: { min: Perbill; ideal: Perbill; max: Perbill } };
    }
  /**
   * Set the account that will hold funds set aside for parachain bond
   **/
  | { name: "SetParachainBondAccount"; params: { new: AccountId32 } }
  /**
   * Set the percent of inflation set aside for parachain bond
   **/
  | { name: "SetParachainBondReservePercent"; params: { new: Percent } }
  /**
   * Set the total number of collator candidates selected per round
   * - changes are not applied until the start of the next round
   **/
  | { name: "SetTotalSelected"; params: { new: number } }
  /**
   * Set the commission for all collators
   **/
  | { name: "SetCollatorCommission"; params: { new: Perbill } }
  /**
   * Set blocks per round
   * - if called with `new` less than length of current round, will transition immediately
   * in the next block
   * - also updates per-round inflation config
   **/
  | { name: "SetBlocksPerRound"; params: { new: number } }
  /**
   * Join the set of collator candidates
   **/
  | { name: "JoinCandidates"; params: { bond: bigint; candidateCount: number } }
  /**
   * Request to leave the set of candidates. If successful, the account is immediately
   * removed from the candidate pool to prevent selection as a collator.
   **/
  | { name: "ScheduleLeaveCandidates"; params: { candidateCount: number } }
  /**
   * Execute leave candidates request
   **/
  | {
      name: "ExecuteLeaveCandidates";
      params: { candidate: AccountId32; candidateDelegationCount: number };
    }
  /**
   * Cancel open request to leave candidates
   * - only callable by collator account
   * - result upon successful call is the candidate is active in the candidate pool
   **/
  | { name: "CancelLeaveCandidates"; params: { candidateCount: number } }
  /**
   * Temporarily leave the set of collator candidates without unbonding
   **/
  | { name: "GoOffline" }
  /**
   * Rejoin the set of collator candidates if previously had called `go_offline`
   **/
  | { name: "GoOnline" }
  /**
   * Increase collator candidate self bond by `more`
   **/
  | { name: "CandidateBondMore"; params: { more: bigint } }
  /**
   * Request by collator candidate to decrease self bond by `less`
   **/
  | { name: "ScheduleCandidateBondLess"; params: { less: bigint } }
  /**
   * Execute pending request to adjust the collator candidate self bond
   **/
  | { name: "ExecuteCandidateBondLess"; params: { candidate: AccountId32 } }
  /**
   * Cancel pending request to adjust the collator candidate self bond
   **/
  | { name: "CancelCandidateBondLess" }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   **/
  | {
      name: "Delegate";
      params: {
        candidate: AccountId32;
        amount: bigint;
        candidateDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   * Sets the auto-compound config for the delegation
   **/
  | {
      name: "DelegateWithAutoCompound";
      params: {
        candidate: AccountId32;
        amount: bigint;
        autoCompound: Percent;
        candidateDelegationCount: number;
        candidateAutoCompoundingDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * DEPRECATED use batch util with schedule_revoke_delegation for all delegations
   * Request to leave the set of delegators. If successful, the caller is scheduled to be
   * allowed to exit via a [DelegationAction::Revoke] towards all existing delegations.
   * Success forbids future delegation requests until the request is invoked or cancelled.
   **/
  | { name: "ScheduleLeaveDelegators" }
  /**
   * DEPRECATED use batch util with execute_delegation_request for all delegations
   * Execute the right to exit the set of delegators and revoke all ongoing delegations.
   **/
  | {
      name: "ExecuteLeaveDelegators";
      params: { delegator: AccountId32; delegationCount: number };
    }
  /**
   * DEPRECATED use batch util with cancel_delegation_request for all delegations
   * Cancel a pending request to exit the set of delegators. Success clears the pending exit
   * request (thereby resetting the delay upon another `leave_delegators` call).
   **/
  | { name: "CancelLeaveDelegators" }
  /**
   * Request to revoke an existing delegation. If successful, the delegation is scheduled
   * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
   * The delegation receives no rewards for the rounds while a revoke is pending.
   * A revoke may not be performed if any other scheduled request is pending.
   **/
  | { name: "ScheduleRevokeDelegation"; params: { collator: AccountId32 } }
  /**
   * Bond more for delegators wrt a specific collator candidate.
   **/
  | {
      name: "DelegatorBondMore";
      params: { candidate: AccountId32; more: bigint };
    }
  /**
   * Request bond less for delegators wrt a specific collator candidate. The delegation's
   * rewards for rounds while the request is pending use the reduced bonded amount.
   * A bond less may not be performed if any other scheduled request is pending.
   **/
  | {
      name: "ScheduleDelegatorBondLess";
      params: { candidate: AccountId32; less: bigint };
    }
  /**
   * Execute pending request to change an existing delegation
   **/
  | {
      name: "ExecuteDelegationRequest";
      params: { delegator: AccountId32; candidate: AccountId32 };
    }
  /**
   * Cancel request to change an existing delegation.
   **/
  | { name: "CancelDelegationRequest"; params: { candidate: AccountId32 } }
  /**
   * Sets the auto-compounding reward percentage for a delegation.
   **/
  | {
      name: "SetAutoCompound";
      params: {
        candidate: AccountId32;
        value: Percent;
        candidateAutoCompoundingDelegationCountHint: number;
        delegationCountHint: number;
      };
    }
  /**
   * Hotfix to remove existing empty entries for candidates that have left.
   **/
  | {
      name: "HotfixRemoveDelegationRequestsExitedCandidates";
      params: { candidates: Array<AccountId32> };
    };

export type PalletParachainStakingCallLike =
  /**
   * Set the expectations for total staked. These expectations determine the issuance for
   * the round according to logic in `fn compute_issuance`
   **/
  | {
      name: "SetStakingExpectations";
      params: { expectations: { min: bigint; ideal: bigint; max: bigint } };
    }
  /**
   * Set the annual inflation rate to derive per-round inflation
   **/
  | {
      name: "SetInflation";
      params: { schedule: { min: Perbill; ideal: Perbill; max: Perbill } };
    }
  /**
   * Set the account that will hold funds set aside for parachain bond
   **/
  | { name: "SetParachainBondAccount"; params: { new: AccountId32Like } }
  /**
   * Set the percent of inflation set aside for parachain bond
   **/
  | { name: "SetParachainBondReservePercent"; params: { new: Percent } }
  /**
   * Set the total number of collator candidates selected per round
   * - changes are not applied until the start of the next round
   **/
  | { name: "SetTotalSelected"; params: { new: number } }
  /**
   * Set the commission for all collators
   **/
  | { name: "SetCollatorCommission"; params: { new: Perbill } }
  /**
   * Set blocks per round
   * - if called with `new` less than length of current round, will transition immediately
   * in the next block
   * - also updates per-round inflation config
   **/
  | { name: "SetBlocksPerRound"; params: { new: number } }
  /**
   * Join the set of collator candidates
   **/
  | { name: "JoinCandidates"; params: { bond: bigint; candidateCount: number } }
  /**
   * Request to leave the set of candidates. If successful, the account is immediately
   * removed from the candidate pool to prevent selection as a collator.
   **/
  | { name: "ScheduleLeaveCandidates"; params: { candidateCount: number } }
  /**
   * Execute leave candidates request
   **/
  | {
      name: "ExecuteLeaveCandidates";
      params: { candidate: AccountId32Like; candidateDelegationCount: number };
    }
  /**
   * Cancel open request to leave candidates
   * - only callable by collator account
   * - result upon successful call is the candidate is active in the candidate pool
   **/
  | { name: "CancelLeaveCandidates"; params: { candidateCount: number } }
  /**
   * Temporarily leave the set of collator candidates without unbonding
   **/
  | { name: "GoOffline" }
  /**
   * Rejoin the set of collator candidates if previously had called `go_offline`
   **/
  | { name: "GoOnline" }
  /**
   * Increase collator candidate self bond by `more`
   **/
  | { name: "CandidateBondMore"; params: { more: bigint } }
  /**
   * Request by collator candidate to decrease self bond by `less`
   **/
  | { name: "ScheduleCandidateBondLess"; params: { less: bigint } }
  /**
   * Execute pending request to adjust the collator candidate self bond
   **/
  | { name: "ExecuteCandidateBondLess"; params: { candidate: AccountId32Like } }
  /**
   * Cancel pending request to adjust the collator candidate self bond
   **/
  | { name: "CancelCandidateBondLess" }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   **/
  | {
      name: "Delegate";
      params: {
        candidate: AccountId32Like;
        amount: bigint;
        candidateDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * If caller is not a delegator and not a collator, then join the set of delegators
   * If caller is a delegator, then makes delegation to change their delegation state
   * Sets the auto-compound config for the delegation
   **/
  | {
      name: "DelegateWithAutoCompound";
      params: {
        candidate: AccountId32Like;
        amount: bigint;
        autoCompound: Percent;
        candidateDelegationCount: number;
        candidateAutoCompoundingDelegationCount: number;
        delegationCount: number;
      };
    }
  /**
   * DEPRECATED use batch util with schedule_revoke_delegation for all delegations
   * Request to leave the set of delegators. If successful, the caller is scheduled to be
   * allowed to exit via a [DelegationAction::Revoke] towards all existing delegations.
   * Success forbids future delegation requests until the request is invoked or cancelled.
   **/
  | { name: "ScheduleLeaveDelegators" }
  /**
   * DEPRECATED use batch util with execute_delegation_request for all delegations
   * Execute the right to exit the set of delegators and revoke all ongoing delegations.
   **/
  | {
      name: "ExecuteLeaveDelegators";
      params: { delegator: AccountId32Like; delegationCount: number };
    }
  /**
   * DEPRECATED use batch util with cancel_delegation_request for all delegations
   * Cancel a pending request to exit the set of delegators. Success clears the pending exit
   * request (thereby resetting the delay upon another `leave_delegators` call).
   **/
  | { name: "CancelLeaveDelegators" }
  /**
   * Request to revoke an existing delegation. If successful, the delegation is scheduled
   * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
   * The delegation receives no rewards for the rounds while a revoke is pending.
   * A revoke may not be performed if any other scheduled request is pending.
   **/
  | { name: "ScheduleRevokeDelegation"; params: { collator: AccountId32Like } }
  /**
   * Bond more for delegators wrt a specific collator candidate.
   **/
  | {
      name: "DelegatorBondMore";
      params: { candidate: AccountId32Like; more: bigint };
    }
  /**
   * Request bond less for delegators wrt a specific collator candidate. The delegation's
   * rewards for rounds while the request is pending use the reduced bonded amount.
   * A bond less may not be performed if any other scheduled request is pending.
   **/
  | {
      name: "ScheduleDelegatorBondLess";
      params: { candidate: AccountId32Like; less: bigint };
    }
  /**
   * Execute pending request to change an existing delegation
   **/
  | {
      name: "ExecuteDelegationRequest";
      params: { delegator: AccountId32Like; candidate: AccountId32Like };
    }
  /**
   * Cancel request to change an existing delegation.
   **/
  | { name: "CancelDelegationRequest"; params: { candidate: AccountId32Like } }
  /**
   * Sets the auto-compounding reward percentage for a delegation.
   **/
  | {
      name: "SetAutoCompound";
      params: {
        candidate: AccountId32Like;
        value: Percent;
        candidateAutoCompoundingDelegationCountHint: number;
        delegationCountHint: number;
      };
    }
  /**
   * Hotfix to remove existing empty entries for candidates that have left.
   **/
  | {
      name: "HotfixRemoveDelegationRequestsExitedCandidates";
      params: { candidates: Array<AccountId32Like> };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmpQueueCall =
  /**
   * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: "SuspendXcmExecution" }
  /**
   * Resumes all XCM executions for the XCMP queue.
   *
   * Note that this function doesn't change the status of the in/out bound channels.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: "ResumeXcmExecution" }
  /**
   * Overwrites the number of pages which must be in the queue for the other side to be
   * told to suspend their sending.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.suspend_value`
   **/
  | { name: "UpdateSuspendThreshold"; params: { new: number } }
  /**
   * Overwrites the number of pages which must be in the queue after which we drop any
   * further messages from the channel.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.drop_threshold`
   **/
  | { name: "UpdateDropThreshold"; params: { new: number } }
  /**
   * Overwrites the number of pages which the queue must be reduced to before it signals
   * that message sending may recommence after it has been suspended.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.resume_threshold`
   **/
  | { name: "UpdateResumeThreshold"; params: { new: number } };

export type CumulusPalletXcmpQueueCallLike =
  /**
   * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: "SuspendXcmExecution" }
  /**
   * Resumes all XCM executions for the XCMP queue.
   *
   * Note that this function doesn't change the status of the in/out bound channels.
   *
   * - `origin`: Must pass `ControllerOrigin`.
   **/
  | { name: "ResumeXcmExecution" }
  /**
   * Overwrites the number of pages which must be in the queue for the other side to be
   * told to suspend their sending.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.suspend_value`
   **/
  | { name: "UpdateSuspendThreshold"; params: { new: number } }
  /**
   * Overwrites the number of pages which must be in the queue after which we drop any
   * further messages from the channel.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.drop_threshold`
   **/
  | { name: "UpdateDropThreshold"; params: { new: number } }
  /**
   * Overwrites the number of pages which the queue must be reduced to before it signals
   * that message sending may recommence after it has been suspended.
   *
   * - `origin`: Must pass `Root`.
   * - `new`: Desired value for `QueueConfigData.resume_threshold`
   **/
  | { name: "UpdateResumeThreshold"; params: { new: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletXcmCall =
  | {
      name: "Send";
      params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: "TeleportAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: "ReserveTransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | {
      name: "Execute";
      params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
    }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | {
      name: "ForceXcmVersion";
      params: { location: StagingXcmV5Location; version: number };
    }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | {
      name: "ForceDefaultXcmVersion";
      params: { maybeXcmVersion?: number | undefined };
    }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | {
      name: "ForceSubscribeVersionNotify";
      params: { location: XcmVersionedLocation };
    }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | {
      name: "ForceUnsubscribeVersionNotify";
      params: { location: XcmVersionedLocation };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "LimitedReserveTransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "LimitedTeleportAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: "ForceSuspension"; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "TransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | {
      name: "ClaimAssets";
      params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
    }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "TransferAssetsUsingTypeAndThen";
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type PalletXcmCallLike =
  | {
      name: "Send";
      params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * **This function is deprecated: Use `limited_teleport_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: "TeleportAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
   * with all fees taken as needed from the asset.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   **/
  | {
      name: "ReserveTransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
      };
    }
  /**
   * Execute an XCM message from a local, signed, origin.
   *
   * An event is deposited indicating whether `msg` could be executed completely or only
   * partially.
   *
   * No more than `max_weight` will be used in its attempted execution. If this is less than
   * the maximum amount of weight that the message could take to be executed, then no
   * execution attempt will be made.
   **/
  | {
      name: "Execute";
      params: { message: XcmVersionedXcm; maxWeight: SpWeightsWeightV2Weight };
    }
  /**
   * Extoll that a particular destination can be communicated with through a particular
   * version of XCM.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The destination that is being described.
   * - `xcm_version`: The latest version of XCM that `location` supports.
   **/
  | {
      name: "ForceXcmVersion";
      params: { location: StagingXcmV5Location; version: number };
    }
  /**
   * Set a safe XCM version (the version that XCM should be encoded with if the most recent
   * version a destination can accept is unknown).
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
   **/
  | {
      name: "ForceDefaultXcmVersion";
      params: { maybeXcmVersion?: number | undefined };
    }
  /**
   * Ask a location to notify us regarding their XCM version and any changes to it.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we should subscribe for XCM version notifications.
   **/
  | {
      name: "ForceSubscribeVersionNotify";
      params: { location: XcmVersionedLocation };
    }
  /**
   * Require that a particular destination should no longer notify us regarding any XCM
   * version changes.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `location`: The location to which we are currently subscribed for XCM version
   * notifications which we no longer desire.
   **/
  | {
      name: "ForceUnsubscribeVersionNotify";
      params: { location: XcmVersionedLocation };
    }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve.
   *
   * `assets` must have same reserve location and may not be teleportable to `dest`.
   * - `assets` have local reserve: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `assets` have destination reserve: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
   * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
   * to mint and deposit reserve-based assets to `beneficiary`.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "LimitedReserveTransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Teleport some assets from the local chain to some destination chain.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` chain.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "LimitedTeleportAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Set or unset the global suspension state of the XCM executor.
   *
   * - `origin`: Must be an origin specified by AdminOrigin.
   * - `suspended`: `true` to suspend, `false` to resume.
   **/
  | { name: "ForceSuspension"; params: { suspended: boolean } }
  /**
   * Transfer some assets from the local chain to the destination chain through their local,
   * destination or remote reserve, or through teleports.
   *
   * Fee payment on the destination side is made from the asset in the `assets` vector of
   * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
   * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
   * operation will fail and the sent assets may be at risk.
   *
   * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
   * to `dest`, no limitations imposed on `fees`.
   * - for local reserve: transfer assets to sovereign account of destination chain and
   * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
   * `beneficiary`.
   * - for destination reserve: burn local assets and forward a notification to `dest` chain
   * to withdraw the reserve assets from this chain's sovereign account and deposit them
   * to `beneficiary`.
   * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
   * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
   * and deposit reserve-based assets to `beneficiary`.
   * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
   * assets and deposit them to `beneficiary`.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
   * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
   * from relay to parachain.
   * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
   * generally be an `AccountId32` value.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
   * fees.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "TransferAssets";
      params: {
        dest: XcmVersionedLocation;
        beneficiary: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        feeAssetItem: number;
        weightLimit: XcmV3WeightLimit;
      };
    }
  /**
   * Claims assets trapped on this pallet because of leftover assets during XCM execution.
   *
   * - `origin`: Anyone can call this extrinsic.
   * - `assets`: The exact assets that were trapped. Use the version to specify what version
   * was the latest when they were trapped.
   * - `beneficiary`: The location/account where the claimed assets will be deposited.
   **/
  | {
      name: "ClaimAssets";
      params: { assets: XcmVersionedAssets; beneficiary: XcmVersionedLocation };
    }
  /**
   * Transfer assets from the local chain to the destination chain using explicit transfer
   * types for assets and fees.
   *
   * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
   * provide the `assets_transfer_type` to be used for `assets`:
   * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
   * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
   * assets to `beneficiary`.
   * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
   * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
   * deposit them to `beneficiary`.
   * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
   * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
   * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
   * the remote `reserve` is Asset Hub.
   * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
   * mint/teleport assets and deposit them to `beneficiary`.
   *
   * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
   * buy execution using transferred `assets` identified by `remote_fees_id`.
   * Make sure enough of the specified `remote_fees_id` asset is included in the given list
   * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
   * is needed than `weight_limit`, then the operation will fail and the sent assets may be
   * at risk.
   *
   * `remote_fees_id` may use different transfer type than rest of `assets` and can be
   * specified through `fees_transfer_type`.
   *
   * The caller needs to specify what should happen to the transferred assets once they reach
   * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
   * contains the instructions to execute on `dest` as a final step.
   * This is usually as simple as:
   * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
   * but could be something more exotic like sending the `assets` even further.
   *
   * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
   * - `dest`: Destination context for the assets. Will typically be `[Parent,
   * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
   * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
   * parachain across a bridge to another ecosystem destination.
   * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
   * fee on the `dest` (and possibly reserve) chains.
   * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
   * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
   * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
   * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
   * transfer, which also determines what happens to the assets on the destination chain.
   * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
   **/
  | {
      name: "TransferAssetsUsingTypeAndThen";
      params: {
        dest: XcmVersionedLocation;
        assets: XcmVersionedAssets;
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
        remoteFeesId: XcmVersionedAssetId;
        feesTransferType: StagingXcmExecutorAssetTransferTransferType;
        customXcmOnDest: XcmVersionedXcm;
        weightLimit: XcmV3WeightLimit;
      };
    };

export type XcmVersionedXcm =
  | { type: "V3"; value: XcmV3Xcm }
  | { type: "V4"; value: StagingXcmV4Xcm }
  | { type: "V5"; value: StagingXcmV5Xcm };

export type XcmV3Xcm = Array<XcmV3Instruction>;

export type XcmV3Instruction =
  | { type: "WithdrawAsset"; value: XcmV3MultiassetMultiAssets }
  | { type: "ReserveAssetDeposited"; value: XcmV3MultiassetMultiAssets }
  | { type: "ReceiveTeleportedAsset"; value: XcmV3MultiassetMultiAssets }
  | {
      type: "QueryResponse";
      value: {
        queryId: bigint;
        response: XcmV3Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    }
  | {
      type: "TransferAsset";
      value: {
        assets: XcmV3MultiassetMultiAssets;
        beneficiary: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | {
      type: "TransferReserveAsset";
      value: {
        assets: XcmV3MultiassetMultiAssets;
        dest: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: "Transact";
      value: {
        originKind: XcmV3OriginKind;
        requireWeightAtMost: SpWeightsWeightV2Weight;
        call: XcmDoubleEncoded;
      };
    }
  | {
      type: "HrmpNewChannelOpenRequest";
      value: { sender: number; maxMessageSize: number; maxCapacity: number };
    }
  | { type: "HrmpChannelAccepted"; value: { recipient: number } }
  | {
      type: "HrmpChannelClosing";
      value: { initiator: number; sender: number; recipient: number };
    }
  | { type: "ClearOrigin" }
  | { type: "DescendOrigin"; value: XcmV3Junctions }
  | { type: "ReportError"; value: XcmV3QueryResponseInfo }
  | {
      type: "DepositAsset";
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        beneficiary: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | {
      type: "DepositReserveAsset";
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        dest: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: "ExchangeAsset";
      value: {
        give: XcmV3MultiassetMultiAssetFilter;
        want: XcmV3MultiassetMultiAssets;
        maximal: boolean;
      };
    }
  | {
      type: "InitiateReserveWithdraw";
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        reserve: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: "InitiateTeleport";
      value: {
        assets: XcmV3MultiassetMultiAssetFilter;
        dest: StagingXcmV3MultilocationMultiLocation;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: "ReportHolding";
      value: {
        responseInfo: XcmV3QueryResponseInfo;
        assets: XcmV3MultiassetMultiAssetFilter;
      };
    }
  | {
      type: "BuyExecution";
      value: { fees: XcmV3MultiassetMultiAsset; weightLimit: XcmV3WeightLimit };
    }
  | { type: "RefundSurplus" }
  | { type: "SetErrorHandler"; value: XcmV3Xcm }
  | { type: "SetAppendix"; value: XcmV3Xcm }
  | { type: "ClearError" }
  | {
      type: "ClaimAsset";
      value: {
        assets: XcmV3MultiassetMultiAssets;
        ticket: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | { type: "Trap"; value: bigint }
  | {
      type: "SubscribeVersion";
      value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight };
    }
  | { type: "UnsubscribeVersion" }
  | { type: "BurnAsset"; value: XcmV3MultiassetMultiAssets }
  | { type: "ExpectAsset"; value: XcmV3MultiassetMultiAssets }
  | {
      type: "ExpectOrigin";
      value?: StagingXcmV3MultilocationMultiLocation | undefined;
    }
  | { type: "ExpectError"; value?: [number, XcmV3TraitsError] | undefined }
  | { type: "ExpectTransactStatus"; value: XcmV3MaybeErrorCode }
  | {
      type: "QueryPallet";
      value: { moduleName: Bytes; responseInfo: XcmV3QueryResponseInfo };
    }
  | {
      type: "ExpectPallet";
      value: {
        index: number;
        name: Bytes;
        moduleName: Bytes;
        crateMajor: number;
        minCrateMinor: number;
      };
    }
  | { type: "ReportTransactStatus"; value: XcmV3QueryResponseInfo }
  | { type: "ClearTransactStatus" }
  | { type: "UniversalOrigin"; value: XcmV3Junction }
  | {
      type: "ExportMessage";
      value: {
        network: XcmV3JunctionNetworkId;
        destination: XcmV3Junctions;
        xcm: XcmV3Xcm;
      };
    }
  | {
      type: "LockAsset";
      value: {
        asset: XcmV3MultiassetMultiAsset;
        unlocker: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | {
      type: "UnlockAsset";
      value: {
        asset: XcmV3MultiassetMultiAsset;
        target: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | {
      type: "NoteUnlockable";
      value: {
        asset: XcmV3MultiassetMultiAsset;
        owner: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | {
      type: "RequestUnlock";
      value: {
        asset: XcmV3MultiassetMultiAsset;
        locker: StagingXcmV3MultilocationMultiLocation;
      };
    }
  | { type: "SetFeesMode"; value: { jitWithdraw: boolean } }
  | { type: "SetTopic"; value: FixedBytes<32> }
  | { type: "ClearTopic" }
  | { type: "AliasOrigin"; value: StagingXcmV3MultilocationMultiLocation }
  | {
      type: "UnpaidExecution";
      value: {
        weightLimit: XcmV3WeightLimit;
        checkOrigin?: StagingXcmV3MultilocationMultiLocation | undefined;
      };
    };

export type XcmV3Response =
  | { type: "Null" }
  | { type: "Assets"; value: XcmV3MultiassetMultiAssets }
  | { type: "ExecutionResult"; value?: [number, XcmV3TraitsError] | undefined }
  | { type: "Version"; value: number }
  | { type: "PalletsInfo"; value: Array<XcmV3PalletInfo> }
  | { type: "DispatchResult"; value: XcmV3MaybeErrorCode };

export type XcmV3PalletInfo = {
  index: number;
  name: Bytes;
  moduleName: Bytes;
  major: number;
  minor: number;
  patch: number;
};

export type XcmV3QueryResponseInfo = {
  destination: StagingXcmV3MultilocationMultiLocation;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type XcmV3MultiassetMultiAssetFilter =
  | { type: "Definite"; value: XcmV3MultiassetMultiAssets }
  | { type: "Wild"; value: XcmV3MultiassetWildMultiAsset };

export type XcmV3MultiassetWildMultiAsset =
  | { type: "All" }
  | {
      type: "AllOf";
      value: {
        id: XcmV3MultiassetAssetId;
        fun: XcmV3MultiassetWildFungibility;
      };
    }
  | { type: "AllCounted"; value: number }
  | {
      type: "AllOfCounted";
      value: {
        id: XcmV3MultiassetAssetId;
        fun: XcmV3MultiassetWildFungibility;
        count: number;
      };
    };

export type XcmV3MultiassetWildFungibility = "Fungible" | "NonFungible";

export type StagingXcmV4Xcm = Array<StagingXcmV4Instruction>;

export type StagingXcmV4Instruction =
  | { type: "WithdrawAsset"; value: StagingXcmV4AssetAssets }
  | { type: "ReserveAssetDeposited"; value: StagingXcmV4AssetAssets }
  | { type: "ReceiveTeleportedAsset"; value: StagingXcmV4AssetAssets }
  | {
      type: "QueryResponse";
      value: {
        queryId: bigint;
        response: StagingXcmV4Response;
        maxWeight: SpWeightsWeightV2Weight;
        querier?: StagingXcmV4Location | undefined;
      };
    }
  | {
      type: "TransferAsset";
      value: {
        assets: StagingXcmV4AssetAssets;
        beneficiary: StagingXcmV4Location;
      };
    }
  | {
      type: "TransferReserveAsset";
      value: {
        assets: StagingXcmV4AssetAssets;
        dest: StagingXcmV4Location;
        xcm: StagingXcmV4Xcm;
      };
    }
  | {
      type: "Transact";
      value: {
        originKind: XcmV3OriginKind;
        requireWeightAtMost: SpWeightsWeightV2Weight;
        call: XcmDoubleEncoded;
      };
    }
  | {
      type: "HrmpNewChannelOpenRequest";
      value: { sender: number; maxMessageSize: number; maxCapacity: number };
    }
  | { type: "HrmpChannelAccepted"; value: { recipient: number } }
  | {
      type: "HrmpChannelClosing";
      value: { initiator: number; sender: number; recipient: number };
    }
  | { type: "ClearOrigin" }
  | { type: "DescendOrigin"; value: StagingXcmV4Junctions }
  | { type: "ReportError"; value: StagingXcmV4QueryResponseInfo }
  | {
      type: "DepositAsset";
      value: {
        assets: StagingXcmV4AssetAssetFilter;
        beneficiary: StagingXcmV4Location;
      };
    }
  | {
      type: "DepositReserveAsset";
      value: {
        assets: StagingXcmV4AssetAssetFilter;
        dest: StagingXcmV4Location;
        xcm: StagingXcmV4Xcm;
      };
    }
  | {
      type: "ExchangeAsset";
      value: {
        give: StagingXcmV4AssetAssetFilter;
        want: StagingXcmV4AssetAssets;
        maximal: boolean;
      };
    }
  | {
      type: "InitiateReserveWithdraw";
      value: {
        assets: StagingXcmV4AssetAssetFilter;
        reserve: StagingXcmV4Location;
        xcm: StagingXcmV4Xcm;
      };
    }
  | {
      type: "InitiateTeleport";
      value: {
        assets: StagingXcmV4AssetAssetFilter;
        dest: StagingXcmV4Location;
        xcm: StagingXcmV4Xcm;
      };
    }
  | {
      type: "ReportHolding";
      value: {
        responseInfo: StagingXcmV4QueryResponseInfo;
        assets: StagingXcmV4AssetAssetFilter;
      };
    }
  | {
      type: "BuyExecution";
      value: { fees: StagingXcmV4Asset; weightLimit: XcmV3WeightLimit };
    }
  | { type: "RefundSurplus" }
  | { type: "SetErrorHandler"; value: StagingXcmV4Xcm }
  | { type: "SetAppendix"; value: StagingXcmV4Xcm }
  | { type: "ClearError" }
  | {
      type: "ClaimAsset";
      value: { assets: StagingXcmV4AssetAssets; ticket: StagingXcmV4Location };
    }
  | { type: "Trap"; value: bigint }
  | {
      type: "SubscribeVersion";
      value: { queryId: bigint; maxResponseWeight: SpWeightsWeightV2Weight };
    }
  | { type: "UnsubscribeVersion" }
  | { type: "BurnAsset"; value: StagingXcmV4AssetAssets }
  | { type: "ExpectAsset"; value: StagingXcmV4AssetAssets }
  | { type: "ExpectOrigin"; value?: StagingXcmV4Location | undefined }
  | { type: "ExpectError"; value?: [number, XcmV3TraitsError] | undefined }
  | { type: "ExpectTransactStatus"; value: XcmV3MaybeErrorCode }
  | {
      type: "QueryPallet";
      value: { moduleName: Bytes; responseInfo: StagingXcmV4QueryResponseInfo };
    }
  | {
      type: "ExpectPallet";
      value: {
        index: number;
        name: Bytes;
        moduleName: Bytes;
        crateMajor: number;
        minCrateMinor: number;
      };
    }
  | { type: "ReportTransactStatus"; value: StagingXcmV4QueryResponseInfo }
  | { type: "ClearTransactStatus" }
  | { type: "UniversalOrigin"; value: StagingXcmV4Junction }
  | {
      type: "ExportMessage";
      value: {
        network: StagingXcmV4JunctionNetworkId;
        destination: StagingXcmV4Junctions;
        xcm: StagingXcmV4Xcm;
      };
    }
  | {
      type: "LockAsset";
      value: { asset: StagingXcmV4Asset; unlocker: StagingXcmV4Location };
    }
  | {
      type: "UnlockAsset";
      value: { asset: StagingXcmV4Asset; target: StagingXcmV4Location };
    }
  | {
      type: "NoteUnlockable";
      value: { asset: StagingXcmV4Asset; owner: StagingXcmV4Location };
    }
  | {
      type: "RequestUnlock";
      value: { asset: StagingXcmV4Asset; locker: StagingXcmV4Location };
    }
  | { type: "SetFeesMode"; value: { jitWithdraw: boolean } }
  | { type: "SetTopic"; value: FixedBytes<32> }
  | { type: "ClearTopic" }
  | { type: "AliasOrigin"; value: StagingXcmV4Location }
  | {
      type: "UnpaidExecution";
      value: {
        weightLimit: XcmV3WeightLimit;
        checkOrigin?: StagingXcmV4Location | undefined;
      };
    };

export type StagingXcmV4QueryResponseInfo = {
  destination: StagingXcmV4Location;
  queryId: bigint;
  maxWeight: SpWeightsWeightV2Weight;
};

export type StagingXcmV4AssetAssetFilter =
  | { type: "Definite"; value: StagingXcmV4AssetAssets }
  | { type: "Wild"; value: StagingXcmV4AssetWildAsset };

export type StagingXcmV4AssetWildAsset =
  | { type: "All" }
  | {
      type: "AllOf";
      value: {
        id: StagingXcmV4AssetAssetId;
        fun: StagingXcmV4AssetWildFungibility;
      };
    }
  | { type: "AllCounted"; value: number }
  | {
      type: "AllOfCounted";
      value: {
        id: StagingXcmV4AssetAssetId;
        fun: StagingXcmV4AssetWildFungibility;
        count: number;
      };
    };

export type StagingXcmV4AssetWildFungibility = "Fungible" | "NonFungible";

export type StagingXcmExecutorAssetTransferTransferType =
  | { type: "Teleport" }
  | { type: "LocalReserve" }
  | { type: "DestinationReserve" }
  | { type: "RemoteReserve"; value: XcmVersionedLocation };

export type XcmVersionedAssetId =
  | { type: "V3"; value: XcmV3MultiassetAssetId }
  | { type: "V4"; value: StagingXcmV4AssetAssetId }
  | { type: "V5"; value: StagingXcmV5AssetAssetId };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type CumulusPalletXcmCall = null;

export type CumulusPalletXcmCallLike = null;

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMessageQueueCall =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | {
      name: "ReapPage";
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        pageIndex: number;
      };
    }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: "ExecuteOverweight";
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

export type PalletMessageQueueCallLike =
  /**
   * Remove a page which has no more messages remaining to be processed or is stale.
   **/
  | {
      name: "ReapPage";
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        pageIndex: number;
      };
    }
  /**
   * Execute an overweight message.
   *
   * Temporary processing errors will be propagated whereas permanent errors are treated
   * as success condition.
   *
   * - `origin`: Must be `Signed`.
   * - `message_origin`: The origin from which the message to be executed arrived.
   * - `page`: The page in the queue in which the message to be executed is sitting.
   * - `index`: The index into the queue of the message to be executed.
   * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
   * of the message.
   *
   * Benchmark complexity considerations: O(index + weight_limit).
   **/
  | {
      name: "ExecuteOverweight";
      params: {
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
        page: number;
        index: number;
        weightLimit: SpWeightsWeightV2Weight;
      };
    };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletTreasuryCall =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | {
      name: "SpendLocal";
      params: { amount: bigint; beneficiary: MultiAddress };
    }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: "RemoveApproval"; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: "Spend";
      params: {
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32;
        validFrom?: number | undefined;
      };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: "Payout"; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: "CheckStatus"; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: "VoidSpend"; params: { index: number } };

export type PalletTreasuryCallLike =
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
   *
   * ### Details
   * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
   * beneficiary.
   *
   * ### Parameters
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The destination account for the transfer.
   *
   * ## Events
   *
   * Emits [`Event::SpendApproved`] if successful.
   **/
  | {
      name: "SpendLocal";
      params: { amount: bigint; beneficiary: MultiAddressLike };
    }
  /**
   * Force a previously approved proposal to be removed from the approval queue.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * The original deposit will no longer be returned.
   *
   * ### Parameters
   * - `proposal_id`: The index of a proposal
   *
   * ### Complexity
   * - O(A) where `A` is the number of approvals
   *
   * ### Errors
   * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
   * approval queue, i.e., the proposal has not been approved. This could also mean the
   * proposal does not exist altogether, thus there is no way it would have been approved
   * in the first place.
   **/
  | { name: "RemoveApproval"; params: { proposalId: number } }
  /**
   * Propose and approve a spend of treasury funds.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::SpendOrigin`] with the `Success` value being at least
   * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
   * for assertion using the [`Config::BalanceConverter`].
   *
   * ## Details
   *
   * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
   * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
   * the [`Config::PayoutPeriod`].
   *
   * ### Parameters
   * - `asset_kind`: An indicator of the specific asset class to be spent.
   * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
   * - `beneficiary`: The beneficiary of the spend.
   * - `valid_from`: The block number from which the spend can be claimed. It can refer to
   * the past if the resulting spend has not yet expired according to the
   * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
   * approval.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendApproved`] if successful.
   **/
  | {
      name: "Spend";
      params: {
        assetKind: [];
        amount: bigint;
        beneficiary: AccountId32Like;
        validFrom?: number | undefined;
      };
    }
  /**
   * Claim a spend.
   *
   * ## Dispatch Origin
   *
   * Must be signed
   *
   * ## Details
   *
   * Spends must be claimed within some temporal bounds. A spend may be claimed within one
   * [`Config::PayoutPeriod`] from the `valid_from` block.
   * In case of a payout failure, the spend status must be updated with the `check_status`
   * dispatchable before retrying with the current function.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::Paid`] if successful.
   **/
  | { name: "Payout"; params: { index: number } }
  /**
   * Check the status of the spend and remove it from the storage if processed.
   *
   * ## Dispatch Origin
   *
   * Must be signed.
   *
   * ## Details
   *
   * The status check is a prerequisite for retrying a failed payout.
   * If a spend has either succeeded or expired, it is removed from the storage by this
   * function. In such instances, transaction fees are refunded.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::PaymentFailed`] if the spend payout has failed.
   * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
   **/
  | { name: "CheckStatus"; params: { index: number } }
  /**
   * Void previously approved spend.
   *
   * ## Dispatch Origin
   *
   * Must be [`Config::RejectOrigin`].
   *
   * ## Details
   *
   * A spend void is only possible if the payout has not been attempted yet.
   *
   * ### Parameters
   * - `index`: The spend index.
   *
   * ## Events
   *
   * Emits [`Event::AssetSpendVoided`] if successful.
   **/
  | { name: "VoidSpend"; params: { index: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletDemocracyCall =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | {
      name: "Propose";
      params: { proposal: FrameSupportPreimagesBounded; value: bigint };
    }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: "Second"; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | {
      name: "Vote";
      params: { refIndex: number; vote: PalletDemocracyVoteAccountVote };
    }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: "EmergencyCancel"; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | {
      name: "ExternalPropose";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ExternalProposeMajority";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ExternalProposeDefault";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "FastTrack";
      params: { proposalHash: H256; votingPeriod: number; delay: number };
    }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: "VetoExternal"; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: "CancelReferendum"; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | {
      name: "Delegate";
      params: {
        to: MultiAddress;
        conviction: PalletDemocracyConviction;
        balance: bigint;
      };
    }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: "Undelegate" }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: "ClearPublicProposals" }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: "Unlock"; params: { target: MultiAddress } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: "RemoveVote"; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: "RemoveOtherVote"; params: { target: MultiAddress; index: number } }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | {
      name: "Blacklist";
      params: { proposalHash: H256; maybeRefIndex?: number | undefined };
    }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: "CancelProposal"; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | {
      name: "SetMetadata";
      params: {
        owner: PalletDemocracyMetadataOwner;
        maybeHash?: H256 | undefined;
      };
    };

export type PalletDemocracyCallLike =
  /**
   * Propose a sensitive action to be taken.
   *
   * The dispatch origin of this call must be _Signed_ and the sender must
   * have funds to cover the deposit.
   *
   * - `proposal_hash`: The hash of the proposal preimage.
   * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
   *
   * Emits `Proposed`.
   **/
  | {
      name: "Propose";
      params: { proposal: FrameSupportPreimagesBounded; value: bigint };
    }
  /**
   * Signals agreement with a particular proposal.
   *
   * The dispatch origin of this call must be _Signed_ and the sender
   * must have funds to cover the deposit, equal to the original deposit.
   *
   * - `proposal`: The index of the proposal to second.
   **/
  | { name: "Second"; params: { proposal: number } }
  /**
   * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
   * otherwise it is a vote to keep the status quo.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `ref_index`: The index of the referendum to vote for.
   * - `vote`: The vote configuration.
   **/
  | {
      name: "Vote";
      params: { refIndex: number; vote: PalletDemocracyVoteAccountVote };
    }
  /**
   * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
   * referendum.
   *
   * The dispatch origin of this call must be `CancellationOrigin`.
   *
   * -`ref_index`: The index of the referendum to cancel.
   *
   * Weight: `O(1)`.
   **/
  | { name: "EmergencyCancel"; params: { refIndex: number } }
  /**
   * Schedule a referendum to be tabled once it is legal to schedule an external
   * referendum.
   *
   * The dispatch origin of this call must be `ExternalOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   **/
  | {
      name: "ExternalPropose";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
   * an external referendum.
   *
   * The dispatch of this call must be `ExternalMajorityOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ExternalProposeMajority";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
   * schedule an external referendum.
   *
   * The dispatch of this call must be `ExternalDefaultOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal.
   *
   * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
   * pre-scheduled `external_propose` call.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "ExternalProposeDefault";
      params: { proposal: FrameSupportPreimagesBounded };
    }
  /**
   * Schedule the currently externally-proposed majority-carries referendum to be tabled
   * immediately. If there is no externally-proposed referendum currently, or if there is one
   * but it is not a majority-carries referendum then it fails.
   *
   * The dispatch of this call must be `FastTrackOrigin`.
   *
   * - `proposal_hash`: The hash of the current external proposal.
   * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
   * Must be always greater than zero.
   * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
   * - `delay`: The number of block after voting has ended in approval and this should be
   * enacted. This doesn't have a minimum amount.
   *
   * Emits `Started`.
   *
   * Weight: `O(1)`
   **/
  | {
      name: "FastTrack";
      params: { proposalHash: H256; votingPeriod: number; delay: number };
    }
  /**
   * Veto and blacklist the external proposal hash.
   *
   * The dispatch origin of this call must be `VetoOrigin`.
   *
   * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
   *
   * Emits `Vetoed`.
   *
   * Weight: `O(V + log(V))` where V is number of `existing vetoers`
   **/
  | { name: "VetoExternal"; params: { proposalHash: H256 } }
  /**
   * Remove a referendum.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * - `ref_index`: The index of the referendum to cancel.
   *
   * # Weight: `O(1)`.
   **/
  | { name: "CancelReferendum"; params: { refIndex: number } }
  /**
   * Delegate the voting power (with some given conviction) of the sending account.
   *
   * The balance delegated is locked for as long as it's delegated, and thereafter for the
   * time appropriate for the conviction's lock period.
   *
   * The dispatch origin of this call must be _Signed_, and the signing account must either:
   * - be delegating already; or
   * - have no voting activity (if there is, then it will need to be removed/consolidated
   * through `reap_vote` or `unvote`).
   *
   * - `to`: The account whose voting the `target` account's voting power will follow.
   * - `conviction`: The conviction that will be attached to the delegated votes. When the
   * account is undelegated, the funds will be locked for the corresponding period.
   * - `balance`: The amount of the account's balance to be used in delegating. This must not
   * be more than the account's current balance.
   *
   * Emits `Delegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | {
      name: "Delegate";
      params: {
        to: MultiAddressLike;
        conviction: PalletDemocracyConviction;
        balance: bigint;
      };
    }
  /**
   * Undelegate the voting power of the sending account.
   *
   * Tokens may be unlocked following once an amount of time consistent with the lock period
   * of the conviction with which the delegation was issued.
   *
   * The dispatch origin of this call must be _Signed_ and the signing account must be
   * currently delegating.
   *
   * Emits `Undelegated`.
   *
   * Weight: `O(R)` where R is the number of referendums the voter delegating to has
   * voted on. Weight is charged as if maximum votes.
   **/
  | { name: "Undelegate" }
  /**
   * Clears all public proposals.
   *
   * The dispatch origin of this call must be _Root_.
   *
   * Weight: `O(1)`.
   **/
  | { name: "ClearPublicProposals" }
  /**
   * Unlock tokens that have an expired lock.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account to remove the lock on.
   *
   * Weight: `O(R)` with R number of vote of target.
   **/
  | { name: "Unlock"; params: { target: MultiAddressLike } }
  /**
   * Remove a vote for a referendum.
   *
   * If:
   * - the referendum was cancelled, or
   * - the referendum is ongoing, or
   * - the referendum has ended such that
   * - the vote of the account was in opposition to the result; or
   * - there was no conviction to the account's vote; or
   * - the account made a split vote
   * ...then the vote is removed cleanly and a following call to `unlock` may result in more
   * funds being available.
   *
   * If, however, the referendum has ended and:
   * - it finished corresponding to the vote of the account, and
   * - the account made a standard vote with conviction, and
   * - the lock period of the conviction is not over
   * ...then the lock will be aggregated into the overall account's lock, which may involve
   * *overlocking* (where the two locks are combined into a single lock that is the maximum
   * of both the amount locked and the time is it locked for).
   *
   * The dispatch origin of this call must be _Signed_, and the signer must have a vote
   * registered for referendum `index`.
   *
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | { name: "RemoveVote"; params: { index: number } }
  /**
   * Remove a vote for a referendum.
   *
   * If the `target` is equal to the signer, then this function is exactly equivalent to
   * `remove_vote`. If not equal to the signer, then the vote must have expired,
   * either because the referendum was cancelled, because the voter lost the referendum or
   * because the conviction period is over.
   *
   * The dispatch origin of this call must be _Signed_.
   *
   * - `target`: The account of the vote to be removed; this account must have voted for
   * referendum `index`.
   * - `index`: The index of referendum of the vote to be removed.
   *
   * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
   * Weight is calculated for the maximum number of vote.
   **/
  | {
      name: "RemoveOtherVote";
      params: { target: MultiAddressLike; index: number };
    }
  /**
   * Permanently place a proposal into the blacklist. This prevents it from ever being
   * proposed again.
   *
   * If called on a queued public or external proposal, then this will result in it being
   * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
   * then it will be cancelled.
   *
   * The dispatch origin of this call must be `BlacklistOrigin`.
   *
   * - `proposal_hash`: The proposal hash to blacklist permanently.
   * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
   * cancelled.
   *
   * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
   * reasonable value).
   **/
  | {
      name: "Blacklist";
      params: { proposalHash: H256; maybeRefIndex?: number | undefined };
    }
  /**
   * Remove a proposal.
   *
   * The dispatch origin of this call must be `CancelProposalOrigin`.
   *
   * - `prop_index`: The index of the proposal to cancel.
   *
   * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
   **/
  | { name: "CancelProposal"; params: { propIndex: number } }
  /**
   * Set or clear a metadata of a proposal or a referendum.
   *
   * Parameters:
   * - `origin`: Must correspond to the `MetadataOwner`.
   * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
   * threshold.
   * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
   * threshold.
   * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
   * threshold.
   * - `Signed` by a creator for a public proposal.
   * - `Signed` to clear a metadata for a finished referendum.
   * - `Root` to set a metadata for an ongoing referendum.
   * - `owner`: an identifier of a metadata owner.
   * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
   **/
  | {
      name: "SetMetadata";
      params: {
        owner: PalletDemocracyMetadataOwner;
        maybeHash?: H256 | undefined;
      };
    };

export type FrameSupportPreimagesBounded =
  | { type: "Legacy"; value: { hash: H256 } }
  | { type: "Inline"; value: Bytes }
  | { type: "Lookup"; value: { hash: H256; len: number } };

export type SpRuntimeBlakeTwo256 = {};

export type PalletDemocracyConviction =
  | "None"
  | "Locked1x"
  | "Locked2x"
  | "Locked3x"
  | "Locked4x"
  | "Locked5x"
  | "Locked6x";

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletCollectiveCall =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32>;
        prime?: AccountId32 | undefined;
        oldCount: number;
      };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | {
      name: "Execute";
      params: { proposal: PolimecRuntimeRuntimeCall; lengthBound: number };
    }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | {
      name: "Propose";
      params: {
        threshold: number;
        proposal: PolimecRuntimeRuntimeCall;
        lengthBound: number;
      };
    }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    }
  /**
   * Disapprove the proposal and burn the cost held for storing this proposal.
   *
   * Parameters:
   * - `origin`: must be the `KillOrigin`.
   * - `proposal_hash`: The hash of the proposal that should be killed.
   *
   * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
   **/
  | { name: "Kill"; params: { proposalHash: H256 } }
  /**
   * Release the cost held for storing a proposal once the given proposal is completed.
   *
   * If there is no associated cost for the given proposal, this call will have no effect.
   *
   * Parameters:
   * - `origin`: must be `Signed` or `Root`.
   * - `proposal_hash`: The hash of the proposal.
   *
   * Emits `ProposalCostReleased` if any cost held for a given proposal.
   **/
  | { name: "ReleaseProposalCost"; params: { proposalHash: H256 } };

export type PalletCollectiveCallLike =
  /**
   * Set the collective's membership.
   *
   * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
   * - `prime`: The prime member whose vote sets the default.
   * - `old_count`: The upper bound for the previous number of members in storage. Used for
   * weight estimation.
   *
   * The dispatch of this call must be `SetMembersOrigin`.
   *
   * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
   * the weight estimations rely on it to estimate dispatchable weight.
   *
   * # WARNING:
   *
   * The `pallet-collective` can also be managed by logic outside of the pallet through the
   * implementation of the trait [`ChangeMembers`].
   * Any call to `set_members` must be careful that the member set doesn't get out of sync
   * with other logic managing the member set.
   *
   * ## Complexity:
   * - `O(MP + N)` where:
   * - `M` old-members-count (code- and governance-bounded)
   * - `N` new-members-count (code- and governance-bounded)
   * - `P` proposals-count (code-bounded)
   **/
  | {
      name: "SetMembers";
      params: {
        newMembers: Array<AccountId32Like>;
        prime?: AccountId32Like | undefined;
        oldCount: number;
      };
    }
  /**
   * Dispatch a proposal from a member using the `Member` origin.
   *
   * Origin must be a member of the collective.
   *
   * ## Complexity:
   * - `O(B + M + P)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` members-count (code-bounded)
   * - `P` complexity of dispatching `proposal`
   **/
  | {
      name: "Execute";
      params: { proposal: PolimecRuntimeRuntimeCallLike; lengthBound: number };
    }
  /**
   * Add a new proposal to either be voted on or executed directly.
   *
   * Requires the sender to be member.
   *
   * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
   * or put up for voting.
   *
   * ## Complexity
   * - `O(B + M + P1)` or `O(B + M + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - branching is influenced by `threshold` where:
   * - `P1` is proposal execution complexity (`threshold < 2`)
   * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
   **/
  | {
      name: "Propose";
      params: {
        threshold: number;
        proposal: PolimecRuntimeRuntimeCallLike;
        lengthBound: number;
      };
    }
  /**
   * Add an aye or nay vote for the sender to the given proposal.
   *
   * Requires the sender to be a member.
   *
   * Transaction fees will be waived if the member is voting on any particular proposal
   * for the first time and the call is successful. Subsequent vote changes will charge a
   * fee.
   * ## Complexity
   * - `O(M)` where `M` is members-count (code- and governance-bounded)
   **/
  | {
      name: "Vote";
      params: { proposal: H256; index: number; approve: boolean };
    }
  /**
   * Disapprove a proposal, close, and remove it from the system, regardless of its current
   * state.
   *
   * Must be called by the Root origin.
   *
   * Parameters:
   * * `proposal_hash`: The hash of the proposal that should be disapproved.
   *
   * ## Complexity
   * O(P) where P is the number of max proposals
   **/
  | { name: "DisapproveProposal"; params: { proposalHash: H256 } }
  /**
   * Close a vote that is either approved, disapproved or whose voting period has ended.
   *
   * May be called by any signed account in order to finish voting and close the proposal.
   *
   * If called before the end of the voting period it will only close the vote if it is
   * has enough votes to be approved or disapproved.
   *
   * If called after the end of the voting period abstentions are counted as rejections
   * unless there is a prime member set and the prime member cast an approval.
   *
   * If the close operation completes successfully with disapproval, the transaction fee will
   * be waived. Otherwise execution of the approved operation will be charged to the caller.
   *
   * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
   * proposal.
   * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
   * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
   *
   * ## Complexity
   * - `O(B + M + P1 + P2)` where:
   * - `B` is `proposal` size in bytes (length-fee-bounded)
   * - `M` is members-count (code- and governance-bounded)
   * - `P1` is the complexity of `proposal` preimage.
   * - `P2` is proposal-count (code-bounded)
   **/
  | {
      name: "Close";
      params: {
        proposalHash: H256;
        index: number;
        proposalWeightBound: SpWeightsWeightV2Weight;
        lengthBound: number;
      };
    }
  /**
   * Disapprove the proposal and burn the cost held for storing this proposal.
   *
   * Parameters:
   * - `origin`: must be the `KillOrigin`.
   * - `proposal_hash`: The hash of the proposal that should be killed.
   *
   * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
   **/
  | { name: "Kill"; params: { proposalHash: H256 } }
  /**
   * Release the cost held for storing a proposal once the given proposal is completed.
   *
   * If there is no associated cost for the given proposal, this call will have no effect.
   *
   * Parameters:
   * - `origin`: must be `Signed` or `Root`.
   * - `proposal_hash`: The hash of the proposal.
   *
   * Emits `ProposalCostReleased` if any cost held for a given proposal.
   **/
  | { name: "ReleaseProposalCost"; params: { proposalHash: H256 } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletElectionsPhragmenCall =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: "Vote"; params: { votes: Array<AccountId32>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: "RemoveVoter" }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: "SubmitCandidacy"; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | {
      name: "RenounceCandidacy";
      params: { renouncing: PalletElectionsPhragmenRenouncing };
    }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | {
      name: "RemoveMember";
      params: { who: MultiAddress; slashBond: boolean; rerunElection: boolean };
    }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | {
      name: "CleanDefunctVoters";
      params: { numVoters: number; numDefunct: number };
    };

export type PalletElectionsPhragmenCallLike =
  /**
   * Vote for a set of candidates for the upcoming round of election. This can be called to
   * set the initial votes, or update already existing votes.
   *
   * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
   * reserved. The deposit is based on the number of votes and can be updated over time.
   *
   * The `votes` should:
   * - not be empty.
   * - be less than the number of possible candidates. Note that all current members and
   * runners-up are also automatically candidates for the next round.
   *
   * If `value` is more than `who`'s free balance, then the maximum of the two is used.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * It is the responsibility of the caller to **NOT** place all of their balance into the
   * lock and keep some for further operations.
   **/
  | { name: "Vote"; params: { votes: Array<AccountId32Like>; value: bigint } }
  /**
   * Remove `origin` as a voter.
   *
   * This removes the lock and returns the deposit.
   *
   * The dispatch origin of this call must be signed and be a voter.
   **/
  | { name: "RemoveVoter" }
  /**
   * Submit oneself for candidacy. A fixed amount of deposit is recorded.
   *
   * All candidates are wiped at the end of the term. They either become a member/runner-up,
   * or leave the system while their deposit is slashed.
   *
   * The dispatch origin of this call must be signed.
   *
   * ### Warning
   *
   * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
   * to get their deposit back. Losing the spot in an election will always lead to a slash.
   *
   * The number of current candidates must be provided as witness data.
   * ## Complexity
   * O(C + log(C)) where C is candidate_count.
   **/
  | { name: "SubmitCandidacy"; params: { candidateCount: number } }
  /**
   * Renounce one's intention to be a candidate for the next election round. 3 potential
   * outcomes exist:
   *
   * - `origin` is a candidate and not elected in any set. In this case, the deposit is
   * unreserved, returned and origin is removed as a candidate.
   * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
   * origin is removed as a runner-up.
   * - `origin` is a current member. In this case, the deposit is unreserved and origin is
   * removed as a member, consequently not being a candidate for the next round anymore.
   * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
   * are immediately used. If the prime is renouncing, then no prime will exist until the
   * next round.
   *
   * The dispatch origin of this call must be signed, and have one of the above roles.
   * The type of renouncing must be provided as witness data.
   *
   * ## Complexity
   * - Renouncing::Candidate(count): O(count + log(count))
   * - Renouncing::Member: O(1)
   * - Renouncing::RunnerUp: O(1)
   **/
  | {
      name: "RenounceCandidacy";
      params: { renouncing: PalletElectionsPhragmenRenouncing };
    }
  /**
   * Remove a particular member from the set. This is effective immediately and the bond of
   * the outgoing member is slashed.
   *
   * If a runner-up is available, then the best runner-up will be removed and replaces the
   * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
   * started, else, nothing happens.
   *
   * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
   * it is returned.
   *
   * The dispatch origin of this call must be root.
   *
   * Note that this does not affect the designated block number of the next election.
   *
   * ## Complexity
   * - Check details of remove_and_replace_member() and do_phragmen().
   **/
  | {
      name: "RemoveMember";
      params: {
        who: MultiAddressLike;
        slashBond: boolean;
        rerunElection: boolean;
      };
    }
  /**
   * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
   * deposit of the removed voters are returned.
   *
   * This is an root function to be used only for cleaning the state.
   *
   * The dispatch origin of this call must be root.
   *
   * ## Complexity
   * - Check is_defunct_voter() details.
   **/
  | {
      name: "CleanDefunctVoters";
      params: { numVoters: number; numDefunct: number };
    };

export type PalletElectionsPhragmenRenouncing =
  | { type: "Member" }
  | { type: "RunnerUp" }
  | { type: "Candidate"; value: number };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletPreimageCall =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: "NotePreimage"; params: { bytes: Bytes } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

export type PalletPreimageCallLike =
  /**
   * Register a preimage on-chain.
   *
   * If the preimage was previously requested, no fees or deposits are taken for providing
   * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
   **/
  | { name: "NotePreimage"; params: { bytes: BytesLike } }
  /**
   * Clear an unrequested preimage from the runtime storage.
   *
   * If `len` is provided, then it will be a much cheaper operation.
   *
   * - `hash`: The hash of the preimage to be removed from the store.
   * - `len`: The length of the preimage of `hash`.
   **/
  | { name: "UnnotePreimage"; params: { hash: H256 } }
  /**
   * Request a preimage be uploaded to the chain without paying any fees or deposits.
   *
   * If the preimage requests has already been provided on-chain, we unreserve any deposit
   * a user may have paid, and take the control of the preimage out of their hands.
   **/
  | { name: "RequestPreimage"; params: { hash: H256 } }
  /**
   * Clear a previously made request for a preimage.
   *
   * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
   **/
  | { name: "UnrequestPreimage"; params: { hash: H256 } }
  /**
   * Ensure that the a bulk of pre-images is upgraded.
   *
   * The caller pays no fee if at least 90% of pre-images were successfully updated.
   **/
  | { name: "EnsureUpdated"; params: { hashes: Array<H256> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletSchedulerCall =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCall;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetry";
      params: { task: [number, number]; retries: number; period: number };
    }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetryNamed";
      params: { id: FixedBytes<32>; retries: number; period: number };
    }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: "CancelRetry"; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: "CancelRetryNamed"; params: { id: FixedBytes<32> } };

export type PalletSchedulerCallLike =
  /**
   * Anonymously schedule a task.
   **/
  | {
      name: "Schedule";
      params: {
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel an anonymously scheduled task.
   **/
  | { name: "Cancel"; params: { when: number; index: number } }
  /**
   * Schedule a named task.
   **/
  | {
      name: "ScheduleNamed";
      params: {
        id: FixedBytes<32>;
        when: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Cancel a named scheduled task.
   **/
  | { name: "CancelNamed"; params: { id: FixedBytes<32> } }
  /**
   * Anonymously schedule a task after a delay.
   **/
  | {
      name: "ScheduleAfter";
      params: {
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Schedule a named task after a delay.
   **/
  | {
      name: "ScheduleNamedAfter";
      params: {
        id: FixedBytes<32>;
        after: number;
        maybePeriodic?: [number, number] | undefined;
        priority: number;
        call: PolimecRuntimeRuntimeCallLike;
      };
    }
  /**
   * Set a retry configuration for a task so that, in case its scheduled run fails, it will
   * be retried after `period` blocks, for a total amount of `retries` retries or until it
   * succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetry";
      params: { task: [number, number]; retries: number; period: number };
    }
  /**
   * Set a retry configuration for a named task so that, in case its scheduled run fails, it
   * will be retried after `period` blocks, for a total amount of `retries` retries or until
   * it succeeds.
   *
   * Tasks which need to be scheduled for a retry are still subject to weight metering and
   * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
   * normally while the task is retrying.
   *
   * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
   * clones of the original task. Their retry configuration will be derived from the
   * original task's configuration, but will have a lower value for `remaining` than the
   * original `total_retries`.
   **/
  | {
      name: "SetRetryNamed";
      params: { id: FixedBytes<32>; retries: number; period: number };
    }
  /**
   * Removes the retry configuration of a task.
   **/
  | { name: "CancelRetry"; params: { task: [number, number] } }
  /**
   * Cancel the retry configuration of a named task.
   **/
  | { name: "CancelRetryNamed"; params: { id: FixedBytes<32> } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type OrmlOracleModuleCall =
  /**
   * Feed the external value.
   *
   * Require authorized operator.
   **/
  {
    name: "FeedValues";
    params: { values: Array<[StagingXcmV4Location, FixedU128]> };
  };

export type OrmlOracleModuleCallLike =
  /**
   * Feed the external value.
   *
   * Require authorized operator.
   **/
  {
    name: "FeedValues";
    params: { values: Array<[StagingXcmV4Location, FixedU128]> };
  };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletMembershipCall =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: "AddMember"; params: { who: MultiAddress } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: "RemoveMember"; params: { who: MultiAddress } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | { name: "SwapMember"; params: { remove: MultiAddress; add: MultiAddress } }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: "ResetMembers"; params: { members: Array<AccountId32> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: "ChangeKey"; params: { new: MultiAddress } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "SetPrime"; params: { who: MultiAddress } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "ClearPrime" };

export type PalletMembershipCallLike =
  /**
   * Add a member `who` to the set.
   *
   * May only be called from `T::AddOrigin`.
   **/
  | { name: "AddMember"; params: { who: MultiAddressLike } }
  /**
   * Remove a member `who` from the set.
   *
   * May only be called from `T::RemoveOrigin`.
   **/
  | { name: "RemoveMember"; params: { who: MultiAddressLike } }
  /**
   * Swap out one member `remove` for another `add`.
   *
   * May only be called from `T::SwapOrigin`.
   *
   * Prime membership is *not* passed from `remove` to `add`, if extant.
   **/
  | {
      name: "SwapMember";
      params: { remove: MultiAddressLike; add: MultiAddressLike };
    }
  /**
   * Change the membership to a new set, disregarding the existing membership. Be nice and
   * pass `members` pre-sorted.
   *
   * May only be called from `T::ResetOrigin`.
   **/
  | { name: "ResetMembers"; params: { members: Array<AccountId32Like> } }
  /**
   * Swap out the sending member for some other key `new`.
   *
   * May only be called from `Signed` origin of a current member.
   *
   * Prime membership is passed from the origin account to `new`, if extant.
   **/
  | { name: "ChangeKey"; params: { new: MultiAddressLike } }
  /**
   * Set the prime member. Must be a current member.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "SetPrime"; params: { who: MultiAddressLike } }
  /**
   * Remove the prime member if it exists.
   *
   * May only be called from `T::PrimeOrigin`.
   **/
  | { name: "ClearPrime" };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletFundingCall =
  /**
   * Creates a project and assigns it to the `issuer` account.
   **/
  | {
      name: "CreateProject";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        project: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * Removes a project that hasn't started the evaluation round yet
   **/
  | {
      name: "RemoveProject";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  /**
   * Change the metadata of a project
   **/
  | {
      name: "EditProject";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        newProjectMetadata: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * Starts the evaluation round of a project.
   **/
  | {
      name: "StartEvaluation";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  /**
   * Bond PLMC for a project in the evaluation stage
   **/
  | {
      name: "Evaluate";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        usdAmount: bigint;
      };
    }
  | {
      name: "EvaluateWithReceivingAccount";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        usdAmount: bigint;
        receivingAccount: StagingXcmV4Junction;
        signatureBytes: FixedBytes<65>;
      };
    }
  | { name: "EndEvaluation"; params: { projectId: number } }
  /**
   * Bid for a project in the Auction round
   **/
  | {
      name: "Bid";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        ctAmount: bigint;
        mode: PalletFundingInnerParticipationMode;
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
      };
    }
  | {
      name: "BidWithReceivingAccount";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        ctAmount: bigint;
        mode: PalletFundingInnerParticipationMode;
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
        receivingAccount: StagingXcmV4Junction;
        signatureBytes: FixedBytes<65>;
      };
    }
  | { name: "ProcessNextOversubscribedBid"; params: { projectId: number } }
  | { name: "EndFunding"; params: { projectId: number } }
  | { name: "StartSettlement"; params: { projectId: number } }
  | {
      name: "SettleEvaluation";
      params: {
        projectId: number;
        evaluator: AccountId32;
        evaluationId: number;
      };
    }
  | { name: "SettleBid"; params: { projectId: number; bidId: number } }
  | { name: "MarkProjectAsSettled"; params: { projectId: number } }
  | {
      name: "StartOffchainMigration";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  | {
      name: "ConfirmOffchainMigration";
      params: { projectId: number; participant: AccountId32 };
    }
  | { name: "MarkProjectCtMigrationAsFinished"; params: { projectId: number } };

export type PalletFundingCallLike =
  /**
   * Creates a project and assigns it to the `issuer` account.
   **/
  | {
      name: "CreateProject";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        project: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * Removes a project that hasn't started the evaluation round yet
   **/
  | {
      name: "RemoveProject";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  /**
   * Change the metadata of a project
   **/
  | {
      name: "EditProject";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        newProjectMetadata: PalletFundingStorageProjectMetadata;
      };
    }
  /**
   * Starts the evaluation round of a project.
   **/
  | {
      name: "StartEvaluation";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  /**
   * Bond PLMC for a project in the evaluation stage
   **/
  | {
      name: "Evaluate";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        usdAmount: bigint;
      };
    }
  | {
      name: "EvaluateWithReceivingAccount";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        usdAmount: bigint;
        receivingAccount: StagingXcmV4Junction;
        signatureBytes: FixedBytes<65>;
      };
    }
  | { name: "EndEvaluation"; params: { projectId: number } }
  /**
   * Bid for a project in the Auction round
   **/
  | {
      name: "Bid";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        ctAmount: bigint;
        mode: PalletFundingInnerParticipationMode;
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
      };
    }
  | {
      name: "BidWithReceivingAccount";
      params: {
        jwt: JwtCompactFrameTokenUntrustedToken;
        projectId: number;
        ctAmount: bigint;
        mode: PalletFundingInnerParticipationMode;
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
        receivingAccount: StagingXcmV4Junction;
        signatureBytes: FixedBytes<65>;
      };
    }
  | { name: "ProcessNextOversubscribedBid"; params: { projectId: number } }
  | { name: "EndFunding"; params: { projectId: number } }
  | { name: "StartSettlement"; params: { projectId: number } }
  | {
      name: "SettleEvaluation";
      params: {
        projectId: number;
        evaluator: AccountId32Like;
        evaluationId: number;
      };
    }
  | { name: "SettleBid"; params: { projectId: number; bidId: number } }
  | { name: "MarkProjectAsSettled"; params: { projectId: number } }
  | {
      name: "StartOffchainMigration";
      params: { jwt: JwtCompactFrameTokenUntrustedToken; projectId: number };
    }
  | {
      name: "ConfirmOffchainMigration";
      params: { projectId: number; participant: AccountId32Like };
    }
  | { name: "MarkProjectCtMigrationAsFinished"; params: { projectId: number } };

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletLinearReleaseCall =
  /**
   * Unlock any vested funds of the sender account, for the given `reason`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "Vest"; params: { reason: PolimecRuntimeRuntimeHoldReason } }
  /**
   * Unlock any vested funds of a `target` account, for the given `reason`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestOther";
      params: { target: AccountId32; reason: PolimecRuntimeRuntimeHoldReason };
    }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestedTransfer";
      params: {
        target: AccountId32;
        schedule: PalletLinearReleaseVestingInfo;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "ForceVestedTransfer";
      params: {
        source: AccountId32;
        target: AccountId32;
        schedule: PalletLinearReleaseVestingInfo;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | {
      name: "MergeSchedules";
      params: {
        schedule1Index: number;
        schedule2Index: number;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestAll" }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestAllOther"; params: { target: AccountId32 } };

export type PalletLinearReleaseCallLike =
  /**
   * Unlock any vested funds of the sender account, for the given `reason`.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "Vest"; params: { reason: PolimecRuntimeRuntimeHoldReason } }
  /**
   * Unlock any vested funds of a `target` account, for the given `reason`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestOther";
      params: {
        target: AccountId32Like;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Create a vested transfer.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account receiving the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "VestedTransfer";
      params: {
        target: AccountId32Like;
        schedule: PalletLinearReleaseVestingInfo;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Force a vested transfer.
   *
   * The dispatch origin for this call must be _Root_.
   *
   * - `source`: The account whose funds should be transferred.
   * - `target`: The account that should be transferred the vested funds.
   * - `schedule`: The vesting schedule attached to the transfer.
   *
   * Emits `VestingCreated`.
   *
   * NOTE: This will unlock all schedules through the current block.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | {
      name: "ForceVestedTransfer";
      params: {
        source: AccountId32Like;
        target: AccountId32Like;
        schedule: PalletLinearReleaseVestingInfo;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
   * the highest possible start and end blocks. If both schedules have already started the
   * current block will be used as the schedule start; with the caveat that if one schedule
   * is finished by the current block, the other will be treated as the new merged schedule,
   * unmodified.
   *
   * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
   * NOTE: This will unlock all schedules through the current block prior to merging.
   * NOTE: If both schedules have ended by the current block, no new schedule will be created
   * and both will be removed.
   *
   * Merged schedule attributes:
   * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
   * current_block)`.
   * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
   * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `schedule1_index`: index of the first schedule to merge.
   * - `schedule2_index`: index of the second schedule to merge.
   **/
  | {
      name: "MergeSchedules";
      params: {
        schedule1Index: number;
        schedule2Index: number;
        reason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  /**
   * Unlock any vested funds of the sender account.
   *
   * The dispatch origin for this call must be _Signed_ and the sender must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestAll" }
  /**
   * Unlock any vested funds of a `target` account.
   *
   * The dispatch origin for this call must be _Signed_.
   *
   * - `target`: The account whose vested funds should be unlocked. Must have funds still
   * locked under this pallet.
   *
   * Emits either `VestingCompleted` or `VestingUpdated`.
   *
   * ## Complexity
   * - `O(1)`.
   **/
  | { name: "VestAllOther"; params: { target: AccountId32Like } };

export type PolimecRuntimeRuntimeHoldReason =
  | { type: "ParachainStaking"; value: PalletParachainStakingHoldReason }
  | { type: "Democracy"; value: PalletDemocracyHoldReason }
  | { type: "Council"; value: PalletCollectiveHoldReason }
  | { type: "TechnicalCommittee"; value: PalletCollectiveHoldReason }
  | { type: "Elections"; value: PalletElectionsPhragmenHoldReason }
  | { type: "Preimage"; value: PalletPreimageHoldReason }
  | { type: "Funding"; value: PalletFundingHoldReason };

export type PalletParachainStakingHoldReason =
  | "StakingCollator"
  | "StakingDelegator";

export type PalletDemocracyHoldReason = "Proposal";

export type PalletCollectiveHoldReason = "ProposalSubmission";

export type PalletElectionsPhragmenHoldReason = "Candidacy";

export type PalletPreimageHoldReason = "Preimage";

export type PalletFundingHoldReason = "Evaluation" | "Participation";

export type PalletLinearReleaseVestingInfo = {
  locked: bigint;
  perBlock: bigint;
  startingBlock: number;
};

/**
 * Contains a variant per dispatchable extrinsic that this pallet has.
 **/
export type PalletProxyBondingCall =
  /**
   * If sub-account has all the tokens unbonded, it will transfer everything including ED back to the treasury
   **/
  | {
      name: "TransferBondsBackToTreasury";
      params: {
        derivationPath: number;
        holdReason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  | {
      name: "TransferFeesToRecipient";
      params: {
        derivationPath: number;
        holdReason: PolimecRuntimeRuntimeHoldReason;
        feeAsset: StagingXcmV4Location;
      };
    };

export type PalletProxyBondingCallLike =
  /**
   * If sub-account has all the tokens unbonded, it will transfer everything including ED back to the treasury
   **/
  | {
      name: "TransferBondsBackToTreasury";
      params: {
        derivationPath: number;
        holdReason: PolimecRuntimeRuntimeHoldReason;
      };
    }
  | {
      name: "TransferFeesToRecipient";
      params: {
        derivationPath: number;
        holdReason: PolimecRuntimeRuntimeHoldReason;
        feeAsset: StagingXcmV4Location;
      };
    };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletUtilityError =
  /**
   * Too many calls batched.
   **/
  "TooManyCalls";

export type PalletMultisigMultisig = {
  when: PalletMultisigTimepoint;
  deposit: bigint;
  depositor: AccountId32;
  approvals: Array<AccountId32>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMultisigError =
  /**
   * Threshold must be 2 or greater.
   **/
  | "MinimumThreshold"
  /**
   * Call is already approved by this signatory.
   **/
  | "AlreadyApproved"
  /**
   * Call doesn't need any (more) approvals.
   **/
  | "NoApprovalsNeeded"
  /**
   * There are too few signatories in the list.
   **/
  | "TooFewSignatories"
  /**
   * There are too many signatories in the list.
   **/
  | "TooManySignatories"
  /**
   * The signatories were provided out of order; they should be ordered.
   **/
  | "SignatoriesOutOfOrder"
  /**
   * The sender was contained in the other signatories; it shouldn't be.
   **/
  | "SenderInSignatories"
  /**
   * Multisig operation not found when attempting to cancel.
   **/
  | "NotFound"
  /**
   * Only the account that originally created the multisig is able to cancel it.
   **/
  | "NotOwner"
  /**
   * No timepoint was given, yet the multisig operation is already underway.
   **/
  | "NoTimepoint"
  /**
   * A different timepoint was given to the multisig operation that is underway.
   **/
  | "WrongTimepoint"
  /**
   * A timepoint was given, yet no multisig operation is underway.
   **/
  | "UnexpectedTimepoint"
  /**
   * The maximum weight information provided was too low.
   **/
  | "MaxWeightTooLow"
  /**
   * The data to be stored is already stored.
   **/
  | "AlreadyStored";

export type PalletProxyProxyDefinition = {
  delegate: AccountId32;
  proxyType: SharedConfigurationProxyType;
  delay: number;
};

export type PalletProxyAnnouncement = {
  real: AccountId32;
  callHash: H256;
  height: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyError =
  /**
   * There are too many proxies registered or too many announcements pending.
   **/
  | "TooMany"
  /**
   * Proxy registration not found.
   **/
  | "NotFound"
  /**
   * Sender is not a proxy of the account to be proxied.
   **/
  | "NotProxy"
  /**
   * A call which is incompatible with the proxy type's filter was attempted.
   **/
  | "Unproxyable"
  /**
   * Account is already a proxy.
   **/
  | "Duplicate"
  /**
   * Call may not be made by proxy because it may escalate its privileges.
   **/
  | "NoPermission"
  /**
   * Announcement, if made at all, was made too recently.
   **/
  | "Unannounced"
  /**
   * Cannot add self as proxy.
   **/
  | "NoSelfProxy";

export type PalletBalancesBalanceLock = {
  id: FixedBytes<8>;
  amount: bigint;
  reasons: PalletBalancesReasons;
};

export type PalletBalancesReasons = "Fee" | "Misc" | "All";

export type PalletBalancesReserveData = { id: FixedBytes<8>; amount: bigint };

export type FrameSupportTokensMiscIdAmount = {
  id: PolimecRuntimeRuntimeHoldReason;
  amount: bigint;
};

export type FrameSupportTokensMiscIdAmountRuntimeFreezeReason = {
  id: PolimecRuntimeRuntimeFreezeReason;
  amount: bigint;
};

export type PolimecRuntimeRuntimeFreezeReason =
  | { type: "Democracy"; value: PalletDemocracyFreezeReason }
  | { type: "Elections"; value: PalletElectionsPhragmenFreezeReason };

export type PalletDemocracyFreezeReason = "Vote";

export type PalletElectionsPhragmenFreezeReason = "Voting";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletBalancesError =
  /**
   * Vesting balance too high to send value.
   **/
  | "VestingBalance"
  /**
   * Account liquidity restrictions prevent withdrawal.
   **/
  | "LiquidityRestrictions"
  /**
   * Balance too low to send value.
   **/
  | "InsufficientBalance"
  /**
   * Value too low to create account due to existential deposit.
   **/
  | "ExistentialDeposit"
  /**
   * Transfer/payment would kill account.
   **/
  | "Expendability"
  /**
   * A vesting schedule already exists for this account.
   **/
  | "ExistingVestingSchedule"
  /**
   * Beneficiary account must pre-exist.
   **/
  | "DeadAccount"
  /**
   * Number of named reserves exceed `MaxReserves`.
   **/
  | "TooManyReserves"
  /**
   * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
   **/
  | "TooManyHolds"
  /**
   * Number of freezes exceed `MaxFreezes`.
   **/
  | "TooManyFreezes"
  /**
   * The issuance cannot be modified since it is already deactivated.
   **/
  | "IssuanceDeactivated"
  /**
   * The delta cannot be zero.
   **/
  | "DeltaZero";

export type PalletTransactionPaymentReleases = "V1Ancient" | "V2";

export type PalletVestingReleases = "V0" | "V1";

/**
 * Error for the vesting pallet.
 **/
export type PalletVestingError =
  /**
   * The account given is not vesting.
   **/
  | "NotVesting"
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | "AtMaxVestingSchedules"
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | "AmountLow"
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | "ScheduleIndexOutOfBounds"
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | "InvalidScheduleParams";

export type PalletAssetsAssetDetails = {
  owner: AccountId32;
  issuer: AccountId32;
  admin: AccountId32;
  freezer: AccountId32;
  supply: bigint;
  deposit: bigint;
  minBalance: bigint;
  isSufficient: boolean;
  accounts: number;
  sufficients: number;
  approvals: number;
  status: PalletAssetsAssetStatus;
};

export type PalletAssetsAssetStatus = "Live" | "Frozen" | "Destroying";

export type PalletAssetsAssetAccount = {
  balance: bigint;
  status: PalletAssetsAccountStatus;
  reason: PalletAssetsExistenceReason;
  extra: [];
};

export type PalletAssetsAccountStatus = "Liquid" | "Frozen" | "Blocked";

export type PalletAssetsExistenceReason =
  | { type: "Consumer" }
  | { type: "Sufficient" }
  | { type: "DepositHeld"; value: bigint }
  | { type: "DepositRefunded" }
  | { type: "DepositFrom"; value: [AccountId32, bigint] };

export type PalletAssetsApproval = { amount: bigint; deposit: bigint };

export type PalletAssetsAssetMetadata = {
  deposit: bigint;
  name: Bytes;
  symbol: Bytes;
  decimals: number;
  isFrozen: boolean;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletAssetsError =
  /**
   * Account balance must be greater than or equal to the transfer amount.
   **/
  | "BalanceLow"
  /**
   * The account to alter does not exist.
   **/
  | "NoAccount"
  /**
   * The signing account has no permission to do the operation.
   **/
  | "NoPermission"
  /**
   * The given asset ID is unknown.
   **/
  | "Unknown"
  /**
   * The origin account is frozen.
   **/
  | "Frozen"
  /**
   * The asset ID is already taken.
   **/
  | "InUse"
  /**
   * Invalid witness data given.
   **/
  | "BadWitness"
  /**
   * Minimum balance should be non-zero.
   **/
  | "MinBalanceZero"
  /**
   * Unable to increment the consumer reference counters on the account. Either no provider
   * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
   * fewer then the maximum number of consumers has been reached.
   **/
  | "UnavailableConsumer"
  /**
   * Invalid metadata given.
   **/
  | "BadMetadata"
  /**
   * No approval exists that would allow the transfer.
   **/
  | "Unapproved"
  /**
   * The source account would not survive the transfer and it needs to stay alive.
   **/
  | "WouldDie"
  /**
   * The asset-account already exists.
   **/
  | "AlreadyExists"
  /**
   * The asset-account doesn't have an associated deposit.
   **/
  | "NoDeposit"
  /**
   * The operation would result in funds being burned.
   **/
  | "WouldBurn"
  /**
   * The asset is a live asset and is actively being used. Usually emit for operations such
   * as `start_destroy` which require the asset to be in a destroying state.
   **/
  | "LiveAsset"
  /**
   * The asset is not live, and likely being destroyed.
   **/
  | "AssetNotLive"
  /**
   * The asset status is not the expected status.
   **/
  | "IncorrectStatus"
  /**
   * The asset should be frozen before the given operation.
   **/
  | "NotFrozen"
  /**
   * Callback action resulted in error
   **/
  | "CallbackFailed"
  /**
   * The asset ID must be equal to the [`NextAssetId`].
   **/
  | "BadAssetId";

export type FrameSupportPalletId = FixedBytes<8>;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDispenserError =
  /**
   * The dispenser has already dispensed to the DID.
   **/
  | "DispensedAlreadyToDid"
  /**
   * The dispenser account does not have any funds to distribute.
   **/
  | "DispenserDepleted"
  /**
   * The dispense amount is too low. It must be greater than the free dispense amount.
   **/
  | "DispenseAmountTooLow"
  /**
   * The origin does not have the required credentials.
   **/
  | "InvalidCredential";

export type SpCoreCryptoKeyTypeId = FixedBytes<4>;

/**
 * Error for the session pallet.
 **/
export type PalletSessionError =
  /**
   * Invalid ownership proof.
   **/
  | "InvalidProof"
  /**
   * No associated validator ID for account.
   **/
  | "NoAssociatedValidatorId"
  /**
   * Registered duplicate key.
   **/
  | "DuplicatedKey"
  /**
   * No keys are associated with this account.
   **/
  | "NoKeys"
  /**
   * Key setting account is not live, so it's impossible to associate keys.
   **/
  | "NoAccount";

export type SpConsensusSlotsSlot = bigint;

export type PalletParachainStakingParachainBondConfig = {
  account: AccountId32;
  percent: Percent;
};

export type PalletParachainStakingRoundInfo = {
  current: number;
  first: number;
  length: number;
};

export type PalletParachainStakingDelegator = {
  id: AccountId32;
  delegations: PalletParachainStakingSetOrderedSet;
  total: bigint;
  lessTotal: bigint;
  status: PalletParachainStakingDelegatorStatus;
};

export type PalletParachainStakingSetOrderedSet =
  Array<PalletParachainStakingBond>;

export type PalletParachainStakingBond = { owner: AccountId32; amount: bigint };

export type PalletParachainStakingDelegatorStatus =
  | { type: "Active" }
  | { type: "Leaving"; value: number };

export type PalletParachainStakingCandidateMetadata = {
  bond: bigint;
  delegationCount: number;
  totalCounted: bigint;
  lowestTopDelegationAmount: bigint;
  highestBottomDelegationAmount: bigint;
  lowestBottomDelegationAmount: bigint;
  topCapacity: PalletParachainStakingCapacityStatus;
  bottomCapacity: PalletParachainStakingCapacityStatus;
  request?: PalletParachainStakingCandidateBondLessRequest | undefined;
  status: PalletParachainStakingCollatorStatus;
};

export type PalletParachainStakingCapacityStatus = "Full" | "Empty" | "Partial";

export type PalletParachainStakingCandidateBondLessRequest = {
  amount: bigint;
  whenExecutable: number;
};

export type PalletParachainStakingCollatorStatus =
  | { type: "Active" }
  | { type: "Idle" }
  | { type: "Leaving"; value: number };

export type PalletParachainStakingDelegationRequestsScheduledRequest = {
  delegator: AccountId32;
  whenExecutable: number;
  action: PalletParachainStakingDelegationRequestsDelegationAction;
};

export type PalletParachainStakingAutoCompoundAutoCompoundConfig = {
  delegator: AccountId32;
  value: Percent;
};

export type PalletParachainStakingDelegations = {
  delegations: Array<PalletParachainStakingBond>;
  total: bigint;
};

export type PalletParachainStakingCollatorSnapshot = {
  bond: bigint;
  delegations: Array<PalletParachainStakingBondWithAutoCompound>;
  total: bigint;
};

export type PalletParachainStakingBondWithAutoCompound = {
  owner: AccountId32;
  amount: bigint;
  autoCompound: Percent;
};

export type PalletParachainStakingDelayedPayout = {
  roundIssuance: bigint;
  totalStakingReward: bigint;
  collatorCommission: Perbill;
};

export type PalletParachainStakingInflationInflationInfo = {
  expect: { min: bigint; ideal: bigint; max: bigint };
  annual: { min: Perbill; ideal: Perbill; max: Perbill };
  round: { min: Perbill; ideal: Perbill; max: Perbill };
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletParachainStakingError =
  | "DelegatorDNE"
  | "DelegatorDNEinTopNorBottom"
  | "DelegatorDNEInDelegatorSet"
  | "CandidateDNE"
  | "DelegationDNE"
  | "DelegatorExists"
  | "CandidateExists"
  | "CandidateBondBelowMin"
  | "InsufficientBalance"
  | "DelegatorBondBelowMin"
  | "DelegationBelowMin"
  | "AlreadyOffline"
  | "AlreadyActive"
  | "DelegatorAlreadyLeaving"
  | "DelegatorNotLeaving"
  | "DelegatorCannotLeaveYet"
  | "CannotDelegateIfLeaving"
  | "CandidateAlreadyLeaving"
  | "CandidateNotLeaving"
  | "CandidateCannotLeaveYet"
  | "CannotGoOnlineIfLeaving"
  | "ExceedMaxDelegationsPerDelegator"
  | "AlreadyDelegatedCandidate"
  | "InvalidSchedule"
  | "CannotSetBelowMin"
  | "RoundLengthMustBeGreaterThanTotalSelectedCollators"
  | "NoWritingSameValue"
  | "TooLowCandidateCountWeightHintJoinCandidates"
  | "TooLowCandidateCountWeightHintCancelLeaveCandidates"
  | "TooLowCandidateCountToLeaveCandidates"
  | "TooLowDelegationCountToDelegate"
  | "TooLowCandidateDelegationCountToDelegate"
  | "TooLowCandidateDelegationCountToLeaveCandidates"
  | "TooLowDelegationCountToLeaveDelegators"
  | "PendingCandidateRequestsDNE"
  | "PendingCandidateRequestAlreadyExists"
  | "PendingCandidateRequestNotDueYet"
  | "PendingDelegationRequestDNE"
  | "PendingDelegationRequestAlreadyExists"
  | "PendingDelegationRequestNotDueYet"
  | "CannotDelegateLessThanOrEqualToLowestBottomWhenFull"
  | "PendingDelegationRevoke"
  | "TooLowDelegationCountToAutoCompound"
  | "TooLowCandidateAutoCompoundingDelegationCountToAutoCompound"
  | "TooLowCandidateAutoCompoundingDelegationCountToDelegate";

export type CumulusPalletXcmpQueueOutboundChannelDetails = {
  recipient: PolkadotParachainPrimitivesPrimitivesId;
  state: CumulusPalletXcmpQueueOutboundState;
  signalsExist: boolean;
  firstIndex: number;
  lastIndex: number;
};

export type CumulusPalletXcmpQueueOutboundState = "Ok" | "Suspended";

export type CumulusPalletXcmpQueueQueueConfigData = {
  suspendThreshold: number;
  dropThreshold: number;
  resumeThreshold: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type CumulusPalletXcmpQueueError =
  /**
   * Setting the queue config failed since one of its values was invalid.
   **/
  | "BadQueueConfig"
  /**
   * The execution is already suspended.
   **/
  | "AlreadySuspended"
  /**
   * The execution is already resumed.
   **/
  | "AlreadyResumed"
  /**
   * There are too many active outbound channels.
   **/
  | "TooManyActiveOutboundChannels"
  /**
   * The message is too big.
   **/
  | "TooBig";

export type PalletXcmQueryStatus =
  | {
      type: "Pending";
      value: {
        responder: XcmVersionedLocation;
        maybeMatchQuerier?: XcmVersionedLocation | undefined;
        maybeNotify?: [number, number] | undefined;
        timeout: number;
      };
    }
  | {
      type: "VersionNotifier";
      value: { origin: XcmVersionedLocation; isActive: boolean };
    }
  | { type: "Ready"; value: { response: XcmVersionedResponse; at: number } };

export type XcmVersionedResponse =
  | { type: "V3"; value: XcmV3Response }
  | { type: "V4"; value: StagingXcmV4Response }
  | { type: "V5"; value: StagingXcmV5Response };

export type PalletXcmVersionMigrationStage =
  | { type: "MigrateSupportedVersion" }
  | { type: "MigrateVersionNotifiers" }
  | { type: "NotifyCurrentTargets"; value?: Bytes | undefined }
  | { type: "MigrateAndNotifyOldTargets" };

export type PalletXcmRemoteLockedFungibleRecord = {
  amount: bigint;
  owner: XcmVersionedLocation;
  locker: XcmVersionedLocation;
  consumers: Array<[[], bigint]>;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletXcmError =
  /**
   * The desired destination was unreachable, generally because there is a no way of routing
   * to it.
   **/
  | "Unreachable"
  /**
   * There was some other issue (i.e. not to do with routing) in sending the message.
   * Perhaps a lack of space for buffering the message.
   **/
  | "SendFailure"
  /**
   * The message execution fails the filter.
   **/
  | "Filtered"
  /**
   * The message's weight could not be determined.
   **/
  | "UnweighableMessage"
  /**
   * The destination `Location` provided cannot be inverted.
   **/
  | "DestinationNotInvertible"
  /**
   * The assets to be sent are empty.
   **/
  | "Empty"
  /**
   * Could not re-anchor the assets to declare the fees for the destination chain.
   **/
  | "CannotReanchor"
  /**
   * Too many assets have been attempted for transfer.
   **/
  | "TooManyAssets"
  /**
   * Origin is invalid for sending.
   **/
  | "InvalidOrigin"
  /**
   * The version of the `Versioned` value used is not able to be interpreted.
   **/
  | "BadVersion"
  /**
   * The given location could not be used (e.g. because it cannot be expressed in the
   * desired version of XCM).
   **/
  | "BadLocation"
  /**
   * The referenced subscription could not be found.
   **/
  | "NoSubscription"
  /**
   * The location is invalid since it already has a subscription from us.
   **/
  | "AlreadySubscribed"
  /**
   * Could not check-out the assets for teleportation to the destination chain.
   **/
  | "CannotCheckOutTeleport"
  /**
   * The owner does not own (all) of the asset that they wish to do the operation on.
   **/
  | "LowBalance"
  /**
   * The asset owner has too many locks on the asset.
   **/
  | "TooManyLocks"
  /**
   * The given account is not an identifiable sovereign account for any location.
   **/
  | "AccountNotSovereign"
  /**
   * The operation required fees to be paid which the initiator could not meet.
   **/
  | "FeesNotMet"
  /**
   * A remote lock with the corresponding data could not be found.
   **/
  | "LockNotFound"
  /**
   * The unlock operation cannot succeed because there are still consumers of the lock.
   **/
  | "InUse"
  /**
   * Invalid asset, reserve chain could not be determined for it.
   **/
  | "InvalidAssetUnknownReserve"
  /**
   * Invalid asset, do not support remote asset reserves with different fees reserves.
   **/
  | "InvalidAssetUnsupportedReserve"
  /**
   * Too many assets with different reserve locations have been attempted for transfer.
   **/
  | "TooManyReserves"
  /**
   * Local XCM execution incomplete.
   **/
  | "LocalExecutionIncomplete";

export type PalletMessageQueueBookState = {
  begin: number;
  end: number;
  count: number;
  readyNeighbours?: PalletMessageQueueNeighbours | undefined;
  messageCount: bigint;
  size: bigint;
};

export type PalletMessageQueueNeighbours = {
  prev: CumulusPrimitivesCoreAggregateMessageOrigin;
  next: CumulusPrimitivesCoreAggregateMessageOrigin;
};

export type PalletMessageQueuePage = {
  remaining: number;
  remainingSize: number;
  firstIndex: number;
  first: number;
  last: number;
  heap: Bytes;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMessageQueueError =
  /**
   * Page is not reapable because it has items remaining to be processed and is not old
   * enough.
   **/
  | "NotReapable"
  /**
   * Page to be reaped does not exist.
   **/
  | "NoPage"
  /**
   * The referenced message could not be found.
   **/
  | "NoMessage"
  /**
   * The message was already processed and cannot be processed again.
   **/
  | "AlreadyProcessed"
  /**
   * The message is queued for future execution.
   **/
  | "Queued"
  /**
   * There is temporarily not enough weight to continue servicing messages.
   **/
  | "InsufficientWeight"
  /**
   * This message is temporarily unprocessable.
   *
   * Such errors are expected, but not guaranteed, to resolve themselves eventually through
   * retrying.
   **/
  | "TemporarilyUnprocessable"
  /**
   * The queue is paused and no message can be executed from it.
   *
   * This can change at any time and may resolve in the future by re-trying.
   **/
  | "QueuePaused"
  /**
   * Another call is in progress and needs to finish before this call can happen.
   **/
  | "RecursiveDisallowed";

export type PalletTreasuryProposal = {
  proposer: AccountId32;
  value: bigint;
  beneficiary: AccountId32;
  bond: bigint;
};

export type PalletTreasurySpendStatus = {
  assetKind: [];
  amount: bigint;
  beneficiary: AccountId32;
  validFrom: number;
  expireAt: number;
  status: PalletTreasuryPaymentState;
};

export type PalletTreasuryPaymentState =
  | { type: "Pending" }
  | { type: "Attempted"; value: { id: [] } }
  | { type: "Failed" };

/**
 * Error for the treasury pallet.
 **/
export type PalletTreasuryError =
  /**
   * No proposal, bounty or spend at that index.
   **/
  | "InvalidIndex"
  /**
   * Too many approvals in the queue.
   **/
  | "TooManyApprovals"
  /**
   * The spend origin is valid but the amount it is allowed to spend is lower than the
   * amount to be spent.
   **/
  | "InsufficientPermission"
  /**
   * Proposal has not been approved.
   **/
  | "ProposalNotApproved"
  /**
   * The balance of the asset kind is not convertible to the balance of the native asset.
   **/
  | "FailedToConvertBalance"
  /**
   * The spend has expired and cannot be claimed.
   **/
  | "SpendExpired"
  /**
   * The spend is not yet eligible for payout.
   **/
  | "EarlyPayout"
  /**
   * The payment has already been attempted.
   **/
  | "AlreadyAttempted"
  /**
   * There was some issue with the mechanism of payment.
   **/
  | "PayoutError"
  /**
   * The payout was not yet attempted/claimed.
   **/
  | "NotAttempted"
  /**
   * The payment has neither failed nor succeeded yet.
   **/
  | "Inconclusive";

export type PalletDemocracyReferendumInfo =
  | { type: "Ongoing"; value: PalletDemocracyReferendumStatus }
  | { type: "Finished"; value: { approved: boolean; end: number } };

export type PalletDemocracyReferendumStatus = {
  end: number;
  proposal: FrameSupportPreimagesBounded;
  threshold: PalletDemocracyVoteThreshold;
  delay: number;
  tally: PalletDemocracyTally;
};

export type PalletDemocracyTally = {
  ayes: bigint;
  nays: bigint;
  turnout: bigint;
};

export type PalletDemocracyVoteVoting =
  | {
      type: "Direct";
      value: {
        votes: Array<[number, PalletDemocracyVoteAccountVote]>;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    }
  | {
      type: "Delegating";
      value: {
        balance: bigint;
        target: AccountId32;
        conviction: PalletDemocracyConviction;
        delegations: PalletDemocracyDelegations;
        prior: PalletDemocracyVotePriorLock;
      };
    };

export type PalletDemocracyDelegations = { votes: bigint; capital: bigint };

export type PalletDemocracyVotePriorLock = [number, bigint];

/**
 * The `Error` enum of this pallet.
 **/
export type PalletDemocracyError =
  /**
   * Value too low
   **/
  | "ValueLow"
  /**
   * Proposal does not exist
   **/
  | "ProposalMissing"
  /**
   * Cannot cancel the same proposal twice
   **/
  | "AlreadyCanceled"
  /**
   * Proposal already made
   **/
  | "DuplicateProposal"
  /**
   * Proposal still blacklisted
   **/
  | "ProposalBlacklisted"
  /**
   * Next external proposal not simple majority
   **/
  | "NotSimpleMajority"
  /**
   * Invalid hash
   **/
  | "InvalidHash"
  /**
   * No external proposal
   **/
  | "NoProposal"
  /**
   * Identity may not veto a proposal twice
   **/
  | "AlreadyVetoed"
  /**
   * Vote given for invalid referendum
   **/
  | "ReferendumInvalid"
  /**
   * No proposals waiting
   **/
  | "NoneWaiting"
  /**
   * The given account did not vote on the referendum.
   **/
  | "NotVoter"
  /**
   * The actor has no permission to conduct the action.
   **/
  | "NoPermission"
  /**
   * The account is already delegating.
   **/
  | "AlreadyDelegating"
  /**
   * Too high a balance was provided that the account cannot afford.
   **/
  | "InsufficientFunds"
  /**
   * The account is not currently delegating.
   **/
  | "NotDelegating"
  /**
   * The account currently has votes attached to it and the operation cannot succeed until
   * these are removed, either through `unvote` or `reap_vote`.
   **/
  | "VotesExist"
  /**
   * The instant referendum origin is currently disallowed.
   **/
  | "InstantNotAllowed"
  /**
   * Delegation to oneself makes no sense.
   **/
  | "Nonsense"
  /**
   * Invalid upper bound.
   **/
  | "WrongUpperBound"
  /**
   * Maximum number of votes reached.
   **/
  | "MaxVotesReached"
  /**
   * Maximum number of items reached.
   **/
  | "TooMany"
  /**
   * Voting period too low
   **/
  | "VotingPeriodLow"
  /**
   * The preimage does not exist.
   **/
  | "PreimageNotExist";

export type PalletCollectiveVotes = {
  index: number;
  threshold: number;
  ayes: Array<AccountId32>;
  nays: Array<AccountId32>;
  end: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletCollectiveError =
  /**
   * Account is not a member
   **/
  | "NotMember"
  /**
   * Duplicate proposals not allowed
   **/
  | "DuplicateProposal"
  /**
   * Proposal must exist
   **/
  | "ProposalMissing"
  /**
   * Mismatched index
   **/
  | "WrongIndex"
  /**
   * Duplicate vote ignored
   **/
  | "DuplicateVote"
  /**
   * Members are already initialized!
   **/
  | "AlreadyInitialized"
  /**
   * The close call was made too early, before the end of the voting.
   **/
  | "TooEarly"
  /**
   * There can only be a maximum of `MaxProposals` active proposals.
   **/
  | "TooManyProposals"
  /**
   * The given weight bound for the proposal was too low.
   **/
  | "WrongProposalWeight"
  /**
   * The given length bound for the proposal was too low.
   **/
  | "WrongProposalLength"
  /**
   * Prime account is not a member
   **/
  | "PrimeAccountNotMember"
  /**
   * Proposal is still active.
   **/
  | "ProposalActive";

export type PalletElectionsPhragmenSeatHolder = {
  who: AccountId32;
  stake: bigint;
  deposit: bigint;
};

export type PalletElectionsPhragmenVoter = {
  votes: Array<AccountId32>;
  stake: bigint;
  lockupTill: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletElectionsPhragmenError =
  /**
   * Cannot vote when no candidates or members exist.
   **/
  | "UnableToVote"
  /**
   * Must vote for at least one candidate.
   **/
  | "NoVotes"
  /**
   * Cannot vote more than candidates.
   **/
  | "TooManyVotes"
  /**
   * Cannot vote more than maximum allowed.
   **/
  | "MaximumVotesExceeded"
  /**
   * Cannot vote with stake less than minimum balance.
   **/
  | "LowBalance"
  /**
   * Voter can not pay voting bond.
   **/
  | "UnableToPayBond"
  /**
   * Must be a voter.
   **/
  | "MustBeVoter"
  | "VotingPeriodNotEnded"
  /**
   * Duplicated candidate submission.
   **/
  | "DuplicatedCandidate"
  /**
   * Too many candidates have been created.
   **/
  | "TooManyCandidates"
  /**
   * Member cannot re-submit candidacy.
   **/
  | "MemberSubmit"
  /**
   * Runner cannot re-submit candidacy.
   **/
  | "RunnerUpSubmit"
  /**
   * Candidate does not have enough funds.
   **/
  | "InsufficientCandidateFunds"
  /**
   * Not a member.
   **/
  | "NotMember"
  /**
   * The provided count of number of candidates is incorrect.
   **/
  | "InvalidWitnessData"
  /**
   * The provided count of number of votes is incorrect.
   **/
  | "InvalidVoteCount"
  /**
   * The renouncing origin presented a wrong `Renouncing` parameter.
   **/
  | "InvalidRenouncing"
  /**
   * Prediction regarding replacement after member removal is wrong.
   **/
  | "InvalidReplacement"
  /**
   * Unable to release held funds.
   **/
  | "UnableToReleaseBond";

export type PalletPreimageOldRequestStatus =
  | {
      type: "Unrequested";
      value: { deposit: [AccountId32, bigint]; len: number };
    }
  | {
      type: "Requested";
      value: {
        deposit?: [AccountId32, bigint] | undefined;
        count: number;
        len?: number | undefined;
      };
    };

export type PalletPreimageRequestStatus =
  | {
      type: "Unrequested";
      value: {
        ticket: [AccountId32, FrameSupportTokensFungibleHoldConsideration];
        len: number;
      };
    }
  | {
      type: "Requested";
      value: {
        maybeTicket?:
          | [AccountId32, FrameSupportTokensFungibleHoldConsideration]
          | undefined;
        count: number;
        maybeLen?: number | undefined;
      };
    };

export type FrameSupportTokensFungibleHoldConsideration = bigint;

/**
 * The `Error` enum of this pallet.
 **/
export type PalletPreimageError =
  /**
   * Preimage is too large to store on-chain.
   **/
  | "TooBig"
  /**
   * Preimage has already been noted on-chain.
   **/
  | "AlreadyNoted"
  /**
   * The user is not authorized to perform this action.
   **/
  | "NotAuthorized"
  /**
   * The preimage cannot be removed since it has not yet been noted.
   **/
  | "NotNoted"
  /**
   * A preimage may not be removed when there are outstanding requests.
   **/
  | "Requested"
  /**
   * The preimage request cannot be removed since no outstanding requests exist.
   **/
  | "NotRequested"
  /**
   * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
   **/
  | "TooMany"
  /**
   * Too few hashes were requested to be upgraded (i.e. zero).
   **/
  | "TooFew";

export type PalletSchedulerScheduled = {
  maybeId?: FixedBytes<32> | undefined;
  priority: number;
  call: FrameSupportPreimagesBounded;
  maybePeriodic?: [number, number] | undefined;
  origin: PolimecRuntimeOriginCaller;
};

export type PalletSchedulerRetryConfig = {
  totalRetries: number;
  remaining: number;
  period: number;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletSchedulerError =
  /**
   * Failed to schedule a call
   **/
  | "FailedToSchedule"
  /**
   * Cannot find the scheduled call.
   **/
  | "NotFound"
  /**
   * Given target block number is in the past.
   **/
  | "TargetBlockNumberInPast"
  /**
   * Reschedule failed because it does not change scheduled time.
   **/
  | "RescheduleNoChange"
  /**
   * Attempt to use a non-named function on a named task.
   **/
  | "Named";

export type OrmlOracleModuleTimestampedValue = {
  value: FixedU128;
  timestamp: bigint;
};

export type OrmlUtilitiesOrderedSet = Array<AccountId32>;

/**
 * The `Error` enum of this pallet.
 **/
export type OrmlOracleModuleError =
  /**
   * Sender does not have permission
   **/
  | "NoPermission"
  /**
   * Feeder has already feeded at this block
   **/
  | "AlreadyFeeded";

/**
 * The `Error` enum of this pallet.
 **/
export type PalletMembershipError =
  /**
   * Already a member.
   **/
  | "AlreadyMember"
  /**
   * Not a member.
   **/
  | "NotMember"
  /**
   * Too many members.
   **/
  | "TooManyMembers";

export type PalletFundingStorageBucket = {
  amountLeft: bigint;
  currentPrice: FixedU128;
  initialPrice: FixedU128;
  deltaPrice: FixedU128;
  deltaAmount: bigint;
};

export type PalletFundingStorageProjectDetails = {
  issuerAccount: AccountId32;
  issuerDid: Bytes;
  isFrozen: boolean;
  status: PalletFundingInnerProjectStatus;
  roundDuration: PalletFundingInnerBlockNumberPair;
  fundraisingTargetUsd: bigint;
  remainingContributionTokens: bigint;
  fundingAmountReachedUsd: bigint;
  evaluationRoundInfo: PalletFundingInnerEvaluationRoundInfo;
  usdBidOnOversubscription?: bigint | undefined;
  fundingEndBlock?: number | undefined;
};

export type PalletFundingInnerEvaluationRoundInfo = {
  totalBondedUsd: bigint;
  totalBondedPlmc: bigint;
  evaluatorsOutcome?: PalletFundingInnerEvaluatorsOutcome | undefined;
};

export type PalletFundingInnerEvaluatorsOutcome =
  | { type: "Rewarded"; value: PalletFundingInnerRewardInfo }
  | { type: "Slashed" };

export type PalletFundingInnerRewardInfo = {
  earlyEvaluatorRewardPot: bigint;
  normalEvaluatorRewardPot: bigint;
  earlyEvaluatorTotalBondedUsd: bigint;
  normalEvaluatorTotalBondedUsd: bigint;
};

export type PalletFundingInnerBlockNumberPair = {
  start?: number | undefined;
  end?: number | undefined;
};

export type PalletFundingStorageEvaluationInfo = {
  id: number;
  did: Bytes;
  projectId: number;
  evaluator: AccountId32;
  originalPlmcBond: bigint;
  currentPlmcBond: bigint;
  earlyUsdAmount: bigint;
  lateUsdAmount: bigint;
  when: number;
  receivingAccount: StagingXcmV4Junction;
};

export type PalletFundingStorageBidInfo = {
  id: number;
  projectId: number;
  bidder: AccountId32;
  did: Bytes;
  status: PalletFundingInnerBidStatus;
  originalCtAmount: bigint;
  originalCtUsdPrice: FixedU128;
  fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
  fundingAssetAmountLocked: bigint;
  mode: PalletFundingInnerParticipationMode;
  plmcBond: bigint;
  when: number;
  receivingAccount: StagingXcmV4Junction;
};

export type PalletFundingStorageBidBucketBounds = {
  firstBidIndex: number;
  lastBidIndex: number;
};

export type PalletFundingStorageOutbidBidsCutoff = {
  bidPrice: FixedU128;
  bidIndex: number;
};

export type PolimecCommonMigrationTypesMigration = {
  origin: PolimecCommonMigrationTypesMigrationOrigin;
  info: PolimecCommonMigrationTypesMigrationInfo;
};

export type PolimecCommonMigrationTypesMigrationOrigin = {
  user: StagingXcmV4Junction;
  participationType: PolimecCommonMigrationTypesParticipationType;
};

export type PolimecCommonMigrationTypesParticipationType = "Evaluation" | "Bid";

export type PolimecCommonMigrationTypesMigrationInfo = {
  contributionTokenAmount: bigint;
  vestingTime: bigint;
};

/**
 * The `Error` enum of this pallet.
 **/
export type PalletFundingError =
  /**
   * Something in storage has a state which should never be possible at this point. Programming error.
   **/
  | "ImpossibleState"
  /**
   * Action is not allowed.
   **/
  | "NotAllowed"
  /**
   * Checked math failed.
   **/
  | "BadMath"
  /**
   * Could not get the price in USD equivalent for an asset/PLMC.
   **/
  | "PriceNotFound"
  /**
   * Tried to retrieve a evaluation, bid or contribution but it does not exist.
   **/
  | "ParticipationNotFound"
  /**
   * The user investor type is not eligible for the action.
   **/
  | "WrongInvestorType"
  /**
   * Could not verify that the signature provided corresponds to the specified receiver account.
   **/
  | "BadReceiverAccountSignature"
  /**
   * Used a Junction variant unsupported to represent a receiving account.
   **/
  | "UnsupportedReceiverAccountJunction"
  /**
   * The project details were not found. Happens when the project with provided ID does
   * not exist in the `ProjectsDetails` storage.
   **/
  | "ProjectDetailsNotFound"
  /**
   * The project metadata was not found. Happens when the project with provided ID does
   * not exist in the `ProjectsMetadata` storage.
   **/
  | "ProjectMetadataNotFound"
  /**
   * The project's bucket info was not found. Happens when the project with provided ID does
   * not exist in the `Buckets` storage.
   **/
  | "BucketNotFound"
  /**
   * The project is already frozen, so cannot be frozen again. Happens when
   * `do_start_evaluation` is called on a project that has already started the
   * evaluation round.
   **/
  | "ProjectAlreadyFrozen"
  /**
   * The project is frozen, so no changes to the metadata are allowed and the project
   * cannot be deleted anymore.
   **/
  | "ProjectIsFrozen"
  /**
   * The project is not in the correct round to execute the action.
   **/
  | "IncorrectRound"
  /**
   * Too early to execute the action. The action can likely be called again at a later stage.
   **/
  | "TooEarlyForRound"
  /**
   * Too late to execute the action. Round has already ended, but transition to new
   * round has still to be executed.
   **/
  | "TooLateForRound"
  /**
   * A project's transition point (block number) was not set.
   **/
  | "TransitionPointNotSet"
  /**
   * did not have the correct state to execute an action.
   * The action's caller is not the issuer of the project and is not allowed to execute
   * this action.
   **/
  | "NotIssuer"
  /**
   * The issuer already has an active project. The issuer can only have one active project.
   **/
  | "HasActiveProject"
  /**
   * The issuer tries to participate to their own project.
   **/
  | "ParticipationToOwnProject"
  /**
   * The issuer has not enough funds to cover the escrow account costs.
   **/
  | "IssuerNotEnoughFunds"
  /**
   * The minimum price per token is too low.
   **/
  | "PriceTooLow"
  /**
   * The ticket sizes are not valid.
   **/
  | "TicketSizeError"
  /**
   * The participation currencies are not unique.
   **/
  | "ParticipationCurrenciesError"
  /**
   * The allocation size is invalid. Either zero or higher than the max supply.
   **/
  | "AllocationSizeError"
  /**
   * The auction round percentage cannot be zero.
   **/
  | "AuctionRoundPercentageError"
  /**
   * The funding target has to be higher than 1000 USD.
   **/
  | "FundingTargetTooLow"
  /**
   * The funding target has to be lower than 1bn USD.
   **/
  | "FundingTargetTooHigh"
  /**
   * The project's metadata hash is not provided while starting the evaluation round.
   **/
  | "CidNotProvided"
  /**
   * The ct decimals specified for the CT is outside the 4 to 20 range.
   **/
  | "BadDecimals"
  | "BadTokenomics"
  /**
   * The amount is too low.
   **/
  | "TooLow"
  /**
   * The amount is too high.
   **/
  | "TooHigh"
  /**
   * The participation currency is not accepted for this project.
   **/
  | "FundingAssetNotAccepted"
  /**
   * The user already has the maximum number of participations in this project.
   **/
  | "TooManyUserParticipations"
  /**
   * The user is not allowed to use the selected multiplier.
   **/
  | "ForbiddenMultiplier"
  /**
   * The user has a winning bid in the auction round and is not allowed to participate
   * in the community round.
   **/
  | "UserHasWinningBid"
  /**
   * The funds in the wallet are too low to cover the participation.
   **/
  | "ParticipantNotEnoughFunds"
  /**
   * The JWT included the wrong policy for participating in this project.
   **/
  | "PolicyMismatch"
  /**
   * Contribution tokens have all been sold
   **/
  | "ProjectSoldOut"
  /**
   * Tried to process an oversubscribed bid, but none remain.
   **/
  | "NoBidsOversubscribed"
  /**
   * Tried to transition the project, but some oversubscribed bid are still pending to be processed.
   **/
  | "OversubscribedBidsRemaining"
  /**
   * User has a partially accepted bid and needs to first process the rejected amount before settling the accepted amount.
   **/
  | "RejectedAmountInPartialBidRemaining"
  /**
   * Tried to start a migration check but the bidirectional channel is not yet open
   **/
  | "ChannelNotOpen"
  /**
   * The xcm execution/sending failed.
   **/
  | "XcmFailed"
  /**
   * Reached limit on maximum number of migrations. In practise this should not happen,
   * as the max migrations is set to the sum of max evaluations, bids and contributions.
   **/
  | "TooManyMigrations"
  /**
   * User has no migrations to execute.
   **/
  | "NoMigrationsFound"
  /**
   * User has no active migrations in the queue.
   **/
  | "NoActiveMigrationsFound"
  /**
   * Wrong para_id is provided.
   **/
  | "WrongParaId"
  /**
   * Migration channel is not ready for migrations.
   **/
  | "ChannelNotReady"
  /**
   * Settlement for this project has not yet started.
   **/
  | "SettlementNotStarted"
  /**
   * Wanted to settle as successful when it failed, or vice versa.
   **/
  | "WrongSettlementOutcome"
  /**
   * User still has participations that need to be settled before migration.
   **/
  | "ParticipationsNotSettled"
  /**
   * Tried to mark project as fully settled but there are participations that are not settled.
   **/
  | "SettlementNotComplete"
  /**
   * Tried to mark a project's CT migration as finished but there are still migrations to be confirmed
   **/
  | "MigrationsStillPending"
  /**
   * Tried to confirm an already confirmed user CT migration
   **/
  | "MigrationAlreadyConfirmed";

/**
 * Error for the vesting pallet.
 **/
export type PalletLinearReleaseError =
  /**
   * The account given is not vesting.
   **/
  | "NotVesting"
  /**
   * The account already has `MaxVestingSchedules` count of schedules and thus
   * cannot add another one. Consider merging existing schedules in order to add another.
   **/
  | "AtMaxVestingSchedules"
  /**
   * Amount being transferred is too low to create a vesting schedule.
   **/
  | "AmountLow"
  /**
   * An index was out of bounds of the vesting schedules.
   **/
  | "ScheduleIndexOutOfBounds"
  /**
   * Failed to create a new schedule because some parameter was invalid.
   **/
  | "InvalidScheduleParams";

export type PalletProxyBondingReleaseType =
  | { type: "Refunded" }
  | { type: "Locked"; value: number };

/**
 * The `Error` enum of this pallet.
 **/
export type PalletProxyBondingError =
  /**
   * The release type for the given derivation path / hold reason is not set
   **/
  | "ReleaseTypeNotSet"
  /**
   * Tried to unlock the native tokens and send them back to the treasury, but the release type configured a later unlock block.
   **/
  | "TooEarlyToUnlock"
  /**
   * The release type for the given derivation path / hold reason is set to `Refunded`, which disallows sending fees to the recipient
   **/
  | "FeeToRecipientDisallowed"
  /**
   * The release type for the given derivation path / hold reason is set to `Locked`, which disallows refunding fees
   **/
  | "FeeRefundDisallowed"
  /**
   * The price of a fee asset or the native token could not be retrieved
   **/
  | "PriceNotAvailable";

export type SpRuntimeMultiSignature =
  | { type: "Ed25519"; value: FixedBytes<64> }
  | { type: "Sr25519"; value: FixedBytes<64> }
  | { type: "Ecdsa"; value: FixedBytes<65> };

export type FrameSystemExtensionsCheckNonZeroSender = {};

export type FrameSystemExtensionsCheckSpecVersion = {};

export type FrameSystemExtensionsCheckTxVersion = {};

export type FrameSystemExtensionsCheckGenesis = {};

export type FrameSystemExtensionsCheckMortality = Era;

export type PalletDispenserExtensionsCheckNonce = number;

export type FrameSystemExtensionsCheckWeight = {};

export type PalletAssetTxPaymentChargeAssetTxPayment = {
  tip: bigint;
  assetId?: StagingXcmV3MultilocationMultiLocation | undefined;
};

export type FrameMetadataHashExtensionCheckMetadataHash = {
  mode: FrameMetadataHashExtensionMode;
};

export type FrameMetadataHashExtensionMode = "Disabled" | "Enabled";

export type PolimecRuntimeRuntime = {};

export type AssetsCommonRuntimeApiFungiblesAccessError =
  | "AssetIdConversionFailed"
  | "AmountToBalanceConversionFailed";

export type SpConsensusSlotsSlotDuration = bigint;

export type SpRuntimeBlock = {
  header: Header;
  extrinsics: Array<UncheckedExtrinsic>;
};

export type SpRuntimeExtrinsicInclusionMode = "AllExtrinsics" | "OnlyInherents";

export type SpCoreOpaqueMetadata = Bytes;

export type SpRuntimeTransactionValidityTransactionValidityError =
  | { type: "Invalid"; value: SpRuntimeTransactionValidityInvalidTransaction }
  | { type: "Unknown"; value: SpRuntimeTransactionValidityUnknownTransaction };

export type SpRuntimeTransactionValidityInvalidTransaction =
  | { type: "Call" }
  | { type: "Payment" }
  | { type: "Future" }
  | { type: "Stale" }
  | { type: "BadProof" }
  | { type: "AncientBirthBlock" }
  | { type: "ExhaustsResources" }
  | { type: "Custom"; value: number }
  | { type: "BadMandatory" }
  | { type: "MandatoryValidation" }
  | { type: "BadSigner" }
  | { type: "IndeterminateImplicit" }
  | { type: "UnknownOrigin" };

export type SpRuntimeTransactionValidityUnknownTransaction =
  | { type: "CannotLookup" }
  | { type: "NoUnsignedValidator" }
  | { type: "Custom"; value: number };

export type SpInherentsInherentData = { data: Array<[FixedBytes<8>, Bytes]> };

export type SpInherentsCheckInherentsResult = {
  okay: boolean;
  fatalError: boolean;
  errors: SpInherentsInherentData;
};

export type SpRuntimeTransactionValidityTransactionSource =
  | "InBlock"
  | "Local"
  | "External";

export type SpRuntimeTransactionValidityValidTransaction = {
  priority: bigint;
  requires: Array<Bytes>;
  provides: Array<Bytes>;
  longevity: bigint;
  propagate: boolean;
};

export type PalletTransactionPaymentRuntimeDispatchInfo = {
  weight: SpWeightsWeightV2Weight;
  class: FrameSupportDispatchDispatchClass;
  partialFee: bigint;
};

export type PalletTransactionPaymentFeeDetails = {
  inclusionFee?: PalletTransactionPaymentInclusionFee | undefined;
  tip: bigint;
};

export type PalletTransactionPaymentInclusionFee = {
  baseFee: bigint;
  lenFee: bigint;
  adjustedWeightFee: bigint;
};

export type CumulusPrimitivesCoreCollationInfo = {
  upwardMessages: Array<Bytes>;
  horizontalMessages: Array<PolkadotCorePrimitivesOutboundHrmpMessage>;
  newValidationCode?:
    | PolkadotParachainPrimitivesPrimitivesValidationCode
    | undefined;
  processedDownwardMessages: number;
  hrmpWatermark: number;
  headData: PolkadotParachainPrimitivesPrimitivesHeadData;
};

export type PolkadotParachainPrimitivesPrimitivesValidationCode = Bytes;

export type PolimecCommonCredentialsInvestorType =
  | "Retail"
  | "Professional"
  | "Institutional";

export type XcmRuntimeApisFeesError =
  | "Unimplemented"
  | "VersionedConversionFailed"
  | "WeightNotComputable"
  | "UnhandledXcmVersion"
  | "AssetNotFound"
  | "Unroutable";

export type XcmRuntimeApisDryRunCallDryRunEffects = {
  executionResult: Result<
    FrameSupportDispatchPostDispatchInfo,
    SpRuntimeDispatchErrorWithPostInfo
  >;
  emittedEvents: Array<PolimecRuntimeRuntimeEvent>;
  localXcm?: XcmVersionedXcm | undefined;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type FrameSupportDispatchPostDispatchInfo = {
  actualWeight?: SpWeightsWeightV2Weight | undefined;
  paysFee: FrameSupportDispatchPays;
};

export type SpRuntimeDispatchErrorWithPostInfo = {
  postInfo: FrameSupportDispatchPostDispatchInfo;
  error: DispatchError;
};

export type XcmRuntimeApisDryRunError =
  | "Unimplemented"
  | "VersionedConversionFailed";

export type XcmRuntimeApisDryRunXcmDryRunEffects = {
  executionResult: StagingXcmV5TraitsOutcome;
  emittedEvents: Array<PolimecRuntimeRuntimeEvent>;
  forwardedXcms: Array<[XcmVersionedLocation, Array<XcmVersionedXcm>]>;
};

export type PolimecRuntimeRuntimeError =
  | { pallet: "System"; palletError: FrameSystemError }
  | {
      pallet: "ParachainSystem";
      palletError: CumulusPalletParachainSystemError;
    }
  | { pallet: "Utility"; palletError: PalletUtilityError }
  | { pallet: "Multisig"; palletError: PalletMultisigError }
  | { pallet: "Proxy"; palletError: PalletProxyError }
  | { pallet: "Balances"; palletError: PalletBalancesError }
  | { pallet: "Vesting"; palletError: PalletVestingError }
  | { pallet: "ContributionTokens"; palletError: PalletAssetsError }
  | { pallet: "ForeignAssets"; palletError: PalletAssetsError }
  | { pallet: "Dispenser"; palletError: PalletDispenserError }
  | { pallet: "Session"; palletError: PalletSessionError }
  | { pallet: "ParachainStaking"; palletError: PalletParachainStakingError }
  | { pallet: "XcmpQueue"; palletError: CumulusPalletXcmpQueueError }
  | { pallet: "PolkadotXcm"; palletError: PalletXcmError }
  | { pallet: "MessageQueue"; palletError: PalletMessageQueueError }
  | { pallet: "Treasury"; palletError: PalletTreasuryError }
  | { pallet: "Democracy"; palletError: PalletDemocracyError }
  | { pallet: "Council"; palletError: PalletCollectiveError }
  | { pallet: "TechnicalCommittee"; palletError: PalletCollectiveError }
  | { pallet: "Elections"; palletError: PalletElectionsPhragmenError }
  | { pallet: "Preimage"; palletError: PalletPreimageError }
  | { pallet: "Scheduler"; palletError: PalletSchedulerError }
  | { pallet: "Oracle"; palletError: OrmlOracleModuleError }
  | { pallet: "OracleProvidersMembership"; palletError: PalletMembershipError }
  | { pallet: "Funding"; palletError: PalletFundingError }
  | { pallet: "LinearRelease"; palletError: PalletLinearReleaseError }
  | { pallet: "ProxyBonding"; palletError: PalletProxyBondingError };
