// Generated by dedot cli

import type {
  GenericChainErrors,
  GenericPalletError,
  RpcVersion,
} from "dedot/types";

export interface ChainErrors<Rv extends RpcVersion>
  extends GenericChainErrors<Rv> {
  /**
   * Pallet `System`'s errors
   **/
  system: {
    /**
     * The name of specification does not match between the current runtime
     * and the new runtime.
     **/
    InvalidSpecName: GenericPalletError<Rv>;

    /**
     * The specification version is not allowed to decrease between the current runtime
     * and the new runtime.
     **/
    SpecVersionNeedsToIncrease: GenericPalletError<Rv>;

    /**
     * Failed to extract the runtime version from the new runtime.
     *
     * Either calling `Core_version` or decoding `RuntimeVersion` failed.
     **/
    FailedToExtractRuntimeVersion: GenericPalletError<Rv>;

    /**
     * Suicide called when the account has non-default composite data.
     **/
    NonDefaultComposite: GenericPalletError<Rv>;

    /**
     * There is a non-zero reference count preventing the account from being purged.
     **/
    NonZeroRefCount: GenericPalletError<Rv>;

    /**
     * The origin filter prevent the call to be dispatched.
     **/
    CallFiltered: GenericPalletError<Rv>;

    /**
     * A multi-block migration is ongoing and prevents the current code from being replaced.
     **/
    MultiBlockMigrationsOngoing: GenericPalletError<Rv>;

    /**
     * No upgrade authorized.
     **/
    NothingAuthorized: GenericPalletError<Rv>;

    /**
     * The submitted code is not authorized.
     **/
    Unauthorized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ParachainSystem`'s errors
   **/
  parachainSystem: {
    /**
     * Attempt to upgrade validation function while existing upgrade pending.
     **/
    OverlappingUpgrades: GenericPalletError<Rv>;

    /**
     * Polkadot currently prohibits this parachain from upgrading its validation function.
     **/
    ProhibitedByPolkadot: GenericPalletError<Rv>;

    /**
     * The supplied validation function has compiled into a blob larger than Polkadot is
     * willing to run.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * The inherent which supplies the validation data did not run this block.
     **/
    ValidationDataNotAvailable: GenericPalletError<Rv>;

    /**
     * The inherent which supplies the host configuration did not run this block.
     **/
    HostConfigurationNotAvailable: GenericPalletError<Rv>;

    /**
     * No validation function upgrade is currently scheduled.
     **/
    NotScheduled: GenericPalletError<Rv>;

    /**
     * No code upgrade has been authorized.
     **/
    NothingAuthorized: GenericPalletError<Rv>;

    /**
     * The given code upgrade has not been authorized.
     **/
    Unauthorized: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Utility`'s errors
   **/
  utility: {
    /**
     * Too many calls batched.
     **/
    TooManyCalls: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Multisig`'s errors
   **/
  multisig: {
    /**
     * Threshold must be 2 or greater.
     **/
    MinimumThreshold: GenericPalletError<Rv>;

    /**
     * Call is already approved by this signatory.
     **/
    AlreadyApproved: GenericPalletError<Rv>;

    /**
     * Call doesn't need any (more) approvals.
     **/
    NoApprovalsNeeded: GenericPalletError<Rv>;

    /**
     * There are too few signatories in the list.
     **/
    TooFewSignatories: GenericPalletError<Rv>;

    /**
     * There are too many signatories in the list.
     **/
    TooManySignatories: GenericPalletError<Rv>;

    /**
     * The signatories were provided out of order; they should be ordered.
     **/
    SignatoriesOutOfOrder: GenericPalletError<Rv>;

    /**
     * The sender was contained in the other signatories; it shouldn't be.
     **/
    SenderInSignatories: GenericPalletError<Rv>;

    /**
     * Multisig operation not found when attempting to cancel.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Only the account that originally created the multisig is able to cancel it.
     **/
    NotOwner: GenericPalletError<Rv>;

    /**
     * No timepoint was given, yet the multisig operation is already underway.
     **/
    NoTimepoint: GenericPalletError<Rv>;

    /**
     * A different timepoint was given to the multisig operation that is underway.
     **/
    WrongTimepoint: GenericPalletError<Rv>;

    /**
     * A timepoint was given, yet no multisig operation is underway.
     **/
    UnexpectedTimepoint: GenericPalletError<Rv>;

    /**
     * The maximum weight information provided was too low.
     **/
    MaxWeightTooLow: GenericPalletError<Rv>;

    /**
     * The data to be stored is already stored.
     **/
    AlreadyStored: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Proxy`'s errors
   **/
  proxy: {
    /**
     * There are too many proxies registered or too many announcements pending.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Proxy registration not found.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Sender is not a proxy of the account to be proxied.
     **/
    NotProxy: GenericPalletError<Rv>;

    /**
     * A call which is incompatible with the proxy type's filter was attempted.
     **/
    Unproxyable: GenericPalletError<Rv>;

    /**
     * Account is already a proxy.
     **/
    Duplicate: GenericPalletError<Rv>;

    /**
     * Call may not be made by proxy because it may escalate its privileges.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * Announcement, if made at all, was made too recently.
     **/
    Unannounced: GenericPalletError<Rv>;

    /**
     * Cannot add self as proxy.
     **/
    NoSelfProxy: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Balances`'s errors
   **/
  balances: {
    /**
     * Vesting balance too high to send value.
     **/
    VestingBalance: GenericPalletError<Rv>;

    /**
     * Account liquidity restrictions prevent withdrawal.
     **/
    LiquidityRestrictions: GenericPalletError<Rv>;

    /**
     * Balance too low to send value.
     **/
    InsufficientBalance: GenericPalletError<Rv>;

    /**
     * Value too low to create account due to existential deposit.
     **/
    ExistentialDeposit: GenericPalletError<Rv>;

    /**
     * Transfer/payment would kill account.
     **/
    Expendability: GenericPalletError<Rv>;

    /**
     * A vesting schedule already exists for this account.
     **/
    ExistingVestingSchedule: GenericPalletError<Rv>;

    /**
     * Beneficiary account must pre-exist.
     **/
    DeadAccount: GenericPalletError<Rv>;

    /**
     * Number of named reserves exceed `MaxReserves`.
     **/
    TooManyReserves: GenericPalletError<Rv>;

    /**
     * Number of holds exceed `VariantCountOf<T::RuntimeHoldReason>`.
     **/
    TooManyHolds: GenericPalletError<Rv>;

    /**
     * Number of freezes exceed `MaxFreezes`.
     **/
    TooManyFreezes: GenericPalletError<Rv>;

    /**
     * The issuance cannot be modified since it is already deactivated.
     **/
    IssuanceDeactivated: GenericPalletError<Rv>;

    /**
     * The delta cannot be zero.
     **/
    DeltaZero: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Vesting`'s errors
   **/
  vesting: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError<Rv>;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError<Rv>;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError<Rv>;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError<Rv>;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ContributionTokens`'s errors
   **/
  contributionTokens: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError<Rv>;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError<Rv>;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError<Rv>;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError<Rv>;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError<Rv>;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError<Rv>;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError<Rv>;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError<Rv>;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError<Rv>;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError<Rv>;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError<Rv>;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError<Rv>;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ForeignAssets`'s errors
   **/
  foreignAssets: {
    /**
     * Account balance must be greater than or equal to the transfer amount.
     **/
    BalanceLow: GenericPalletError<Rv>;

    /**
     * The account to alter does not exist.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * The signing account has no permission to do the operation.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The given asset ID is unknown.
     **/
    Unknown: GenericPalletError<Rv>;

    /**
     * The origin account is frozen.
     **/
    Frozen: GenericPalletError<Rv>;

    /**
     * The asset ID is already taken.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * Invalid witness data given.
     **/
    BadWitness: GenericPalletError<Rv>;

    /**
     * Minimum balance should be non-zero.
     **/
    MinBalanceZero: GenericPalletError<Rv>;

    /**
     * Unable to increment the consumer reference counters on the account. Either no provider
     * reference exists to allow a non-zero balance of a non-self-sufficient asset, or one
     * fewer then the maximum number of consumers has been reached.
     **/
    UnavailableConsumer: GenericPalletError<Rv>;

    /**
     * Invalid metadata given.
     **/
    BadMetadata: GenericPalletError<Rv>;

    /**
     * No approval exists that would allow the transfer.
     **/
    Unapproved: GenericPalletError<Rv>;

    /**
     * The source account would not survive the transfer and it needs to stay alive.
     **/
    WouldDie: GenericPalletError<Rv>;

    /**
     * The asset-account already exists.
     **/
    AlreadyExists: GenericPalletError<Rv>;

    /**
     * The asset-account doesn't have an associated deposit.
     **/
    NoDeposit: GenericPalletError<Rv>;

    /**
     * The operation would result in funds being burned.
     **/
    WouldBurn: GenericPalletError<Rv>;

    /**
     * The asset is a live asset and is actively being used. Usually emit for operations such
     * as `start_destroy` which require the asset to be in a destroying state.
     **/
    LiveAsset: GenericPalletError<Rv>;

    /**
     * The asset is not live, and likely being destroyed.
     **/
    AssetNotLive: GenericPalletError<Rv>;

    /**
     * The asset status is not the expected status.
     **/
    IncorrectStatus: GenericPalletError<Rv>;

    /**
     * The asset should be frozen before the given operation.
     **/
    NotFrozen: GenericPalletError<Rv>;

    /**
     * Callback action resulted in error
     **/
    CallbackFailed: GenericPalletError<Rv>;

    /**
     * The asset ID must be equal to the [`NextAssetId`].
     **/
    BadAssetId: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Dispenser`'s errors
   **/
  dispenser: {
    /**
     * The dispenser has already dispensed to the DID.
     **/
    DispensedAlreadyToDid: GenericPalletError<Rv>;

    /**
     * The dispenser account does not have any funds to distribute.
     **/
    DispenserDepleted: GenericPalletError<Rv>;

    /**
     * The dispense amount is too low. It must be greater than the free dispense amount.
     **/
    DispenseAmountTooLow: GenericPalletError<Rv>;

    /**
     * The origin does not have the required credentials.
     **/
    InvalidCredential: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Session`'s errors
   **/
  session: {
    /**
     * Invalid ownership proof.
     **/
    InvalidProof: GenericPalletError<Rv>;

    /**
     * No associated validator ID for account.
     **/
    NoAssociatedValidatorId: GenericPalletError<Rv>;

    /**
     * Registered duplicate key.
     **/
    DuplicatedKey: GenericPalletError<Rv>;

    /**
     * No keys are associated with this account.
     **/
    NoKeys: GenericPalletError<Rv>;

    /**
     * Key setting account is not live, so it's impossible to associate keys.
     **/
    NoAccount: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ParachainStaking`'s errors
   **/
  parachainStaking: {
    DelegatorDNE: GenericPalletError<Rv>;
    DelegatorDNEinTopNorBottom: GenericPalletError<Rv>;
    DelegatorDNEInDelegatorSet: GenericPalletError<Rv>;
    CandidateDNE: GenericPalletError<Rv>;
    DelegationDNE: GenericPalletError<Rv>;
    DelegatorExists: GenericPalletError<Rv>;
    CandidateExists: GenericPalletError<Rv>;
    CandidateBondBelowMin: GenericPalletError<Rv>;
    InsufficientBalance: GenericPalletError<Rv>;
    DelegatorBondBelowMin: GenericPalletError<Rv>;
    DelegationBelowMin: GenericPalletError<Rv>;
    AlreadyOffline: GenericPalletError<Rv>;
    AlreadyActive: GenericPalletError<Rv>;
    DelegatorAlreadyLeaving: GenericPalletError<Rv>;
    DelegatorNotLeaving: GenericPalletError<Rv>;
    DelegatorCannotLeaveYet: GenericPalletError<Rv>;
    CannotDelegateIfLeaving: GenericPalletError<Rv>;
    CandidateAlreadyLeaving: GenericPalletError<Rv>;
    CandidateNotLeaving: GenericPalletError<Rv>;
    CandidateCannotLeaveYet: GenericPalletError<Rv>;
    CannotGoOnlineIfLeaving: GenericPalletError<Rv>;
    ExceedMaxDelegationsPerDelegator: GenericPalletError<Rv>;
    AlreadyDelegatedCandidate: GenericPalletError<Rv>;
    InvalidSchedule: GenericPalletError<Rv>;
    CannotSetBelowMin: GenericPalletError<Rv>;
    RoundLengthMustBeGreaterThanTotalSelectedCollators: GenericPalletError<Rv>;
    NoWritingSameValue: GenericPalletError<Rv>;
    TooLowCandidateCountWeightHintJoinCandidates: GenericPalletError<Rv>;
    TooLowCandidateCountWeightHintCancelLeaveCandidates: GenericPalletError<Rv>;
    TooLowCandidateCountToLeaveCandidates: GenericPalletError<Rv>;
    TooLowDelegationCountToDelegate: GenericPalletError<Rv>;
    TooLowCandidateDelegationCountToDelegate: GenericPalletError<Rv>;
    TooLowCandidateDelegationCountToLeaveCandidates: GenericPalletError<Rv>;
    TooLowDelegationCountToLeaveDelegators: GenericPalletError<Rv>;
    PendingCandidateRequestsDNE: GenericPalletError<Rv>;
    PendingCandidateRequestAlreadyExists: GenericPalletError<Rv>;
    PendingCandidateRequestNotDueYet: GenericPalletError<Rv>;
    PendingDelegationRequestDNE: GenericPalletError<Rv>;
    PendingDelegationRequestAlreadyExists: GenericPalletError<Rv>;
    PendingDelegationRequestNotDueYet: GenericPalletError<Rv>;
    CannotDelegateLessThanOrEqualToLowestBottomWhenFull: GenericPalletError<Rv>;
    PendingDelegationRevoke: GenericPalletError<Rv>;
    TooLowDelegationCountToAutoCompound: GenericPalletError<Rv>;
    TooLowCandidateAutoCompoundingDelegationCountToAutoCompound: GenericPalletError<Rv>;
    TooLowCandidateAutoCompoundingDelegationCountToDelegate: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `XcmpQueue`'s errors
   **/
  xcmpQueue: {
    /**
     * Setting the queue config failed since one of its values was invalid.
     **/
    BadQueueConfig: GenericPalletError<Rv>;

    /**
     * The execution is already suspended.
     **/
    AlreadySuspended: GenericPalletError<Rv>;

    /**
     * The execution is already resumed.
     **/
    AlreadyResumed: GenericPalletError<Rv>;

    /**
     * There are too many active outbound channels.
     **/
    TooManyActiveOutboundChannels: GenericPalletError<Rv>;

    /**
     * The message is too big.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `PolkadotXcm`'s errors
   **/
  polkadotXcm: {
    /**
     * The desired destination was unreachable, generally because there is a no way of routing
     * to it.
     **/
    Unreachable: GenericPalletError<Rv>;

    /**
     * There was some other issue (i.e. not to do with routing) in sending the message.
     * Perhaps a lack of space for buffering the message.
     **/
    SendFailure: GenericPalletError<Rv>;

    /**
     * The message execution fails the filter.
     **/
    Filtered: GenericPalletError<Rv>;

    /**
     * The message's weight could not be determined.
     **/
    UnweighableMessage: GenericPalletError<Rv>;

    /**
     * The destination `Location` provided cannot be inverted.
     **/
    DestinationNotInvertible: GenericPalletError<Rv>;

    /**
     * The assets to be sent are empty.
     **/
    Empty: GenericPalletError<Rv>;

    /**
     * Could not re-anchor the assets to declare the fees for the destination chain.
     **/
    CannotReanchor: GenericPalletError<Rv>;

    /**
     * Too many assets have been attempted for transfer.
     **/
    TooManyAssets: GenericPalletError<Rv>;

    /**
     * Origin is invalid for sending.
     **/
    InvalidOrigin: GenericPalletError<Rv>;

    /**
     * The version of the `Versioned` value used is not able to be interpreted.
     **/
    BadVersion: GenericPalletError<Rv>;

    /**
     * The given location could not be used (e.g. because it cannot be expressed in the
     * desired version of XCM).
     **/
    BadLocation: GenericPalletError<Rv>;

    /**
     * The referenced subscription could not be found.
     **/
    NoSubscription: GenericPalletError<Rv>;

    /**
     * The location is invalid since it already has a subscription from us.
     **/
    AlreadySubscribed: GenericPalletError<Rv>;

    /**
     * Could not check-out the assets for teleportation to the destination chain.
     **/
    CannotCheckOutTeleport: GenericPalletError<Rv>;

    /**
     * The owner does not own (all) of the asset that they wish to do the operation on.
     **/
    LowBalance: GenericPalletError<Rv>;

    /**
     * The asset owner has too many locks on the asset.
     **/
    TooManyLocks: GenericPalletError<Rv>;

    /**
     * The given account is not an identifiable sovereign account for any location.
     **/
    AccountNotSovereign: GenericPalletError<Rv>;

    /**
     * The operation required fees to be paid which the initiator could not meet.
     **/
    FeesNotMet: GenericPalletError<Rv>;

    /**
     * A remote lock with the corresponding data could not be found.
     **/
    LockNotFound: GenericPalletError<Rv>;

    /**
     * The unlock operation cannot succeed because there are still consumers of the lock.
     **/
    InUse: GenericPalletError<Rv>;

    /**
     * Invalid asset, reserve chain could not be determined for it.
     **/
    InvalidAssetUnknownReserve: GenericPalletError<Rv>;

    /**
     * Invalid asset, do not support remote asset reserves with different fees reserves.
     **/
    InvalidAssetUnsupportedReserve: GenericPalletError<Rv>;

    /**
     * Too many assets with different reserve locations have been attempted for transfer.
     **/
    TooManyReserves: GenericPalletError<Rv>;

    /**
     * Local XCM execution incomplete.
     **/
    LocalExecutionIncomplete: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `MessageQueue`'s errors
   **/
  messageQueue: {
    /**
     * Page is not reapable because it has items remaining to be processed and is not old
     * enough.
     **/
    NotReapable: GenericPalletError<Rv>;

    /**
     * Page to be reaped does not exist.
     **/
    NoPage: GenericPalletError<Rv>;

    /**
     * The referenced message could not be found.
     **/
    NoMessage: GenericPalletError<Rv>;

    /**
     * The message was already processed and cannot be processed again.
     **/
    AlreadyProcessed: GenericPalletError<Rv>;

    /**
     * The message is queued for future execution.
     **/
    Queued: GenericPalletError<Rv>;

    /**
     * There is temporarily not enough weight to continue servicing messages.
     **/
    InsufficientWeight: GenericPalletError<Rv>;

    /**
     * This message is temporarily unprocessable.
     *
     * Such errors are expected, but not guaranteed, to resolve themselves eventually through
     * retrying.
     **/
    TemporarilyUnprocessable: GenericPalletError<Rv>;

    /**
     * The queue is paused and no message can be executed from it.
     *
     * This can change at any time and may resolve in the future by re-trying.
     **/
    QueuePaused: GenericPalletError<Rv>;

    /**
     * Another call is in progress and needs to finish before this call can happen.
     **/
    RecursiveDisallowed: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Treasury`'s errors
   **/
  treasury: {
    /**
     * No proposal, bounty or spend at that index.
     **/
    InvalidIndex: GenericPalletError<Rv>;

    /**
     * Too many approvals in the queue.
     **/
    TooManyApprovals: GenericPalletError<Rv>;

    /**
     * The spend origin is valid but the amount it is allowed to spend is lower than the
     * amount to be spent.
     **/
    InsufficientPermission: GenericPalletError<Rv>;

    /**
     * Proposal has not been approved.
     **/
    ProposalNotApproved: GenericPalletError<Rv>;

    /**
     * The balance of the asset kind is not convertible to the balance of the native asset.
     **/
    FailedToConvertBalance: GenericPalletError<Rv>;

    /**
     * The spend has expired and cannot be claimed.
     **/
    SpendExpired: GenericPalletError<Rv>;

    /**
     * The spend is not yet eligible for payout.
     **/
    EarlyPayout: GenericPalletError<Rv>;

    /**
     * The payment has already been attempted.
     **/
    AlreadyAttempted: GenericPalletError<Rv>;

    /**
     * There was some issue with the mechanism of payment.
     **/
    PayoutError: GenericPalletError<Rv>;

    /**
     * The payout was not yet attempted/claimed.
     **/
    NotAttempted: GenericPalletError<Rv>;

    /**
     * The payment has neither failed nor succeeded yet.
     **/
    Inconclusive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Democracy`'s errors
   **/
  democracy: {
    /**
     * Value too low
     **/
    ValueLow: GenericPalletError<Rv>;

    /**
     * Proposal does not exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Cannot cancel the same proposal twice
     **/
    AlreadyCanceled: GenericPalletError<Rv>;

    /**
     * Proposal already made
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal still blacklisted
     **/
    ProposalBlacklisted: GenericPalletError<Rv>;

    /**
     * Next external proposal not simple majority
     **/
    NotSimpleMajority: GenericPalletError<Rv>;

    /**
     * Invalid hash
     **/
    InvalidHash: GenericPalletError<Rv>;

    /**
     * No external proposal
     **/
    NoProposal: GenericPalletError<Rv>;

    /**
     * Identity may not veto a proposal twice
     **/
    AlreadyVetoed: GenericPalletError<Rv>;

    /**
     * Vote given for invalid referendum
     **/
    ReferendumInvalid: GenericPalletError<Rv>;

    /**
     * No proposals waiting
     **/
    NoneWaiting: GenericPalletError<Rv>;

    /**
     * The given account did not vote on the referendum.
     **/
    NotVoter: GenericPalletError<Rv>;

    /**
     * The actor has no permission to conduct the action.
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * The account is already delegating.
     **/
    AlreadyDelegating: GenericPalletError<Rv>;

    /**
     * Too high a balance was provided that the account cannot afford.
     **/
    InsufficientFunds: GenericPalletError<Rv>;

    /**
     * The account is not currently delegating.
     **/
    NotDelegating: GenericPalletError<Rv>;

    /**
     * The account currently has votes attached to it and the operation cannot succeed until
     * these are removed, either through `unvote` or `reap_vote`.
     **/
    VotesExist: GenericPalletError<Rv>;

    /**
     * The instant referendum origin is currently disallowed.
     **/
    InstantNotAllowed: GenericPalletError<Rv>;

    /**
     * Delegation to oneself makes no sense.
     **/
    Nonsense: GenericPalletError<Rv>;

    /**
     * Invalid upper bound.
     **/
    WrongUpperBound: GenericPalletError<Rv>;

    /**
     * Maximum number of votes reached.
     **/
    MaxVotesReached: GenericPalletError<Rv>;

    /**
     * Maximum number of items reached.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Voting period too low
     **/
    VotingPeriodLow: GenericPalletError<Rv>;

    /**
     * The preimage does not exist.
     **/
    PreimageNotExist: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Council`'s errors
   **/
  council: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `TechnicalCommittee`'s errors
   **/
  technicalCommittee: {
    /**
     * Account is not a member
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Duplicate proposals not allowed
     **/
    DuplicateProposal: GenericPalletError<Rv>;

    /**
     * Proposal must exist
     **/
    ProposalMissing: GenericPalletError<Rv>;

    /**
     * Mismatched index
     **/
    WrongIndex: GenericPalletError<Rv>;

    /**
     * Duplicate vote ignored
     **/
    DuplicateVote: GenericPalletError<Rv>;

    /**
     * Members are already initialized!
     **/
    AlreadyInitialized: GenericPalletError<Rv>;

    /**
     * The close call was made too early, before the end of the voting.
     **/
    TooEarly: GenericPalletError<Rv>;

    /**
     * There can only be a maximum of `MaxProposals` active proposals.
     **/
    TooManyProposals: GenericPalletError<Rv>;

    /**
     * The given weight bound for the proposal was too low.
     **/
    WrongProposalWeight: GenericPalletError<Rv>;

    /**
     * The given length bound for the proposal was too low.
     **/
    WrongProposalLength: GenericPalletError<Rv>;

    /**
     * Prime account is not a member
     **/
    PrimeAccountNotMember: GenericPalletError<Rv>;

    /**
     * Proposal is still active.
     **/
    ProposalActive: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Elections`'s errors
   **/
  elections: {
    /**
     * Cannot vote when no candidates or members exist.
     **/
    UnableToVote: GenericPalletError<Rv>;

    /**
     * Must vote for at least one candidate.
     **/
    NoVotes: GenericPalletError<Rv>;

    /**
     * Cannot vote more than candidates.
     **/
    TooManyVotes: GenericPalletError<Rv>;

    /**
     * Cannot vote more than maximum allowed.
     **/
    MaximumVotesExceeded: GenericPalletError<Rv>;

    /**
     * Cannot vote with stake less than minimum balance.
     **/
    LowBalance: GenericPalletError<Rv>;

    /**
     * Voter can not pay voting bond.
     **/
    UnableToPayBond: GenericPalletError<Rv>;

    /**
     * Must be a voter.
     **/
    MustBeVoter: GenericPalletError<Rv>;
    VotingPeriodNotEnded: GenericPalletError<Rv>;

    /**
     * Duplicated candidate submission.
     **/
    DuplicatedCandidate: GenericPalletError<Rv>;

    /**
     * Too many candidates have been created.
     **/
    TooManyCandidates: GenericPalletError<Rv>;

    /**
     * Member cannot re-submit candidacy.
     **/
    MemberSubmit: GenericPalletError<Rv>;

    /**
     * Runner cannot re-submit candidacy.
     **/
    RunnerUpSubmit: GenericPalletError<Rv>;

    /**
     * Candidate does not have enough funds.
     **/
    InsufficientCandidateFunds: GenericPalletError<Rv>;

    /**
     * Not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * The provided count of number of candidates is incorrect.
     **/
    InvalidWitnessData: GenericPalletError<Rv>;

    /**
     * The provided count of number of votes is incorrect.
     **/
    InvalidVoteCount: GenericPalletError<Rv>;

    /**
     * The renouncing origin presented a wrong `Renouncing` parameter.
     **/
    InvalidRenouncing: GenericPalletError<Rv>;

    /**
     * Prediction regarding replacement after member removal is wrong.
     **/
    InvalidReplacement: GenericPalletError<Rv>;

    /**
     * Unable to release held funds.
     **/
    UnableToReleaseBond: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Preimage`'s errors
   **/
  preimage: {
    /**
     * Preimage is too large to store on-chain.
     **/
    TooBig: GenericPalletError<Rv>;

    /**
     * Preimage has already been noted on-chain.
     **/
    AlreadyNoted: GenericPalletError<Rv>;

    /**
     * The user is not authorized to perform this action.
     **/
    NotAuthorized: GenericPalletError<Rv>;

    /**
     * The preimage cannot be removed since it has not yet been noted.
     **/
    NotNoted: GenericPalletError<Rv>;

    /**
     * A preimage may not be removed when there are outstanding requests.
     **/
    Requested: GenericPalletError<Rv>;

    /**
     * The preimage request cannot be removed since no outstanding requests exist.
     **/
    NotRequested: GenericPalletError<Rv>;

    /**
     * More than `MAX_HASH_UPGRADE_BULK_COUNT` hashes were requested to be upgraded at once.
     **/
    TooMany: GenericPalletError<Rv>;

    /**
     * Too few hashes were requested to be upgraded (i.e. zero).
     **/
    TooFew: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Scheduler`'s errors
   **/
  scheduler: {
    /**
     * Failed to schedule a call
     **/
    FailedToSchedule: GenericPalletError<Rv>;

    /**
     * Cannot find the scheduled call.
     **/
    NotFound: GenericPalletError<Rv>;

    /**
     * Given target block number is in the past.
     **/
    TargetBlockNumberInPast: GenericPalletError<Rv>;

    /**
     * Reschedule failed because it does not change scheduled time.
     **/
    RescheduleNoChange: GenericPalletError<Rv>;

    /**
     * Attempt to use a non-named function on a named task.
     **/
    Named: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Oracle`'s errors
   **/
  oracle: {
    /**
     * Sender does not have permission
     **/
    NoPermission: GenericPalletError<Rv>;

    /**
     * Feeder has already feeded at this block
     **/
    AlreadyFeeded: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `OracleProvidersMembership`'s errors
   **/
  oracleProvidersMembership: {
    /**
     * Already a member.
     **/
    AlreadyMember: GenericPalletError<Rv>;

    /**
     * Not a member.
     **/
    NotMember: GenericPalletError<Rv>;

    /**
     * Too many members.
     **/
    TooManyMembers: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `Funding`'s errors
   **/
  funding: {
    /**
     * Something in storage has a state which should never be possible at this point. Programming error.
     **/
    ImpossibleState: GenericPalletError<Rv>;

    /**
     * Action is not allowed.
     **/
    NotAllowed: GenericPalletError<Rv>;

    /**
     * Checked math failed.
     **/
    BadMath: GenericPalletError<Rv>;

    /**
     * Could not get the price in USD equivalent for an asset/PLMC.
     **/
    PriceNotFound: GenericPalletError<Rv>;

    /**
     * Tried to retrieve a evaluation, bid or contribution but it does not exist.
     **/
    ParticipationNotFound: GenericPalletError<Rv>;

    /**
     * The user investor type is not eligible for the action.
     **/
    WrongInvestorType: GenericPalletError<Rv>;

    /**
     * Could not verify that the signature provided corresponds to the specified receiver account.
     **/
    BadReceiverAccountSignature: GenericPalletError<Rv>;

    /**
     * Used a Junction variant unsupported to represent a receiving account.
     **/
    UnsupportedReceiverAccountJunction: GenericPalletError<Rv>;

    /**
     * The project details were not found. Happens when the project with provided ID does
     * not exist in the `ProjectsDetails` storage.
     **/
    ProjectDetailsNotFound: GenericPalletError<Rv>;

    /**
     * The project metadata was not found. Happens when the project with provided ID does
     * not exist in the `ProjectsMetadata` storage.
     **/
    ProjectMetadataNotFound: GenericPalletError<Rv>;

    /**
     * The project's bucket info was not found. Happens when the project with provided ID does
     * not exist in the `Buckets` storage.
     **/
    BucketNotFound: GenericPalletError<Rv>;

    /**
     * The project is already frozen, so cannot be frozen again. Happens when
     * `do_start_evaluation` is called on a project that has already started the
     * evaluation round.
     **/
    ProjectAlreadyFrozen: GenericPalletError<Rv>;

    /**
     * The project is frozen, so no changes to the metadata are allowed and the project
     * cannot be deleted anymore.
     **/
    ProjectIsFrozen: GenericPalletError<Rv>;

    /**
     * The project is not in the correct round to execute the action.
     **/
    IncorrectRound: GenericPalletError<Rv>;

    /**
     * Too early to execute the action. The action can likely be called again at a later stage.
     **/
    TooEarlyForRound: GenericPalletError<Rv>;

    /**
     * Too late to execute the action. Round has already ended, but transition to new
     * round has still to be executed.
     **/
    TooLateForRound: GenericPalletError<Rv>;

    /**
     * A project's transition point (block number) was not set.
     **/
    TransitionPointNotSet: GenericPalletError<Rv>;

    /**
     * did not have the correct state to execute an action.
     * The action's caller is not the issuer of the project and is not allowed to execute
     * this action.
     **/
    NotIssuer: GenericPalletError<Rv>;

    /**
     * The issuer already has an active project. The issuer can only have one active project.
     **/
    HasActiveProject: GenericPalletError<Rv>;

    /**
     * The issuer tries to participate to their own project.
     **/
    ParticipationToOwnProject: GenericPalletError<Rv>;

    /**
     * The issuer has not enough funds to cover the escrow account costs.
     **/
    IssuerNotEnoughFunds: GenericPalletError<Rv>;

    /**
     * The minimum price per token is too low.
     **/
    PriceTooLow: GenericPalletError<Rv>;

    /**
     * The ticket sizes are not valid.
     **/
    TicketSizeError: GenericPalletError<Rv>;

    /**
     * The participation currencies are not unique.
     **/
    ParticipationCurrenciesError: GenericPalletError<Rv>;

    /**
     * The allocation size is invalid. Either zero or higher than the max supply.
     **/
    AllocationSizeError: GenericPalletError<Rv>;

    /**
     * The auction round percentage cannot be zero.
     **/
    AuctionRoundPercentageError: GenericPalletError<Rv>;

    /**
     * The funding target has to be higher than 1000 USD.
     **/
    FundingTargetTooLow: GenericPalletError<Rv>;

    /**
     * The funding target has to be lower than 1bn USD.
     **/
    FundingTargetTooHigh: GenericPalletError<Rv>;

    /**
     * The project's metadata hash is not provided while starting the evaluation round.
     **/
    CidNotProvided: GenericPalletError<Rv>;

    /**
     * The ct decimals specified for the CT is outside the 4 to 20 range.
     **/
    BadDecimals: GenericPalletError<Rv>;
    BadTokenomics: GenericPalletError<Rv>;

    /**
     * The amount is too low.
     **/
    TooLow: GenericPalletError<Rv>;

    /**
     * The amount is too high.
     **/
    TooHigh: GenericPalletError<Rv>;

    /**
     * The participation currency is not accepted for this project.
     **/
    FundingAssetNotAccepted: GenericPalletError<Rv>;

    /**
     * The user already has the maximum number of participations in this project.
     **/
    TooManyUserParticipations: GenericPalletError<Rv>;

    /**
     * The user is not allowed to use the selected multiplier.
     **/
    ForbiddenMultiplier: GenericPalletError<Rv>;

    /**
     * The user has a winning bid in the auction round and is not allowed to participate
     * in the community round.
     **/
    UserHasWinningBid: GenericPalletError<Rv>;

    /**
     * The funds in the wallet are too low to cover the participation.
     **/
    ParticipantNotEnoughFunds: GenericPalletError<Rv>;

    /**
     * The JWT included the wrong policy for participating in this project.
     **/
    PolicyMismatch: GenericPalletError<Rv>;

    /**
     * Contribution tokens have all been sold
     **/
    ProjectSoldOut: GenericPalletError<Rv>;

    /**
     * Tried to process an oversubscribed bid, but none remain.
     **/
    NoBidsOversubscribed: GenericPalletError<Rv>;

    /**
     * Tried to transition the project, but some oversubscribed bid are still pending to be processed.
     **/
    OversubscribedBidsRemaining: GenericPalletError<Rv>;

    /**
     * User has a partially accepted bid and needs to first process the rejected amount before settling the accepted amount.
     **/
    RejectedAmountInPartialBidRemaining: GenericPalletError<Rv>;

    /**
     * Tried to start a migration check but the bidirectional channel is not yet open
     **/
    ChannelNotOpen: GenericPalletError<Rv>;

    /**
     * The xcm execution/sending failed.
     **/
    XcmFailed: GenericPalletError<Rv>;

    /**
     * Reached limit on maximum number of migrations. In practise this should not happen,
     * as the max migrations is set to the sum of max evaluations, bids and contributions.
     **/
    TooManyMigrations: GenericPalletError<Rv>;

    /**
     * User has no migrations to execute.
     **/
    NoMigrationsFound: GenericPalletError<Rv>;

    /**
     * User has no active migrations in the queue.
     **/
    NoActiveMigrationsFound: GenericPalletError<Rv>;

    /**
     * Wrong para_id is provided.
     **/
    WrongParaId: GenericPalletError<Rv>;

    /**
     * Migration channel is not ready for migrations.
     **/
    ChannelNotReady: GenericPalletError<Rv>;

    /**
     * Settlement for this project has not yet started.
     **/
    SettlementNotStarted: GenericPalletError<Rv>;

    /**
     * Wanted to settle as successful when it failed, or vice versa.
     **/
    WrongSettlementOutcome: GenericPalletError<Rv>;

    /**
     * User still has participations that need to be settled before migration.
     **/
    ParticipationsNotSettled: GenericPalletError<Rv>;

    /**
     * Tried to mark project as fully settled but there are participations that are not settled.
     **/
    SettlementNotComplete: GenericPalletError<Rv>;

    /**
     * Tried to mark a project's CT migration as finished but there are still migrations to be confirmed
     **/
    MigrationsStillPending: GenericPalletError<Rv>;

    /**
     * Tried to confirm an already confirmed user CT migration
     **/
    MigrationAlreadyConfirmed: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `LinearRelease`'s errors
   **/
  linearRelease: {
    /**
     * The account given is not vesting.
     **/
    NotVesting: GenericPalletError<Rv>;

    /**
     * The account already has `MaxVestingSchedules` count of schedules and thus
     * cannot add another one. Consider merging existing schedules in order to add another.
     **/
    AtMaxVestingSchedules: GenericPalletError<Rv>;

    /**
     * Amount being transferred is too low to create a vesting schedule.
     **/
    AmountLow: GenericPalletError<Rv>;

    /**
     * An index was out of bounds of the vesting schedules.
     **/
    ScheduleIndexOutOfBounds: GenericPalletError<Rv>;

    /**
     * Failed to create a new schedule because some parameter was invalid.
     **/
    InvalidScheduleParams: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
  /**
   * Pallet `ProxyBonding`'s errors
   **/
  proxyBonding: {
    /**
     * The release type for the given derivation path / hold reason is not set
     **/
    ReleaseTypeNotSet: GenericPalletError<Rv>;

    /**
     * Tried to unlock the native tokens and send them back to the treasury, but the release type configured a later unlock block.
     **/
    TooEarlyToUnlock: GenericPalletError<Rv>;

    /**
     * The release type for the given derivation path / hold reason is set to `Refunded`, which disallows sending fees to the recipient
     **/
    FeeToRecipientDisallowed: GenericPalletError<Rv>;

    /**
     * The release type for the given derivation path / hold reason is set to `Locked`, which disallows refunding fees
     **/
    FeeRefundDisallowed: GenericPalletError<Rv>;

    /**
     * The price of a fee asset or the native token could not be retrieved
     **/
    PriceNotAvailable: GenericPalletError<Rv>;

    /**
     * Generic pallet error
     **/
    [error: string]: GenericPalletError<Rv>;
  };
}
