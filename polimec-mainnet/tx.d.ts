// Generated by dedot cli

import type {
  GenericChainTx,
  GenericTxCall,
  ISubmittableExtrinsic,
  ISubmittableResult,
  IRuntimeTxCall,
  RpcVersion,
  RpcV2,
  ISubmittableExtrinsicLegacy,
} from "dedot/types";
import type {
  MultiAddressLike,
  Extrinsic,
  BytesLike,
  H256,
  AccountId32Like,
  FixedBytes,
  Perbill,
  Percent,
  FixedU128,
} from "dedot/codecs";
import type {
  PolimecRuntimeRuntimeCallLike,
  SpRuntimeMultiSignature,
  FrameSystemEventRecord,
  CumulusPrimitivesParachainInherentParachainInherentData,
  PolimecRuntimeOriginCaller,
  SpWeightsWeightV2Weight,
  PalletMultisigTimepoint,
  SharedConfigurationProxyType,
  PalletBalancesAdjustmentDirection,
  PalletVestingVestingInfo,
  StagingXcmV4Location,
  JwtCompactFrameTokenUntrustedToken,
  PolimecRuntimeSessionKeys,
  XcmVersionedLocation,
  XcmVersionedXcm,
  XcmVersionedAssets,
  StagingXcmV5Location,
  XcmV3WeightLimit,
  StagingXcmExecutorAssetTransferTransferType,
  XcmVersionedAssetId,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  FrameSupportPreimagesBounded,
  PalletDemocracyVoteAccountVote,
  PalletDemocracyConviction,
  PalletDemocracyMetadataOwner,
  PalletElectionsPhragmenRenouncing,
  PalletFundingStorageProjectMetadata,
  StagingXcmV4Junction,
  PalletFundingInnerParticipationMode,
  PolimecCommonAssetsAcceptedFundingAsset,
  PolimecRuntimeRuntimeHoldReason,
  PalletLinearReleaseVestingInfo,
} from "./types.js";

export type ChainSubmittableExtrinsic<
  Rv extends RpcVersion,
  T extends IRuntimeTxCall = PolimecRuntimeRuntimeCallLike,
> = Extrinsic<MultiAddressLike, T, SpRuntimeMultiSignature, any[]> &
  (Rv extends RpcV2
    ? ISubmittableExtrinsic<ISubmittableResult<FrameSystemEventRecord>>
    : ISubmittableExtrinsicLegacy<ISubmittableResult<FrameSystemEventRecord>>);

export type TxCall<Rv extends RpcVersion> = (
  ...args: any[]
) => ChainSubmittableExtrinsic<Rv>;

export interface ChainTx<Rv extends RpcVersion>
  extends GenericChainTx<Rv, TxCall<Rv>> {
  /**
   * Pallet `System`'s transaction calls
   **/
  system: {
    /**
     * Make some on-chain remark.
     *
     * Can be executed by every `origin`.
     *
     * @param {BytesLike} remark
     **/
    remark: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "Remark";
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the number of pages in the WebAssembly environment's heap.
     *
     * @param {bigint} pages
     **/
    setHeapPages: GenericTxCall<
      Rv,
      (pages: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetHeapPages";
            params: { pages: bigint };
          };
        }
      >
    >;

    /**
     * Set the new runtime code.
     *
     * @param {BytesLike} code
     **/
    setCode: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetCode";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set the new runtime code without doing any checks of the given `code`.
     *
     * Note that runtime upgrades will not run if this is called with a not-increasing spec
     * version!
     *
     * @param {BytesLike} code
     **/
    setCodeWithoutChecks: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetCodeWithoutChecks";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Set some items of storage.
     *
     * @param {Array<[BytesLike, BytesLike]>} items
     **/
    setStorage: GenericTxCall<
      Rv,
      (items: Array<[BytesLike, BytesLike]>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "SetStorage";
            params: { items: Array<[BytesLike, BytesLike]> };
          };
        }
      >
    >;

    /**
     * Kill some items from storage.
     *
     * @param {Array<BytesLike>} keys
     **/
    killStorage: GenericTxCall<
      Rv,
      (keys: Array<BytesLike>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "KillStorage";
            params: { keys: Array<BytesLike> };
          };
        }
      >
    >;

    /**
     * Kill all storage items with a key that starts with the given prefix.
     *
     * **NOTE:** We rely on the Root origin to provide us the number of subkeys under
     * the prefix we are removing to accurately calculate the weight of this function.
     *
     * @param {BytesLike} prefix
     * @param {number} subkeys
     **/
    killPrefix: GenericTxCall<
      Rv,
      (
        prefix: BytesLike,
        subkeys: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "KillPrefix";
            params: { prefix: BytesLike; subkeys: number };
          };
        }
      >
    >;

    /**
     * Make some on-chain remark and emit event.
     *
     * @param {BytesLike} remark
     **/
    remarkWithEvent: GenericTxCall<
      Rv,
      (remark: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "RemarkWithEvent";
            params: { remark: BytesLike };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgrade: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "AuthorizeUpgrade";
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Authorize an upgrade to a given `code_hash` for the runtime. The runtime can be supplied
     * later.
     *
     * WARNING: This authorizes an upgrade that will take place without any safety checks, for
     * example that the spec name remains the same and that the version number increases. Not
     * recommended for normal use. Use `authorize_upgrade` instead.
     *
     * This call requires Root origin.
     *
     * @param {H256} codeHash
     **/
    authorizeUpgradeWithoutChecks: GenericTxCall<
      Rv,
      (codeHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "AuthorizeUpgradeWithoutChecks";
            params: { codeHash: H256 };
          };
        }
      >
    >;

    /**
     * Provide the preimage (runtime binary) `code` for an upgrade that has been authorized.
     *
     * If the authorization required a version check, this call will ensure the spec name
     * remains unchanged and that the spec version has increased.
     *
     * Depending on the runtime's `OnSetCode` configuration, this function may directly apply
     * the new `code` in the same block or attempt to schedule the upgrade.
     *
     * All origins are allowed.
     *
     * @param {BytesLike} code
     **/
    applyAuthorizedUpgrade: GenericTxCall<
      Rv,
      (code: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "System";
          palletCall: {
            name: "ApplyAuthorizedUpgrade";
            params: { code: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainSystem`'s transaction calls
   **/
  parachainSystem: {
    /**
     * Set the current validation data.
     *
     * This should be invoked exactly once per block. It will panic at the finalization
     * phase if the call was not invoked.
     *
     * The dispatch origin for this call must be `Inherent`
     *
     * As a side effect, this function upgrades the current validation function
     * if the appropriate time has come.
     *
     * @param {CumulusPrimitivesParachainInherentParachainInherentData} data
     **/
    setValidationData: GenericTxCall<
      Rv,
      (
        data: CumulusPrimitivesParachainInherentParachainInherentData,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainSystem";
          palletCall: {
            name: "SetValidationData";
            params: {
              data: CumulusPrimitivesParachainInherentParachainInherentData;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {BytesLike} message
     **/
    sudoSendUpwardMessage: GenericTxCall<
      Rv,
      (message: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainSystem";
          palletCall: {
            name: "SudoSendUpwardMessage";
            params: { message: BytesLike };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Timestamp`'s transaction calls
   **/
  timestamp: {
    /**
     * Set the current time.
     *
     * This call should be invoked exactly once per block. It will panic at the finalization
     * phase, if this call hasn't been invoked by that time.
     *
     * The timestamp should be greater than the previous one by the amount specified by
     * [`Config::MinimumPeriod`].
     *
     * The dispatch origin for this call must be _None_.
     *
     * This dispatch class is _Mandatory_ to ensure it gets executed in the block. Be aware
     * that changing the complexity of this call could result exhausting the resources in a
     * block to execute any other calls.
     *
     * ## Complexity
     * - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)
     * - 1 storage read and 1 storage mutation (codec `O(1)` because of `DidUpdate::take` in
     * `on_finalize`)
     * - 1 event handler `on_timestamp_set`. Must be `O(1)`.
     *
     * @param {bigint} now
     **/
    set: GenericTxCall<
      Rv,
      (now: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Timestamp";
          palletCall: {
            name: "Set";
            params: { now: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainInfo`'s transaction calls
   **/
  parachainInfo: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Utility`'s transaction calls
   **/
  utility: {
    /**
     * Send a batch of dispatch calls.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * This will return `Ok` in all circumstances. To determine the success of the batch, an
     * event is deposited. If a call failed and the batch was interrupted, then the
     * `BatchInterrupted` event is deposited, along with the number of successful calls made
     * and the error of the failed call. If all were successful, then the `BatchCompleted`
     * event is deposited.
     *
     * @param {Array<PolimecRuntimeRuntimeCallLike>} calls
     **/
    batch: GenericTxCall<
      Rv,
      (
        calls: Array<PolimecRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "Batch";
            params: { calls: Array<PolimecRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Send a call through an indexed pseudonym of the sender.
     *
     * Filter from origin are passed along. The call will be dispatched with an origin which
     * use the same filter as the origin of this call.
     *
     * NOTE: If you need to ensure that any account-based filtering is not honored (i.e.
     * because you expect `proxy` to have been used prior in the call stack and you do not want
     * the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`
     * in the Multisig pallet instead.
     *
     * NOTE: Prior to version *12, this was called `as_limited_sub`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * @param {number} index
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    asDerivative: GenericTxCall<
      Rv,
      (
        index: number,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "AsDerivative";
            params: { index: number; call: PolimecRuntimeRuntimeCallLike };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls and atomically execute them.
     * The whole transaction will rollback and fail if any of the calls failed.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatched without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<PolimecRuntimeRuntimeCallLike>} calls
     **/
    batchAll: GenericTxCall<
      Rv,
      (
        calls: Array<PolimecRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "BatchAll";
            params: { calls: Array<PolimecRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatches a function call with a provided origin.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * ## Complexity
     * - O(1).
     *
     * @param {PolimecRuntimeOriginCaller} asOrigin
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    dispatchAs: GenericTxCall<
      Rv,
      (
        asOrigin: PolimecRuntimeOriginCaller,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "DispatchAs";
            params: {
              asOrigin: PolimecRuntimeOriginCaller;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Send a batch of dispatch calls.
     * Unlike `batch`, it allows errors and won't interrupt.
     *
     * May be called from any origin except `None`.
     *
     * - `calls`: The calls to be dispatched from the same origin. The number of call must not
     * exceed the constant: `batched_calls_limit` (available in constant metadata).
     *
     * If origin is root then the calls are dispatch without checking origin filter. (This
     * includes bypassing `frame_system::Config::BaseCallFilter`).
     *
     * ## Complexity
     * - O(C) where C is the number of calls to be batched.
     *
     * @param {Array<PolimecRuntimeRuntimeCallLike>} calls
     **/
    forceBatch: GenericTxCall<
      Rv,
      (
        calls: Array<PolimecRuntimeRuntimeCallLike>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "ForceBatch";
            params: { calls: Array<PolimecRuntimeRuntimeCallLike> };
          };
        }
      >
    >;

    /**
     * Dispatch a function call with a specified weight.
     *
     * This function does not check the weight of the call, and instead allows the
     * Root origin to specify the weight of the call.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * @param {PolimecRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} weight
     **/
    withWeight: GenericTxCall<
      Rv,
      (
        call: PolimecRuntimeRuntimeCallLike,
        weight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Utility";
          palletCall: {
            name: "WithWeight";
            params: {
              call: PolimecRuntimeRuntimeCallLike;
              weight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Multisig`'s transaction calls
   **/
  multisig: {
    /**
     * Immediately dispatch a multi-signature call using a single approval from the caller.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `other_signatories`: The accounts (other than the sender) who are part of the
     * multi-signature, but do not participate in the approval process.
     * - `call`: The call to be executed.
     *
     * Result is equivalent to the dispatched result.
     *
     * ## Complexity
     * O(Z + C) where Z is the length of the call and C its execution weight.
     *
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    asMultiThreshold1: GenericTxCall<
      Rv,
      (
        otherSignatories: Array<AccountId32Like>,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "AsMultiThreshold1";
            params: {
              otherSignatories: Array<AccountId32Like>;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * If there are enough, then dispatch the call.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call`: The call to be executed.
     *
     * NOTE: Unless this is the final approval, you will generally want to use
     * `approve_as_multi` instead, since it only requires a hash of the call.
     *
     * Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise
     * on success, result is `Ok` and the result from the interior call, if it was executed,
     * may be found in the deposited `MultisigExecuted` event.
     *
     * ## Complexity
     * - `O(S + Z + Call)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - The weight of the `call`.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {PolimecRuntimeRuntimeCallLike} call
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    asMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        call: PolimecRuntimeRuntimeCallLike,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "AsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              call: PolimecRuntimeRuntimeCallLike;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Register approval for a dispatch to be made from a deterministic composite account if
     * approved by a total of `threshold - 1` of `other_signatories`.
     *
     * Payment: `DepositBase` will be reserved if this is the first approval, plus
     * `threshold` times `DepositFactor`. It is returned once this dispatch happens or
     * is cancelled.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is
     * not the first approval, then it must be `Some`, with the timepoint (block number and
     * transaction index) of the first approval transaction.
     * - `call_hash`: The hash of the call to be executed.
     *
     * NOTE: If this is the final approval, you will want to use `as_multi` instead.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - Up to one binary search and insert (`O(logS + S)`).
     * - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.
     * - One event.
     * - Storage: inserts one item, value size bounded by `MaxSignatories`, with a deposit
     * taken for its lifetime of `DepositBase + threshold * DepositFactor`.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint | undefined} maybeTimepoint
     * @param {FixedBytes<32>} callHash
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    approveAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        maybeTimepoint: PalletMultisigTimepoint | undefined,
        callHash: FixedBytes<32>,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "ApproveAsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              maybeTimepoint: PalletMultisigTimepoint | undefined;
              callHash: FixedBytes<32>;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously
     * for this operation will be unreserved on success.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `threshold`: The total number of approvals for this dispatch before it is executed.
     * - `other_signatories`: The accounts (other than the sender) who can approve this
     * dispatch. May not be empty.
     * - `timepoint`: The timepoint (block number and transaction index) of the first approval
     * transaction for this dispatch.
     * - `call_hash`: The hash of the call to be executed.
     *
     * ## Complexity
     * - `O(S)`.
     * - Up to one balance-reserve or unreserve operation.
     * - One passthrough operation, one insert, both `O(S)` where `S` is the number of
     * signatories. `S` is capped by `MaxSignatories`, with weight being proportional.
     * - One encode & hash, both of complexity `O(S)`.
     * - One event.
     * - I/O: 1 read `O(S)`, one remove.
     * - Storage: removes one item.
     *
     * @param {number} threshold
     * @param {Array<AccountId32Like>} otherSignatories
     * @param {PalletMultisigTimepoint} timepoint
     * @param {FixedBytes<32>} callHash
     **/
    cancelAsMulti: GenericTxCall<
      Rv,
      (
        threshold: number,
        otherSignatories: Array<AccountId32Like>,
        timepoint: PalletMultisigTimepoint,
        callHash: FixedBytes<32>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Multisig";
          palletCall: {
            name: "CancelAsMulti";
            params: {
              threshold: number;
              otherSignatories: Array<AccountId32Like>;
              timepoint: PalletMultisigTimepoint;
              callHash: FixedBytes<32>;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Proxy`'s transaction calls
   **/
  proxy: {
    /**
     * Dispatch the given `call` from an account that the sender is authorised for through
     * `add_proxy`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {SharedConfigurationProxyType | undefined} forceProxyType
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    proxy: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        forceProxyType: SharedConfigurationProxyType | undefined,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "Proxy";
            params: {
              real: MultiAddressLike;
              forceProxyType: SharedConfigurationProxyType | undefined;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Register a proxy account for the sender that is able to make calls on its behalf.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to make a proxy.
     * - `proxy_type`: The permissions allowed for this proxy account.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * @param {MultiAddressLike} delegate
     * @param {SharedConfigurationProxyType} proxyType
     * @param {number} delay
     **/
    addProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: SharedConfigurationProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "AddProxy";
            params: {
              delegate: MultiAddressLike;
              proxyType: SharedConfigurationProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister a proxy account for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `proxy`: The account that the `caller` would like to remove as a proxy.
     * - `proxy_type`: The permissions currently enabled for the removed proxy account.
     *
     * @param {MultiAddressLike} delegate
     * @param {SharedConfigurationProxyType} proxyType
     * @param {number} delay
     **/
    removeProxy: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        proxyType: SharedConfigurationProxyType,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveProxy";
            params: {
              delegate: MultiAddressLike;
              proxyType: SharedConfigurationProxyType;
              delay: number;
            };
          };
        }
      >
    >;

    /**
     * Unregister all proxy accounts for the sender.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * WARNING: This may be called on accounts created by `pure`, however if done, then
     * the unreserved fees will be inaccessible. **All access to this account will be lost.**
     *
     **/
    removeProxies: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveProxies";
          };
        }
      >
    >;

    /**
     * Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and
     * initialize it with a proxy of `proxy_type` for `origin` sender.
     *
     * Requires a `Signed` origin.
     *
     * - `proxy_type`: The type of the proxy that the sender will be registered as over the
     * new account. This will almost always be the most permissive `ProxyType` possible to
     * allow for maximum flexibility.
     * - `index`: A disambiguation index, in case this is called multiple times in the same
     * transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just
     * want to use `0`.
     * - `delay`: The announcement period required of the initial proxy. Will generally be
     * zero.
     *
     * Fails with `Duplicate` if this has already been called in this transaction, from the
     * same sender, with the same parameters.
     *
     * Fails if there are insufficient funds to pay for deposit.
     *
     * @param {SharedConfigurationProxyType} proxyType
     * @param {number} delay
     * @param {number} index
     **/
    createPure: GenericTxCall<
      Rv,
      (
        proxyType: SharedConfigurationProxyType,
        delay: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "CreatePure";
            params: {
              proxyType: SharedConfigurationProxyType;
              delay: number;
              index: number;
            };
          };
        }
      >
    >;

    /**
     * Removes a previously spawned pure proxy.
     *
     * WARNING: **All access to this account will be lost.** Any funds held in it will be
     * inaccessible.
     *
     * Requires a `Signed` origin, and the sender account must have been created by a call to
     * `pure` with corresponding parameters.
     *
     * - `spawner`: The account that originally called `pure` to create this account.
     * - `index`: The disambiguation index originally passed to `pure`. Probably `0`.
     * - `proxy_type`: The proxy type originally passed to `pure`.
     * - `height`: The height of the chain when the call to `pure` was processed.
     * - `ext_index`: The extrinsic index in which the call to `pure` was processed.
     *
     * Fails with `NoPermission` in case the caller is not a previously created pure
     * account whose `pure` call has corresponding parameters.
     *
     * @param {MultiAddressLike} spawner
     * @param {SharedConfigurationProxyType} proxyType
     * @param {number} index
     * @param {number} height
     * @param {number} extIndex
     **/
    killPure: GenericTxCall<
      Rv,
      (
        spawner: MultiAddressLike,
        proxyType: SharedConfigurationProxyType,
        index: number,
        height: number,
        extIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "KillPure";
            params: {
              spawner: MultiAddressLike;
              proxyType: SharedConfigurationProxyType;
              index: number;
              height: number;
              extIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Publish the hash of a proxy-call that will be made in the future.
     *
     * This must be called some number of blocks before the corresponding `proxy` is attempted
     * if the delay associated with the proxy relationship is greater than zero.
     *
     * No more than `MaxPending` announcements may be made at any one time.
     *
     * This will take a deposit of `AnnouncementDepositFactor` as well as
     * `AnnouncementDepositBase` if there are no other pending announcements.
     *
     * The dispatch origin for this call must be _Signed_ and a proxy of `real`.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    announce: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "Announce";
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a given announcement.
     *
     * May be called by a proxy account to remove a call they previously announced and return
     * the deposit.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `call_hash`: The hash of the call to be made by the `real` account.
     *
     * @param {MultiAddressLike} real
     * @param {H256} callHash
     **/
    removeAnnouncement: GenericTxCall<
      Rv,
      (
        real: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RemoveAnnouncement";
            params: { real: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove the given announcement of a delegate.
     *
     * May be called by a target (proxied) account to remove a call that one of their delegates
     * (`delegate`) has announced they want to execute. The deposit is returned.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `delegate`: The account that previously announced the call.
     * - `call_hash`: The hash of the call to be made.
     *
     * @param {MultiAddressLike} delegate
     * @param {H256} callHash
     **/
    rejectAnnouncement: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        callHash: H256,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "RejectAnnouncement";
            params: { delegate: MultiAddressLike; callHash: H256 };
          };
        }
      >
    >;

    /**
     * Dispatch the given `call` from an account that the sender is authorized for through
     * `add_proxy`.
     *
     * Removes any corresponding announcement(s).
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * Parameters:
     * - `real`: The account that the proxy will make a call on behalf of.
     * - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.
     * - `call`: The call to be made by the `real` account.
     *
     * @param {MultiAddressLike} delegate
     * @param {MultiAddressLike} real
     * @param {SharedConfigurationProxyType | undefined} forceProxyType
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    proxyAnnounced: GenericTxCall<
      Rv,
      (
        delegate: MultiAddressLike,
        real: MultiAddressLike,
        forceProxyType: SharedConfigurationProxyType | undefined,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Proxy";
          palletCall: {
            name: "ProxyAnnounced";
            params: {
              delegate: MultiAddressLike;
              real: MultiAddressLike;
              forceProxyType: SharedConfigurationProxyType | undefined;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Balances`'s transaction calls
   **/
  balances: {
    /**
     * Transfer some liquid free balance to another account.
     *
     * `transfer_allow_death` will set the `FreeBalance` of the sender and receiver.
     * If the sender's account is below the existential deposit as a result
     * of the transfer, the account will be reaped.
     *
     * The dispatch origin for this call must be `Signed` by the transactor.
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferAllowDeath: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferAllowDeath";
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Exactly as `transfer_allow_death`, except the origin must be root and the source account
     * may be specified.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceTransfer";
            params: {
              source: MultiAddressLike;
              dest: MultiAddressLike;
              value: bigint;
            };
          };
        }
      >
    >;

    /**
     * Same as the [`transfer_allow_death`] call, but with a check that the transfer will not
     * kill the origin account.
     *
     * 99% of the time you want [`transfer_allow_death`] instead.
     *
     * [`transfer_allow_death`]: struct.Pallet.html#method.transfer
     *
     * @param {MultiAddressLike} dest
     * @param {bigint} value
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferKeepAlive";
            params: { dest: MultiAddressLike; value: bigint };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any locked, reserved, or existential deposits (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the account has, causing the sender account to be killed (false), or
     * transfer everything except at least the existential deposit, which will guarantee to
     * keep the sender account alive (true).
     *
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "TransferAll";
            params: { dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Unreserve some balance from a user by force.
     *
     * Can only be called by ROOT.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    forceUnreserve: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceUnreserve";
            params: { who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Upgrade a specified account.
     *
     * - `origin`: Must be `Signed`.
     * - `who`: The account to be upgraded.
     *
     * This will waive the transaction fee if at least all but 10% of the accounts needed to
     * be upgraded. (We let some not have to be upgraded just in order to allow for the
     * possibility of churn).
     *
     * @param {Array<AccountId32Like>} who
     **/
    upgradeAccounts: GenericTxCall<
      Rv,
      (who: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "UpgradeAccounts";
            params: { who: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Set the regular balance of a given account.
     *
     * The dispatch origin for this call is `root`.
     *
     * @param {MultiAddressLike} who
     * @param {bigint} newFree
     **/
    forceSetBalance: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        newFree: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceSetBalance";
            params: { who: MultiAddressLike; newFree: bigint };
          };
        }
      >
    >;

    /**
     * Adjust the total issuance in a saturating way.
     *
     * Can only be called by root and always needs a positive `delta`.
     *
     * # Example
     *
     * @param {PalletBalancesAdjustmentDirection} direction
     * @param {bigint} delta
     **/
    forceAdjustTotalIssuance: GenericTxCall<
      Rv,
      (
        direction: PalletBalancesAdjustmentDirection,
        delta: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "ForceAdjustTotalIssuance";
            params: {
              direction: PalletBalancesAdjustmentDirection;
              delta: bigint;
            };
          };
        }
      >
    >;

    /**
     * Burn the specified liquid free balance from the origin account.
     *
     * If the origin's account ends up below the existential deposit as a result
     * of the burn and `keep_alive` is false, the account will be reaped.
     *
     * Unlike sending funds to a _burn_ address, which merely makes the funds inaccessible,
     * this `burn` operation will reduce total issuance by the amount _burned_.
     *
     * @param {bigint} value
     * @param {boolean} keepAlive
     **/
    burn: GenericTxCall<
      Rv,
      (
        value: bigint,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Balances";
          palletCall: {
            name: "Burn";
            params: { value: bigint; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Vesting`'s transaction calls
   **/
  vesting: {
    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vest: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "Vest";
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     **/
    vestOther: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "VestOther";
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    vestedTransfer: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "VestedTransfer";
            params: {
              target: MultiAddressLike;
              schedule: PalletVestingVestingInfo;
            };
          };
        }
      >
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} target
     * @param {PalletVestingVestingInfo} schedule
     **/
    forceVestedTransfer: GenericTxCall<
      Rv,
      (
        source: MultiAddressLike,
        target: MultiAddressLike,
        schedule: PalletVestingVestingInfo,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "ForceVestedTransfer";
            params: {
              source: MultiAddressLike;
              target: MultiAddressLike;
              schedule: PalletVestingVestingInfo;
            };
          };
        }
      >
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     **/
    mergeSchedules: GenericTxCall<
      Rv,
      (
        schedule1Index: number,
        schedule2Index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "MergeSchedules";
            params: { schedule1Index: number; schedule2Index: number };
          };
        }
      >
    >;

    /**
     * Force remove a vesting schedule
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `target`: An account that has a vesting schedule
     * - `schedule_index`: The vesting schedule index that should be removed
     *
     * @param {MultiAddressLike} target
     * @param {number} scheduleIndex
     **/
    forceRemoveVestingSchedule: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        scheduleIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Vesting";
          palletCall: {
            name: "ForceRemoveVestingSchedule";
            params: { target: MultiAddressLike; scheduleIndex: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ContributionTokens`'s transaction calls
   **/
  contributionTokens: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      Rv,
      (
        id: number,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Create";
            params: { id: number; admin: MultiAddressLike; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      Rv,
      (
        id: number,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceCreate";
            params: {
              id: number;
              owner: MultiAddressLike;
              isSufficient: boolean;
              minBalance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * @param {number} id
     **/
    startDestroy: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "StartDestroy";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {number} id
     **/
    destroyAccounts: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "DestroyAccounts";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {number} id
     **/
    destroyApprovals: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "DestroyApprovals";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {number} id
     **/
    finishDestroy: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "FinishDestroy";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {number} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      Rv,
      (
        id: number,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Mint";
            params: {
              id: number;
              beneficiary: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Burn";
            params: { id: number; who: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      Rv,
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Transfer";
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {number} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        id: number,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "TransferKeepAlive";
            params: { id: number; target: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {number} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        id: number,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceTransfer";
            params: {
              id: number;
              source: MultiAddressLike;
              dest: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Freeze";
            params: { id: number; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Thaw";
            params: { id: number; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    freezeAsset: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "FreezeAsset";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    thawAsset: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ThawAsset";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      Rv,
      (
        id: number,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "TransferOwnership";
            params: { id: number; owner: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      Rv,
      (
        id: number,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "SetTeam";
            params: {
              id: number;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
            };
          };
        }
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "SetMetadata";
            params: {
              id: number;
              name: BytesLike;
              symbol: BytesLike;
              decimals: number;
            };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    clearMetadata: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ClearMetadata";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {number} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      Rv,
      (
        id: number,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceSetMetadata";
            params: {
              id: number;
              name: BytesLike;
              symbol: BytesLike;
              decimals: number;
              isFrozen: boolean;
            };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     **/
    forceClearMetadata: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceClearMetadata";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      Rv,
      (
        id: number,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceAssetStatus";
            params: {
              id: number;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        }
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      Rv,
      (
        id: number,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ApproveTransfer";
            params: { id: number; delegate: MultiAddressLike; amount: bigint };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      Rv,
      (
        id: number,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "CancelApproval";
            params: { id: number; delegate: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      Rv,
      (
        id: number,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "ForceCancelApproval";
            params: {
              id: number;
              owner: MultiAddressLike;
              delegate: MultiAddressLike;
            };
          };
        }
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      Rv,
      (
        id: number,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "TransferApproved";
            params: {
              id: number;
              owner: MultiAddressLike;
              destination: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     **/
    touch: GenericTxCall<
      Rv,
      (id: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Touch";
            params: { id: number };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      Rv,
      (
        id: number,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Refund";
            params: { id: number; allowBurn: boolean };
          };
        }
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {number} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      Rv,
      (
        id: number,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "SetMinBalance";
            params: { id: number; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "TouchOther";
            params: { id: number; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "RefundOther";
            params: { id: number; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {number} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      Rv,
      (
        id: number,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "Block";
            params: { id: number; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     *
     * @param {number} id
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        id: number,
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ContributionTokens";
          palletCall: {
            name: "TransferAll";
            params: { id: number; dest: MultiAddressLike; keepAlive: boolean };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ForeignAssets`'s transaction calls
   **/
  foreignAssets: {
    /**
     * Issue a new class of fungible assets from a public origin.
     *
     * This new asset class has no assets initially and its owner is the origin.
     *
     * The origin must conform to the configured `CreateOrigin` and have sufficient funds free.
     *
     * Funds of sender are reserved by `AssetDeposit`.
     *
     * Parameters:
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `admin`: The admin of this class of assets. The admin is the initial address of each
     * member of the asset class's admin team.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `Created` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} admin
     * @param {bigint} minBalance
     **/
    create: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        admin: MultiAddressLike,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Create";
            params: {
              id: StagingXcmV4Location;
              admin: MultiAddressLike;
              minBalance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Issue a new class of fungible assets from a privileged origin.
     *
     * This new asset class has no assets initially.
     *
     * The origin must conform to `ForceOrigin`.
     *
     * Unlike `create`, no funds are reserved.
     *
     * - `id`: The identifier of the new asset. This must not be currently in use to identify
     * an existing asset. If [`NextAssetId`] is set, then this must be equal to it.
     * - `owner`: The owner of this class of assets. The owner has full superuser permissions
     * over this asset, but may later change and configure the permissions using
     * `transfer_ownership` and `set_team`.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     *
     * Emits `ForceCreated` event when successful.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} owner
     * @param {boolean} isSufficient
     * @param {bigint} minBalance
     **/
    forceCreate: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        owner: MultiAddressLike,
        isSufficient: boolean,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceCreate";
            params: {
              id: StagingXcmV4Location;
              owner: MultiAddressLike;
              isSufficient: boolean;
              minBalance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Start the process of destroying a fungible asset class.
     *
     * `start_destroy` is the first in a series of extrinsics that should be called, to allow
     * destruction of an asset class.
     *
     * The origin must conform to `ForceOrigin` or must be `Signed` by the asset's `owner`.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * @param {StagingXcmV4Location} id
     **/
    startDestroy: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "StartDestroy";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Destroy all accounts associated with a given asset.
     *
     * `destroy_accounts` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all accounts. It will destroy `RemoveItemsLimit` accounts at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedAccounts` event.
     *
     * @param {StagingXcmV4Location} id
     **/
    destroyAccounts: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "DestroyAccounts";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Destroy all approvals associated with a given asset up to the max (T::RemoveItemsLimit).
     *
     * `destroy_approvals` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state.
     *
     * Due to weight restrictions, this function may need to be called multiple times to fully
     * destroy all approvals. It will destroy `RemoveItemsLimit` approvals at a time.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each call emits the `Event::DestroyedApprovals` event.
     *
     * @param {StagingXcmV4Location} id
     **/
    destroyApprovals: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "DestroyApprovals";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Complete destroying asset and unreserve currency.
     *
     * `finish_destroy` should only be called after `start_destroy` has been called, and the
     * asset is in a `Destroying` state. All accounts or approvals should be destroyed before
     * hand.
     *
     * - `id`: The identifier of the asset to be destroyed. This must identify an existing
     * asset.
     *
     * Each successful call emits the `Event::Destroyed` event.
     *
     * @param {StagingXcmV4Location} id
     **/
    finishDestroy: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "FinishDestroy";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Mint assets of a particular class.
     *
     * The origin must be Signed and the sender must be the Issuer of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount minted.
     * - `beneficiary`: The account to be credited with the minted assets.
     * - `amount`: The amount of the asset to be minted.
     *
     * Emits `Issued` event when successful.
     *
     * Weight: `O(1)`
     * Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} beneficiary
     * @param {bigint} amount
     **/
    mint: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        beneficiary: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Mint";
            params: {
              id: StagingXcmV4Location;
              beneficiary: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.
     *
     * Origin must be Signed and the sender should be the Manager of the asset `id`.
     *
     * Bails with `NoAccount` if the `who` is already dead.
     *
     * - `id`: The identifier of the asset to have some amount burned.
     * - `who`: The account to be debited from.
     * - `amount`: The maximum amount by which `who`'s balance should be reduced.
     *
     * Emits `Burned` with the actual amount burned. If this takes the balance to below the
     * minimum for the asset, then the amount burned is increased to take it to zero.
     *
     * Weight: `O(1)`
     * Modes: Post-existence of `who`; Pre & post Zombie-status of `who`.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     * @param {bigint} amount
     **/
    burn: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Burn";
            params: {
              id: StagingXcmV4Location;
              who: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transfer: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Transfer";
            params: {
              id: StagingXcmV4Location;
              target: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Move some assets from the sender account to another, keeping the sender account alive.
     *
     * Origin must be Signed.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `target`: The account to be credited.
     * - `amount`: The amount by which the sender's balance of assets should be reduced and
     * `target`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the sender balance above zero but below
     * the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of
     * `target`.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} target
     * @param {bigint} amount
     **/
    transferKeepAlive: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        target: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "TransferKeepAlive";
            params: {
              id: StagingXcmV4Location;
              target: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Move some assets from one account to another.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to have some amount transferred.
     * - `source`: The account to be debited.
     * - `dest`: The account to be credited.
     * - `amount`: The amount by which the `source`'s balance of assets should be reduced and
     * `dest`'s balance increased. The amount actually transferred may be slightly greater in
     * the case that the transfer would otherwise take the `source` balance above zero but
     * below the minimum balance. Must be greater than zero.
     *
     * Emits `Transferred` with the actual amount transferred. If this takes the source balance
     * to below the minimum for the asset, then the amount transferred is increased to take it
     * to zero.
     *
     * Weight: `O(1)`
     * Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of
     * `dest`.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} source
     * @param {MultiAddressLike} dest
     * @param {bigint} amount
     **/
    forceTransfer: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        source: MultiAddressLike,
        dest: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceTransfer";
            params: {
              id: StagingXcmV4Location;
              source: MultiAddressLike;
              dest: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` from an account `who`. `who`
     * must already exist as an entry in `Account`s of the asset. If you want to freeze an
     * account that does not have an entry, use `touch_other` first.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     **/
    freeze: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Freeze";
            params: { id: StagingXcmV4Location; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers to and from an account again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `who`: The account to be unfrozen.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     **/
    thaw: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Thaw";
            params: { id: StagingXcmV4Location; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers for the asset class.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     *
     * Emits `Frozen`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     **/
    freezeAsset: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "FreezeAsset";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Allow unprivileged transfers for the asset again.
     *
     * Origin must be Signed and the sender should be the Admin of the asset `id`.
     *
     * - `id`: The identifier of the asset to be thawed.
     *
     * Emits `Thawed`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     **/
    thawAsset: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ThawAsset";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Change the Owner of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     *
     * Emits `OwnerChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} owner
     **/
    transferOwnership: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        owner: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "TransferOwnership";
            params: { id: StagingXcmV4Location; owner: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Change the Issuer, Admin and Freezer of an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * - `id`: The identifier of the asset to be frozen.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     *
     * Emits `TeamChanged`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     **/
    setTeam: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "SetTeam";
            params: {
              id: StagingXcmV4Location;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
            };
          };
        }
      >
    >;

    /**
     * Set the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Funds of sender are reserved according to the formula:
     * `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into
     * account any already reserved funds.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "SetMetadata";
            params: {
              id: StagingXcmV4Location;
              name: BytesLike;
              symbol: BytesLike;
              decimals: number;
            };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be Signed and the sender should be the Owner of the asset `id`.
     *
     * Any deposit is freed for the asset owner.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     **/
    clearMetadata: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ClearMetadata";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Force the metadata for an asset to some value.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is left alone.
     *
     * - `id`: The identifier of the asset to update.
     * - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.
     * - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.
     * - `decimals`: The number of decimals this asset uses to represent one unit.
     *
     * Emits `MetadataSet`.
     *
     * Weight: `O(N + S)` where N and S are the length of the name and symbol respectively.
     *
     * @param {StagingXcmV4Location} id
     * @param {BytesLike} name
     * @param {BytesLike} symbol
     * @param {number} decimals
     * @param {boolean} isFrozen
     **/
    forceSetMetadata: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        name: BytesLike,
        symbol: BytesLike,
        decimals: number,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceSetMetadata";
            params: {
              id: StagingXcmV4Location;
              name: BytesLike;
              symbol: BytesLike;
              decimals: number;
              isFrozen: boolean;
            };
          };
        }
      >
    >;

    /**
     * Clear the metadata for an asset.
     *
     * Origin must be ForceOrigin.
     *
     * Any deposit is returned.
     *
     * - `id`: The identifier of the asset to clear.
     *
     * Emits `MetadataCleared`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     **/
    forceClearMetadata: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceClearMetadata";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Alter the attributes of a given asset.
     *
     * Origin must be `ForceOrigin`.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The new Owner of this asset.
     * - `issuer`: The new Issuer of this asset.
     * - `admin`: The new Admin of this asset.
     * - `freezer`: The new Freezer of this asset.
     * - `min_balance`: The minimum balance of this new asset that any single account must
     * have. If an account's balance is reduced below this, then it collapses to zero.
     * - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient
     * value to account for the state bloat associated with its balance storage. If set to
     * `true`, then non-zero balances may be stored without a `consumer` reference (and thus
     * an ED in the Balances pallet or whatever else is used to control user-account state
     * growth).
     * - `is_frozen`: Whether this asset class is frozen except for permissioned/admin
     * instructions.
     *
     * Emits `AssetStatusChanged` with the identity of the asset.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} issuer
     * @param {MultiAddressLike} admin
     * @param {MultiAddressLike} freezer
     * @param {bigint} minBalance
     * @param {boolean} isSufficient
     * @param {boolean} isFrozen
     **/
    forceAssetStatus: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        owner: MultiAddressLike,
        issuer: MultiAddressLike,
        admin: MultiAddressLike,
        freezer: MultiAddressLike,
        minBalance: bigint,
        isSufficient: boolean,
        isFrozen: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceAssetStatus";
            params: {
              id: StagingXcmV4Location;
              owner: MultiAddressLike;
              issuer: MultiAddressLike;
              admin: MultiAddressLike;
              freezer: MultiAddressLike;
              minBalance: bigint;
              isSufficient: boolean;
              isFrozen: boolean;
            };
          };
        }
      >
    >;

    /**
     * Approve an amount of asset for transfer by a delegated third-party account.
     *
     * Origin must be Signed.
     *
     * Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account
     * for the purpose of holding the approval. If some non-zero amount of assets is already
     * approved from signing account to `delegate`, then it is topped up or unreserved to
     * meet the right value.
     *
     * NOTE: The signing account does not need to own `amount` of assets at the point of
     * making this call.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account to delegate permission to transfer asset.
     * - `amount`: The amount of asset that may be transferred by `delegate`. If there is
     * already an approval in place, then this acts additively.
     *
     * Emits `ApprovedTransfer` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} delegate
     * @param {bigint} amount
     **/
    approveTransfer: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        delegate: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ApproveTransfer";
            params: {
              id: StagingXcmV4Location;
              delegate: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be Signed and there must be an approval in place between signer and
     * `delegate`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} delegate
     **/
    cancelApproval: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "CancelApproval";
            params: { id: StagingXcmV4Location; delegate: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Cancel all of some asset approved for delegated transfer by a third-party account.
     *
     * Origin must be either ForceOrigin or Signed origin with the signer being the Admin
     * account of the asset `id`.
     *
     * Unreserves any deposit previously reserved by `approve_transfer` for the approval.
     *
     * - `id`: The identifier of the asset.
     * - `delegate`: The account delegated permission to transfer asset.
     *
     * Emits `ApprovalCancelled` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} delegate
     **/
    forceCancelApproval: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        owner: MultiAddressLike,
        delegate: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "ForceCancelApproval";
            params: {
              id: StagingXcmV4Location;
              owner: MultiAddressLike;
              delegate: MultiAddressLike;
            };
          };
        }
      >
    >;

    /**
     * Transfer some asset balance from a previously delegated account to some third-party
     * account.
     *
     * Origin must be Signed and there must be an approval in place by the `owner` to the
     * signer.
     *
     * If the entire amount approved for transfer is transferred, then any deposit previously
     * reserved by `approve_transfer` is unreserved.
     *
     * - `id`: The identifier of the asset.
     * - `owner`: The account which previously approved for a transfer of at least `amount` and
     * from which the asset balance will be withdrawn.
     * - `destination`: The account to which the asset balance of `amount` will be transferred.
     * - `amount`: The amount of assets to transfer.
     *
     * Emits `TransferredApproved` on success.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} owner
     * @param {MultiAddressLike} destination
     * @param {bigint} amount
     **/
    transferApproved: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        owner: MultiAddressLike,
        destination: MultiAddressLike,
        amount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "TransferApproved";
            params: {
              id: StagingXcmV4Location;
              owner: MultiAddressLike;
              destination: MultiAddressLike;
              amount: bigint;
            };
          };
        }
      >
    >;

    /**
     * Create an asset account for non-provider assets.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed; the signer account must have sufficient funds for a deposit
     * to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {StagingXcmV4Location} id
     **/
    touch: GenericTxCall<
      Rv,
      (id: StagingXcmV4Location) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Touch";
            params: { id: StagingXcmV4Location };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of an asset account or a consumer reference (if any) of an
     * account.
     *
     * The origin must be Signed.
     *
     * - `id`: The identifier of the asset for which the caller would like the deposit
     * refunded.
     * - `allow_burn`: If `true` then assets may be destroyed in order to complete the refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {StagingXcmV4Location} id
     * @param {boolean} allowBurn
     **/
    refund: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        allowBurn: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Refund";
            params: { id: StagingXcmV4Location; allowBurn: boolean };
          };
        }
      >
    >;

    /**
     * Sets the minimum balance of an asset.
     *
     * Only works if there aren't any accounts that are holding the asset or if
     * the new value of `min_balance` is less than the old one.
     *
     * Origin must be Signed and the sender has to be the Owner of the
     * asset `id`.
     *
     * - `id`: The identifier of the asset.
     * - `min_balance`: The new value of `min_balance`.
     *
     * Emits `AssetMinBalanceChanged` event when successful.
     *
     * @param {StagingXcmV4Location} id
     * @param {bigint} minBalance
     **/
    setMinBalance: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        minBalance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "SetMinBalance";
            params: { id: StagingXcmV4Location; minBalance: bigint };
          };
        }
      >
    >;

    /**
     * Create an asset account for `who`.
     *
     * A deposit will be taken from the signer account.
     *
     * - `origin`: Must be Signed by `Freezer` or `Admin` of the asset `id`; the signer account
     * must have sufficient funds for a deposit to be taken.
     * - `id`: The identifier of the asset for the account to be created.
     * - `who`: The account to be created.
     *
     * Emits `Touched` event when successful.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     **/
    touchOther: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "TouchOther";
            params: { id: StagingXcmV4Location; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Return the deposit (if any) of a target asset account. Useful if you are the depositor.
     *
     * The origin must be Signed and either the account owner, depositor, or asset `Admin`. In
     * order to burn a non-zero balance of the asset, the caller must be the account and should
     * use `refund`.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `who`: The account to refund.
     *
     * Emits `Refunded` event when successful.
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     **/
    refundOther: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "RefundOther";
            params: { id: StagingXcmV4Location; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Disallow further unprivileged transfers of an asset `id` to and from an account `who`.
     *
     * Origin must be Signed and the sender should be the Freezer of the asset `id`.
     *
     * - `id`: The identifier of the account's asset.
     * - `who`: The account to be unblocked.
     *
     * Emits `Blocked`.
     *
     * Weight: `O(1)`
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} who
     **/
    block: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        who: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "Block";
            params: { id: StagingXcmV4Location; who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Transfer the entire transferable balance from the caller asset account.
     *
     * NOTE: This function only attempts to transfer _transferable_ balances. This means that
     * any held, frozen, or minimum balance (when `keep_alive` is `true`), will not be
     * transferred by this function. To ensure that this function results in a killed account,
     * you might need to prepare the account by removing any reference counters, storage
     * deposits, etc...
     *
     * The dispatch origin of this call must be Signed.
     *
     * - `id`: The identifier of the asset for the account holding a deposit.
     * - `dest`: The recipient of the transfer.
     * - `keep_alive`: A boolean to determine if the `transfer_all` operation should send all
     * of the funds the asset account has, causing the sender asset account to be killed
     * (false), or transfer everything except at least the minimum balance, which will
     * guarantee to keep the sender asset account alive (true).
     *
     * @param {StagingXcmV4Location} id
     * @param {MultiAddressLike} dest
     * @param {boolean} keepAlive
     **/
    transferAll: GenericTxCall<
      Rv,
      (
        id: StagingXcmV4Location,
        dest: MultiAddressLike,
        keepAlive: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ForeignAssets";
          palletCall: {
            name: "TransferAll";
            params: {
              id: StagingXcmV4Location;
              dest: MultiAddressLike;
              keepAlive: boolean;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Dispenser`'s transaction calls
   **/
  dispenser: {
    /**
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     **/
    dispense: GenericTxCall<
      Rv,
      (jwt: JwtCompactFrameTokenUntrustedToken) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Dispenser";
          palletCall: {
            name: "Dispense";
            params: { jwt: JwtCompactFrameTokenUntrustedToken };
          };
        }
      >
    >;

    /**
     *
     * @param {bigint} amount
     **/
    setDispenseAmount: GenericTxCall<
      Rv,
      (amount: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Dispenser";
          palletCall: {
            name: "SetDispenseAmount";
            params: { amount: bigint };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Session`'s transaction calls
   **/
  session: {
    /**
     * Sets the session key(s) of the function caller to `keys`.
     * Allows an account to set its session key prior to becoming a validator.
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be signed.
     *
     * ## Complexity
     * - `O(1)`. Actual cost depends on the number of length of `T::Keys::key_ids()` which is
     * fixed.
     *
     * @param {PolimecRuntimeSessionKeys} keys
     * @param {BytesLike} proof
     **/
    setKeys: GenericTxCall<
      Rv,
      (
        keys: PolimecRuntimeSessionKeys,
        proof: BytesLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Session";
          palletCall: {
            name: "SetKeys";
            params: { keys: PolimecRuntimeSessionKeys; proof: BytesLike };
          };
        }
      >
    >;

    /**
     * Removes any session key(s) of the function caller.
     *
     * This doesn't take effect until the next session.
     *
     * The dispatch origin of this function must be Signed and the account must be either be
     * convertible to a validator ID using the chain's typical addressing system (this usually
     * means being a controller account) or directly convertible into a validator ID (which
     * usually means being a stash account).
     *
     * ## Complexity
     * - `O(1)` in number of key types. Actual cost depends on the number of length of
     * `T::Keys::key_ids()` which is fixed.
     *
     **/
    purgeKeys: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Session";
          palletCall: {
            name: "PurgeKeys";
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ParachainStaking`'s transaction calls
   **/
  parachainStaking: {
    /**
     * Set the expectations for total staked. These expectations determine the issuance for
     * the round according to logic in `fn compute_issuance`
     *
     * @param {{min: bigint, ideal: bigint, max: bigint}} expectations
     **/
    setStakingExpectations: GenericTxCall<
      Rv,
      (expectations: {
        min: bigint;
        ideal: bigint;
        max: bigint;
      }) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetStakingExpectations";
            params: {
              expectations: { min: bigint; ideal: bigint; max: bigint };
            };
          };
        }
      >
    >;

    /**
     * Set the annual inflation rate to derive per-round inflation
     *
     * @param {{min: Perbill, ideal: Perbill, max: Perbill}} schedule
     **/
    setInflation: GenericTxCall<
      Rv,
      (schedule: {
        min: Perbill;
        ideal: Perbill;
        max: Perbill;
      }) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetInflation";
            params: {
              schedule: { min: Perbill; ideal: Perbill; max: Perbill };
            };
          };
        }
      >
    >;

    /**
     * Set the account that will hold funds set aside for parachain bond
     *
     * @param {AccountId32Like} new_
     **/
    setParachainBondAccount: GenericTxCall<
      Rv,
      (new_: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetParachainBondAccount";
            params: { new: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Set the percent of inflation set aside for parachain bond
     *
     * @param {Percent} new_
     **/
    setParachainBondReservePercent: GenericTxCall<
      Rv,
      (new_: Percent) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetParachainBondReservePercent";
            params: { new: Percent };
          };
        }
      >
    >;

    /**
     * Set the total number of collator candidates selected per round
     * - changes are not applied until the start of the next round
     *
     * @param {number} new_
     **/
    setTotalSelected: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetTotalSelected";
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Set the commission for all collators
     *
     * @param {Perbill} new_
     **/
    setCollatorCommission: GenericTxCall<
      Rv,
      (new_: Perbill) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetCollatorCommission";
            params: { new: Perbill };
          };
        }
      >
    >;

    /**
     * Set blocks per round
     * - if called with `new` less than length of current round, will transition immediately
     * in the next block
     * - also updates per-round inflation config
     *
     * @param {number} new_
     **/
    setBlocksPerRound: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetBlocksPerRound";
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Join the set of collator candidates
     *
     * @param {bigint} bond
     * @param {number} candidateCount
     **/
    joinCandidates: GenericTxCall<
      Rv,
      (
        bond: bigint,
        candidateCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "JoinCandidates";
            params: { bond: bigint; candidateCount: number };
          };
        }
      >
    >;

    /**
     * Request to leave the set of candidates. If successful, the account is immediately
     * removed from the candidate pool to prevent selection as a collator.
     *
     * @param {number} candidateCount
     **/
    scheduleLeaveCandidates: GenericTxCall<
      Rv,
      (candidateCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ScheduleLeaveCandidates";
            params: { candidateCount: number };
          };
        }
      >
    >;

    /**
     * Execute leave candidates request
     *
     * @param {AccountId32Like} candidate
     * @param {number} candidateDelegationCount
     **/
    executeLeaveCandidates: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        candidateDelegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ExecuteLeaveCandidates";
            params: {
              candidate: AccountId32Like;
              candidateDelegationCount: number;
            };
          };
        }
      >
    >;

    /**
     * Cancel open request to leave candidates
     * - only callable by collator account
     * - result upon successful call is the candidate is active in the candidate pool
     *
     * @param {number} candidateCount
     **/
    cancelLeaveCandidates: GenericTxCall<
      Rv,
      (candidateCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "CancelLeaveCandidates";
            params: { candidateCount: number };
          };
        }
      >
    >;

    /**
     * Temporarily leave the set of collator candidates without unbonding
     *
     **/
    goOffline: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "GoOffline";
          };
        }
      >
    >;

    /**
     * Rejoin the set of collator candidates if previously had called `go_offline`
     *
     **/
    goOnline: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "GoOnline";
          };
        }
      >
    >;

    /**
     * Increase collator candidate self bond by `more`
     *
     * @param {bigint} more
     **/
    candidateBondMore: GenericTxCall<
      Rv,
      (more: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "CandidateBondMore";
            params: { more: bigint };
          };
        }
      >
    >;

    /**
     * Request by collator candidate to decrease self bond by `less`
     *
     * @param {bigint} less
     **/
    scheduleCandidateBondLess: GenericTxCall<
      Rv,
      (less: bigint) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ScheduleCandidateBondLess";
            params: { less: bigint };
          };
        }
      >
    >;

    /**
     * Execute pending request to adjust the collator candidate self bond
     *
     * @param {AccountId32Like} candidate
     **/
    executeCandidateBondLess: GenericTxCall<
      Rv,
      (candidate: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ExecuteCandidateBondLess";
            params: { candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Cancel pending request to adjust the collator candidate self bond
     *
     **/
    cancelCandidateBondLess: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "CancelCandidateBondLess";
          };
        }
      >
    >;

    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     *
     * @param {AccountId32Like} candidate
     * @param {bigint} amount
     * @param {number} candidateDelegationCount
     * @param {number} delegationCount
     **/
    delegate: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        amount: bigint,
        candidateDelegationCount: number,
        delegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "Delegate";
            params: {
              candidate: AccountId32Like;
              amount: bigint;
              candidateDelegationCount: number;
              delegationCount: number;
            };
          };
        }
      >
    >;

    /**
     * If caller is not a delegator and not a collator, then join the set of delegators
     * If caller is a delegator, then makes delegation to change their delegation state
     * Sets the auto-compound config for the delegation
     *
     * @param {AccountId32Like} candidate
     * @param {bigint} amount
     * @param {Percent} autoCompound
     * @param {number} candidateDelegationCount
     * @param {number} candidateAutoCompoundingDelegationCount
     * @param {number} delegationCount
     **/
    delegateWithAutoCompound: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        amount: bigint,
        autoCompound: Percent,
        candidateDelegationCount: number,
        candidateAutoCompoundingDelegationCount: number,
        delegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "DelegateWithAutoCompound";
            params: {
              candidate: AccountId32Like;
              amount: bigint;
              autoCompound: Percent;
              candidateDelegationCount: number;
              candidateAutoCompoundingDelegationCount: number;
              delegationCount: number;
            };
          };
        }
      >
    >;

    /**
     * DEPRECATED use batch util with schedule_revoke_delegation for all delegations
     * Request to leave the set of delegators. If successful, the caller is scheduled to be
     * allowed to exit via a [DelegationAction::Revoke] towards all existing delegations.
     * Success forbids future delegation requests until the request is invoked or cancelled.
     *
     **/
    scheduleLeaveDelegators: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ScheduleLeaveDelegators";
          };
        }
      >
    >;

    /**
     * DEPRECATED use batch util with execute_delegation_request for all delegations
     * Execute the right to exit the set of delegators and revoke all ongoing delegations.
     *
     * @param {AccountId32Like} delegator
     * @param {number} delegationCount
     **/
    executeLeaveDelegators: GenericTxCall<
      Rv,
      (
        delegator: AccountId32Like,
        delegationCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ExecuteLeaveDelegators";
            params: { delegator: AccountId32Like; delegationCount: number };
          };
        }
      >
    >;

    /**
     * DEPRECATED use batch util with cancel_delegation_request for all delegations
     * Cancel a pending request to exit the set of delegators. Success clears the pending exit
     * request (thereby resetting the delay upon another `leave_delegators` call).
     *
     **/
    cancelLeaveDelegators: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "CancelLeaveDelegators";
          };
        }
      >
    >;

    /**
     * Request to revoke an existing delegation. If successful, the delegation is scheduled
     * to be allowed to be revoked via the `execute_delegation_request` extrinsic.
     * The delegation receives no rewards for the rounds while a revoke is pending.
     * A revoke may not be performed if any other scheduled request is pending.
     *
     * @param {AccountId32Like} collator
     **/
    scheduleRevokeDelegation: GenericTxCall<
      Rv,
      (collator: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ScheduleRevokeDelegation";
            params: { collator: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Bond more for delegators wrt a specific collator candidate.
     *
     * @param {AccountId32Like} candidate
     * @param {bigint} more
     **/
    delegatorBondMore: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        more: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "DelegatorBondMore";
            params: { candidate: AccountId32Like; more: bigint };
          };
        }
      >
    >;

    /**
     * Request bond less for delegators wrt a specific collator candidate. The delegation's
     * rewards for rounds while the request is pending use the reduced bonded amount.
     * A bond less may not be performed if any other scheduled request is pending.
     *
     * @param {AccountId32Like} candidate
     * @param {bigint} less
     **/
    scheduleDelegatorBondLess: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        less: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ScheduleDelegatorBondLess";
            params: { candidate: AccountId32Like; less: bigint };
          };
        }
      >
    >;

    /**
     * Execute pending request to change an existing delegation
     *
     * @param {AccountId32Like} delegator
     * @param {AccountId32Like} candidate
     **/
    executeDelegationRequest: GenericTxCall<
      Rv,
      (
        delegator: AccountId32Like,
        candidate: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "ExecuteDelegationRequest";
            params: { delegator: AccountId32Like; candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Cancel request to change an existing delegation.
     *
     * @param {AccountId32Like} candidate
     **/
    cancelDelegationRequest: GenericTxCall<
      Rv,
      (candidate: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "CancelDelegationRequest";
            params: { candidate: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Sets the auto-compounding reward percentage for a delegation.
     *
     * @param {AccountId32Like} candidate
     * @param {Percent} value
     * @param {number} candidateAutoCompoundingDelegationCountHint
     * @param {number} delegationCountHint
     **/
    setAutoCompound: GenericTxCall<
      Rv,
      (
        candidate: AccountId32Like,
        value: Percent,
        candidateAutoCompoundingDelegationCountHint: number,
        delegationCountHint: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "SetAutoCompound";
            params: {
              candidate: AccountId32Like;
              value: Percent;
              candidateAutoCompoundingDelegationCountHint: number;
              delegationCountHint: number;
            };
          };
        }
      >
    >;

    /**
     * Hotfix to remove existing empty entries for candidates that have left.
     *
     * @param {Array<AccountId32Like>} candidates
     **/
    hotfixRemoveDelegationRequestsExitedCandidates: GenericTxCall<
      Rv,
      (candidates: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ParachainStaking";
          palletCall: {
            name: "HotfixRemoveDelegationRequestsExitedCandidates";
            params: { candidates: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `XcmpQueue`'s transaction calls
   **/
  xcmpQueue: {
    /**
     * Suspends all XCM executions for the XCMP queue, regardless of the sender's origin.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    suspendXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "XcmpQueue";
          palletCall: {
            name: "SuspendXcmExecution";
          };
        }
      >
    >;

    /**
     * Resumes all XCM executions for the XCMP queue.
     *
     * Note that this function doesn't change the status of the in/out bound channels.
     *
     * - `origin`: Must pass `ControllerOrigin`.
     *
     **/
    resumeXcmExecution: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "XcmpQueue";
          palletCall: {
            name: "ResumeXcmExecution";
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue for the other side to be
     * told to suspend their sending.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.suspend_value`
     *
     * @param {number} new_
     **/
    updateSuspendThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "XcmpQueue";
          palletCall: {
            name: "UpdateSuspendThreshold";
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which must be in the queue after which we drop any
     * further messages from the channel.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.drop_threshold`
     *
     * @param {number} new_
     **/
    updateDropThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "XcmpQueue";
          palletCall: {
            name: "UpdateDropThreshold";
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Overwrites the number of pages which the queue must be reduced to before it signals
     * that message sending may recommence after it has been suspended.
     *
     * - `origin`: Must pass `Root`.
     * - `new`: Desired value for `QueueConfigData.resume_threshold`
     *
     * @param {number} new_
     **/
    updateResumeThreshold: GenericTxCall<
      Rv,
      (new_: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "XcmpQueue";
          palletCall: {
            name: "UpdateResumeThreshold";
            params: { new: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `PolkadotXcm`'s transaction calls
   **/
  polkadotXcm: {
    /**
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedXcm} message
     **/
    send: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        message: XcmVersionedXcm,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "Send";
            params: { dest: XcmVersionedLocation; message: XcmVersionedXcm };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * **This function is deprecated: Use `limited_teleport_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    teleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "TeleportAssets";
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * **This function is deprecated: Use `limited_reserve_transfer_assets` instead.**
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`. The weight limit for fees is not provided and thus is unlimited,
     * with all fees taken as needed from the asset.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     **/
    reserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ReserveTransferAssets";
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
            };
          };
        }
      >
    >;

    /**
     * Execute an XCM message from a local, signed, origin.
     *
     * An event is deposited indicating whether `msg` could be executed completely or only
     * partially.
     *
     * No more than `max_weight` will be used in its attempted execution. If this is less than
     * the maximum amount of weight that the message could take to be executed, then no
     * execution attempt will be made.
     *
     * @param {XcmVersionedXcm} message
     * @param {SpWeightsWeightV2Weight} maxWeight
     **/
    execute: GenericTxCall<
      Rv,
      (
        message: XcmVersionedXcm,
        maxWeight: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "Execute";
            params: {
              message: XcmVersionedXcm;
              maxWeight: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Extoll that a particular destination can be communicated with through a particular
     * version of XCM.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The destination that is being described.
     * - `xcm_version`: The latest version of XCM that `location` supports.
     *
     * @param {StagingXcmV5Location} location
     * @param {number} version
     **/
    forceXcmVersion: GenericTxCall<
      Rv,
      (
        location: StagingXcmV5Location,
        version: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ForceXcmVersion";
            params: { location: StagingXcmV5Location; version: number };
          };
        }
      >
    >;

    /**
     * Set a safe XCM version (the version that XCM should be encoded with if the most recent
     * version a destination can accept is unknown).
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `maybe_xcm_version`: The default XCM encoding version, or `None` to disable.
     *
     * @param {number | undefined} maybeXcmVersion
     **/
    forceDefaultXcmVersion: GenericTxCall<
      Rv,
      (maybeXcmVersion: number | undefined) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ForceDefaultXcmVersion";
            params: { maybeXcmVersion: number | undefined };
          };
        }
      >
    >;

    /**
     * Ask a location to notify us regarding their XCM version and any changes to it.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we should subscribe for XCM version notifications.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceSubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ForceSubscribeVersionNotify";
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Require that a particular destination should no longer notify us regarding any XCM
     * version changes.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `location`: The location to which we are currently subscribed for XCM version
     * notifications which we no longer desire.
     *
     * @param {XcmVersionedLocation} location
     **/
    forceUnsubscribeVersionNotify: GenericTxCall<
      Rv,
      (location: XcmVersionedLocation) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ForceUnsubscribeVersionNotify";
            params: { location: XcmVersionedLocation };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve.
     *
     * `assets` must have same reserve location and may not be teleportable to `dest`.
     * - `assets` have local reserve: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `assets` have destination reserve: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `assets` have remote reserve: burn local assets, forward XCM to reserve chain to move
     * reserves from this chain's SA to `dest` chain's SA, and forward another XCM to `dest`
     * to mint and deposit reserve-based assets to `beneficiary`.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedReserveTransferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "LimitedReserveTransferAssets";
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Teleport some assets from the local chain to some destination chain.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item`, up to enough to pay for `weight_limit` of weight. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` chain.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    limitedTeleportAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "LimitedTeleportAssets";
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Set or unset the global suspension state of the XCM executor.
     *
     * - `origin`: Must be an origin specified by AdminOrigin.
     * - `suspended`: `true` to suspend, `false` to resume.
     *
     * @param {boolean} suspended
     **/
    forceSuspension: GenericTxCall<
      Rv,
      (suspended: boolean) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ForceSuspension";
            params: { suspended: boolean };
          };
        }
      >
    >;

    /**
     * Transfer some assets from the local chain to the destination chain through their local,
     * destination or remote reserve, or through teleports.
     *
     * Fee payment on the destination side is made from the asset in the `assets` vector of
     * index `fee_asset_item` (hence referred to as `fees`), up to enough to pay for
     * `weight_limit` of weight. If more weight is needed than `weight_limit`, then the
     * operation will fail and the sent assets may be at risk.
     *
     * `assets` (excluding `fees`) must have same reserve location or otherwise be teleportable
     * to `dest`, no limitations imposed on `fees`.
     * - for local reserve: transfer assets to sovereign account of destination chain and
     * forward a notification XCM to `dest` to mint and deposit reserve-based assets to
     * `beneficiary`.
     * - for destination reserve: burn local assets and forward a notification to `dest` chain
     * to withdraw the reserve assets from this chain's sovereign account and deposit them
     * to `beneficiary`.
     * - for remote reserve: burn local assets, forward XCM to reserve chain to move reserves
     * from this chain's SA to `dest` chain's SA, and forward another XCM to `dest` to mint
     * and deposit reserve-based assets to `beneficiary`.
     * - for teleports: burn local assets and forward XCM to `dest` chain to mint/teleport
     * assets and deposit them to `beneficiary`.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `X2(Parent,
     * Parachain(..))` to send from parachain to parachain, or `X1(Parachain(..))` to send
     * from relay to parachain.
     * - `beneficiary`: A beneficiary location for the assets in the context of `dest`. Will
     * generally be an `AccountId32` value.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `fee_asset_item`: The index into `assets` of the item which should be used to pay
     * fees.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedLocation} beneficiary
     * @param {XcmVersionedAssets} assets
     * @param {number} feeAssetItem
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssets: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        beneficiary: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        feeAssetItem: number,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "TransferAssets";
            params: {
              dest: XcmVersionedLocation;
              beneficiary: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              feeAssetItem: number;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Claims assets trapped on this pallet because of leftover assets during XCM execution.
     *
     * - `origin`: Anyone can call this extrinsic.
     * - `assets`: The exact assets that were trapped. Use the version to specify what version
     * was the latest when they were trapped.
     * - `beneficiary`: The location/account where the claimed assets will be deposited.
     *
     * @param {XcmVersionedAssets} assets
     * @param {XcmVersionedLocation} beneficiary
     **/
    claimAssets: GenericTxCall<
      Rv,
      (
        assets: XcmVersionedAssets,
        beneficiary: XcmVersionedLocation,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "ClaimAssets";
            params: {
              assets: XcmVersionedAssets;
              beneficiary: XcmVersionedLocation;
            };
          };
        }
      >
    >;

    /**
     * Transfer assets from the local chain to the destination chain using explicit transfer
     * types for assets and fees.
     *
     * `assets` must have same reserve location or may be teleportable to `dest`. Caller must
     * provide the `assets_transfer_type` to be used for `assets`:
     * - `TransferType::LocalReserve`: transfer assets to sovereign account of destination
     * chain and forward a notification XCM to `dest` to mint and deposit reserve-based
     * assets to `beneficiary`.
     * - `TransferType::DestinationReserve`: burn local assets and forward a notification to
     * `dest` chain to withdraw the reserve assets from this chain's sovereign account and
     * deposit them to `beneficiary`.
     * - `TransferType::RemoteReserve(reserve)`: burn local assets, forward XCM to `reserve`
     * chain to move reserves from this chain's SA to `dest` chain's SA, and forward another
     * XCM to `dest` to mint and deposit reserve-based assets to `beneficiary`. Typically
     * the remote `reserve` is Asset Hub.
     * - `TransferType::Teleport`: burn local assets and forward XCM to `dest` chain to
     * mint/teleport assets and deposit them to `beneficiary`.
     *
     * On the destination chain, as well as any intermediary hops, `BuyExecution` is used to
     * buy execution using transferred `assets` identified by `remote_fees_id`.
     * Make sure enough of the specified `remote_fees_id` asset is included in the given list
     * of `assets`. `remote_fees_id` should be enough to pay for `weight_limit`. If more weight
     * is needed than `weight_limit`, then the operation will fail and the sent assets may be
     * at risk.
     *
     * `remote_fees_id` may use different transfer type than rest of `assets` and can be
     * specified through `fees_transfer_type`.
     *
     * The caller needs to specify what should happen to the transferred assets once they reach
     * the `dest` chain. This is done through the `custom_xcm_on_dest` parameter, which
     * contains the instructions to execute on `dest` as a final step.
     * This is usually as simple as:
     * `Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])`,
     * but could be something more exotic like sending the `assets` even further.
     *
     * - `origin`: Must be capable of withdrawing the `assets` and executing XCM.
     * - `dest`: Destination context for the assets. Will typically be `[Parent,
     * Parachain(..)]` to send from parachain to parachain, or `[Parachain(..)]` to send from
     * relay to parachain, or `(parents: 2, (GlobalConsensus(..), ..))` to send from
     * parachain across a bridge to another ecosystem destination.
     * - `assets`: The assets to be withdrawn. This should include the assets used to pay the
     * fee on the `dest` (and possibly reserve) chains.
     * - `assets_transfer_type`: The XCM `TransferType` used to transfer the `assets`.
     * - `remote_fees_id`: One of the included `assets` to be used to pay fees.
     * - `fees_transfer_type`: The XCM `TransferType` used to transfer the `fees` assets.
     * - `custom_xcm_on_dest`: The XCM to be executed on `dest` chain as the last step of the
     * transfer, which also determines what happens to the assets on the destination chain.
     * - `weight_limit`: The remote-side weight limit, if any, for the XCM fee purchase.
     *
     * @param {XcmVersionedLocation} dest
     * @param {XcmVersionedAssets} assets
     * @param {StagingXcmExecutorAssetTransferTransferType} assetsTransferType
     * @param {XcmVersionedAssetId} remoteFeesId
     * @param {StagingXcmExecutorAssetTransferTransferType} feesTransferType
     * @param {XcmVersionedXcm} customXcmOnDest
     * @param {XcmV3WeightLimit} weightLimit
     **/
    transferAssetsUsingTypeAndThen: GenericTxCall<
      Rv,
      (
        dest: XcmVersionedLocation,
        assets: XcmVersionedAssets,
        assetsTransferType: StagingXcmExecutorAssetTransferTransferType,
        remoteFeesId: XcmVersionedAssetId,
        feesTransferType: StagingXcmExecutorAssetTransferTransferType,
        customXcmOnDest: XcmVersionedXcm,
        weightLimit: XcmV3WeightLimit,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "PolkadotXcm";
          palletCall: {
            name: "TransferAssetsUsingTypeAndThen";
            params: {
              dest: XcmVersionedLocation;
              assets: XcmVersionedAssets;
              assetsTransferType: StagingXcmExecutorAssetTransferTransferType;
              remoteFeesId: XcmVersionedAssetId;
              feesTransferType: StagingXcmExecutorAssetTransferTransferType;
              customXcmOnDest: XcmVersionedXcm;
              weightLimit: XcmV3WeightLimit;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `CumulusXcm`'s transaction calls
   **/
  cumulusXcm: {
    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `MessageQueue`'s transaction calls
   **/
  messageQueue: {
    /**
     * Remove a page which has no more messages remaining to be processed or is stale.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} pageIndex
     **/
    reapPage: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        pageIndex: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "MessageQueue";
          palletCall: {
            name: "ReapPage";
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              pageIndex: number;
            };
          };
        }
      >
    >;

    /**
     * Execute an overweight message.
     *
     * Temporary processing errors will be propagated whereas permanent errors are treated
     * as success condition.
     *
     * - `origin`: Must be `Signed`.
     * - `message_origin`: The origin from which the message to be executed arrived.
     * - `page`: The page in the queue in which the message to be executed is sitting.
     * - `index`: The index into the queue of the message to be executed.
     * - `weight_limit`: The maximum amount of weight allowed to be consumed in the execution
     * of the message.
     *
     * Benchmark complexity considerations: O(index + weight_limit).
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} messageOrigin
     * @param {number} page
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} weightLimit
     **/
    executeOverweight: GenericTxCall<
      Rv,
      (
        messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin,
        page: number,
        index: number,
        weightLimit: SpWeightsWeightV2Weight,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "MessageQueue";
          palletCall: {
            name: "ExecuteOverweight";
            params: {
              messageOrigin: CumulusPrimitivesCoreAggregateMessageOrigin;
              page: number;
              index: number;
              weightLimit: SpWeightsWeightV2Weight;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Treasury`'s transaction calls
   **/
  treasury: {
    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least `amount`.
     *
     * ### Details
     * NOTE: For record-keeping purposes, the proposer is deemed to be equivalent to the
     * beneficiary.
     *
     * ### Parameters
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The destination account for the transfer.
     *
     * ## Events
     *
     * Emits [`Event::SpendApproved`] if successful.
     *
     * @param {bigint} amount
     * @param {MultiAddressLike} beneficiary
     **/
    spendLocal: GenericTxCall<
      Rv,
      (
        amount: bigint,
        beneficiary: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "SpendLocal";
            params: { amount: bigint; beneficiary: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Force a previously approved proposal to be removed from the approval queue.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * The original deposit will no longer be returned.
     *
     * ### Parameters
     * - `proposal_id`: The index of a proposal
     *
     * ### Complexity
     * - O(A) where `A` is the number of approvals
     *
     * ### Errors
     * - [`Error::ProposalNotApproved`]: The `proposal_id` supplied was not found in the
     * approval queue, i.e., the proposal has not been approved. This could also mean the
     * proposal does not exist altogether, thus there is no way it would have been approved
     * in the first place.
     *
     * @param {number} proposalId
     **/
    removeApproval: GenericTxCall<
      Rv,
      (proposalId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "RemoveApproval";
            params: { proposalId: number };
          };
        }
      >
    >;

    /**
     * Propose and approve a spend of treasury funds.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::SpendOrigin`] with the `Success` value being at least
     * `amount` of `asset_kind` in the native asset. The amount of `asset_kind` is converted
     * for assertion using the [`Config::BalanceConverter`].
     *
     * ## Details
     *
     * Create an approved spend for transferring a specific `amount` of `asset_kind` to a
     * designated beneficiary. The spend must be claimed using the `payout` dispatchable within
     * the [`Config::PayoutPeriod`].
     *
     * ### Parameters
     * - `asset_kind`: An indicator of the specific asset class to be spent.
     * - `amount`: The amount to be transferred from the treasury to the `beneficiary`.
     * - `beneficiary`: The beneficiary of the spend.
     * - `valid_from`: The block number from which the spend can be claimed. It can refer to
     * the past if the resulting spend has not yet expired according to the
     * [`Config::PayoutPeriod`]. If `None`, the spend can be claimed immediately after
     * approval.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendApproved`] if successful.
     *
     * @param {[]} assetKind
     * @param {bigint} amount
     * @param {AccountId32Like} beneficiary
     * @param {number | undefined} validFrom
     **/
    spend: GenericTxCall<
      Rv,
      (
        assetKind: [],
        amount: bigint,
        beneficiary: AccountId32Like,
        validFrom: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "Spend";
            params: {
              assetKind: [];
              amount: bigint;
              beneficiary: AccountId32Like;
              validFrom: number | undefined;
            };
          };
        }
      >
    >;

    /**
     * Claim a spend.
     *
     * ## Dispatch Origin
     *
     * Must be signed
     *
     * ## Details
     *
     * Spends must be claimed within some temporal bounds. A spend may be claimed within one
     * [`Config::PayoutPeriod`] from the `valid_from` block.
     * In case of a payout failure, the spend status must be updated with the `check_status`
     * dispatchable before retrying with the current function.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::Paid`] if successful.
     *
     * @param {number} index
     **/
    payout: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "Payout";
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Check the status of the spend and remove it from the storage if processed.
     *
     * ## Dispatch Origin
     *
     * Must be signed.
     *
     * ## Details
     *
     * The status check is a prerequisite for retrying a failed payout.
     * If a spend has either succeeded or expired, it is removed from the storage by this
     * function. In such instances, transaction fees are refunded.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::PaymentFailed`] if the spend payout has failed.
     * Emits [`Event::SpendProcessed`] if the spend payout has succeed.
     *
     * @param {number} index
     **/
    checkStatus: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "CheckStatus";
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Void previously approved spend.
     *
     * ## Dispatch Origin
     *
     * Must be [`Config::RejectOrigin`].
     *
     * ## Details
     *
     * A spend void is only possible if the payout has not been attempted yet.
     *
     * ### Parameters
     * - `index`: The spend index.
     *
     * ## Events
     *
     * Emits [`Event::AssetSpendVoided`] if successful.
     *
     * @param {number} index
     **/
    voidSpend: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Treasury";
          palletCall: {
            name: "VoidSpend";
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Democracy`'s transaction calls
   **/
  democracy: {
    /**
     * Propose a sensitive action to be taken.
     *
     * The dispatch origin of this call must be _Signed_ and the sender must
     * have funds to cover the deposit.
     *
     * - `proposal_hash`: The hash of the proposal preimage.
     * - `value`: The amount of deposit (must be at least `MinimumDeposit`).
     *
     * Emits `Proposed`.
     *
     * @param {FrameSupportPreimagesBounded} proposal
     * @param {bigint} value
     **/
    propose: GenericTxCall<
      Rv,
      (
        proposal: FrameSupportPreimagesBounded,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Propose";
            params: { proposal: FrameSupportPreimagesBounded; value: bigint };
          };
        }
      >
    >;

    /**
     * Signals agreement with a particular proposal.
     *
     * The dispatch origin of this call must be _Signed_ and the sender
     * must have funds to cover the deposit, equal to the original deposit.
     *
     * - `proposal`: The index of the proposal to second.
     *
     * @param {number} proposal
     **/
    second: GenericTxCall<
      Rv,
      (proposal: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Second";
            params: { proposal: number };
          };
        }
      >
    >;

    /**
     * Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;
     * otherwise it is a vote to keep the status quo.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `ref_index`: The index of the referendum to vote for.
     * - `vote`: The vote configuration.
     *
     * @param {number} refIndex
     * @param {PalletDemocracyVoteAccountVote} vote
     **/
    vote: GenericTxCall<
      Rv,
      (
        refIndex: number,
        vote: PalletDemocracyVoteAccountVote,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Vote";
            params: { refIndex: number; vote: PalletDemocracyVoteAccountVote };
          };
        }
      >
    >;

    /**
     * Schedule an emergency cancellation of a referendum. Cannot happen twice to the same
     * referendum.
     *
     * The dispatch origin of this call must be `CancellationOrigin`.
     *
     * -`ref_index`: The index of the referendum to cancel.
     *
     * Weight: `O(1)`.
     *
     * @param {number} refIndex
     **/
    emergencyCancel: GenericTxCall<
      Rv,
      (refIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "EmergencyCancel";
            params: { refIndex: number };
          };
        }
      >
    >;

    /**
     * Schedule a referendum to be tabled once it is legal to schedule an external
     * referendum.
     *
     * The dispatch origin of this call must be `ExternalOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalPropose: GenericTxCall<
      Rv,
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "ExternalPropose";
            params: { proposal: FrameSupportPreimagesBounded };
          };
        }
      >
    >;

    /**
     * Schedule a majority-carries referendum to be tabled next once it is legal to schedule
     * an external referendum.
     *
     * The dispatch of this call must be `ExternalMajorityOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalProposeMajority: GenericTxCall<
      Rv,
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "ExternalProposeMajority";
            params: { proposal: FrameSupportPreimagesBounded };
          };
        }
      >
    >;

    /**
     * Schedule a negative-turnout-bias referendum to be tabled next once it is legal to
     * schedule an external referendum.
     *
     * The dispatch of this call must be `ExternalDefaultOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal.
     *
     * Unlike `external_propose`, blacklisting has no effect on this and it may replace a
     * pre-scheduled `external_propose` call.
     *
     * Weight: `O(1)`
     *
     * @param {FrameSupportPreimagesBounded} proposal
     **/
    externalProposeDefault: GenericTxCall<
      Rv,
      (proposal: FrameSupportPreimagesBounded) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "ExternalProposeDefault";
            params: { proposal: FrameSupportPreimagesBounded };
          };
        }
      >
    >;

    /**
     * Schedule the currently externally-proposed majority-carries referendum to be tabled
     * immediately. If there is no externally-proposed referendum currently, or if there is one
     * but it is not a majority-carries referendum then it fails.
     *
     * The dispatch of this call must be `FastTrackOrigin`.
     *
     * - `proposal_hash`: The hash of the current external proposal.
     * - `voting_period`: The period that is allowed for voting on this proposal. Increased to
     * Must be always greater than zero.
     * For `FastTrackOrigin` must be equal or greater than `FastTrackVotingPeriod`.
     * - `delay`: The number of block after voting has ended in approval and this should be
     * enacted. This doesn't have a minimum amount.
     *
     * Emits `Started`.
     *
     * Weight: `O(1)`
     *
     * @param {H256} proposalHash
     * @param {number} votingPeriod
     * @param {number} delay
     **/
    fastTrack: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        votingPeriod: number,
        delay: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "FastTrack";
            params: { proposalHash: H256; votingPeriod: number; delay: number };
          };
        }
      >
    >;

    /**
     * Veto and blacklist the external proposal hash.
     *
     * The dispatch origin of this call must be `VetoOrigin`.
     *
     * - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.
     *
     * Emits `Vetoed`.
     *
     * Weight: `O(V + log(V))` where V is number of `existing vetoers`
     *
     * @param {H256} proposalHash
     **/
    vetoExternal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "VetoExternal";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Remove a referendum.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * - `ref_index`: The index of the referendum to cancel.
     *
     * # Weight: `O(1)`.
     *
     * @param {number} refIndex
     **/
    cancelReferendum: GenericTxCall<
      Rv,
      (refIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "CancelReferendum";
            params: { refIndex: number };
          };
        }
      >
    >;

    /**
     * Delegate the voting power (with some given conviction) of the sending account.
     *
     * The balance delegated is locked for as long as it's delegated, and thereafter for the
     * time appropriate for the conviction's lock period.
     *
     * The dispatch origin of this call must be _Signed_, and the signing account must either:
     * - be delegating already; or
     * - have no voting activity (if there is, then it will need to be removed/consolidated
     * through `reap_vote` or `unvote`).
     *
     * - `to`: The account whose voting the `target` account's voting power will follow.
     * - `conviction`: The conviction that will be attached to the delegated votes. When the
     * account is undelegated, the funds will be locked for the corresponding period.
     * - `balance`: The amount of the account's balance to be used in delegating. This must not
     * be more than the account's current balance.
     *
     * Emits `Delegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     *
     * @param {MultiAddressLike} to
     * @param {PalletDemocracyConviction} conviction
     * @param {bigint} balance
     **/
    delegate: GenericTxCall<
      Rv,
      (
        to: MultiAddressLike,
        conviction: PalletDemocracyConviction,
        balance: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Delegate";
            params: {
              to: MultiAddressLike;
              conviction: PalletDemocracyConviction;
              balance: bigint;
            };
          };
        }
      >
    >;

    /**
     * Undelegate the voting power of the sending account.
     *
     * Tokens may be unlocked following once an amount of time consistent with the lock period
     * of the conviction with which the delegation was issued.
     *
     * The dispatch origin of this call must be _Signed_ and the signing account must be
     * currently delegating.
     *
     * Emits `Undelegated`.
     *
     * Weight: `O(R)` where R is the number of referendums the voter delegating to has
     * voted on. Weight is charged as if maximum votes.
     *
     **/
    undelegate: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Undelegate";
          };
        }
      >
    >;

    /**
     * Clears all public proposals.
     *
     * The dispatch origin of this call must be _Root_.
     *
     * Weight: `O(1)`.
     *
     **/
    clearPublicProposals: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "ClearPublicProposals";
          };
        }
      >
    >;

    /**
     * Unlock tokens that have an expired lock.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account to remove the lock on.
     *
     * Weight: `O(R)` with R number of vote of target.
     *
     * @param {MultiAddressLike} target
     **/
    unlock: GenericTxCall<
      Rv,
      (target: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Unlock";
            params: { target: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a vote for a referendum.
     *
     * If:
     * - the referendum was cancelled, or
     * - the referendum is ongoing, or
     * - the referendum has ended such that
     * - the vote of the account was in opposition to the result; or
     * - there was no conviction to the account's vote; or
     * - the account made a split vote
     * ...then the vote is removed cleanly and a following call to `unlock` may result in more
     * funds being available.
     *
     * If, however, the referendum has ended and:
     * - it finished corresponding to the vote of the account, and
     * - the account made a standard vote with conviction, and
     * - the lock period of the conviction is not over
     * ...then the lock will be aggregated into the overall account's lock, which may involve
     * *overlocking* (where the two locks are combined into a single lock that is the maximum
     * of both the amount locked and the time is it locked for).
     *
     * The dispatch origin of this call must be _Signed_, and the signer must have a vote
     * registered for referendum `index`.
     *
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {number} index
     **/
    removeVote: GenericTxCall<
      Rv,
      (index: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "RemoveVote";
            params: { index: number };
          };
        }
      >
    >;

    /**
     * Remove a vote for a referendum.
     *
     * If the `target` is equal to the signer, then this function is exactly equivalent to
     * `remove_vote`. If not equal to the signer, then the vote must have expired,
     * either because the referendum was cancelled, because the voter lost the referendum or
     * because the conviction period is over.
     *
     * The dispatch origin of this call must be _Signed_.
     *
     * - `target`: The account of the vote to be removed; this account must have voted for
     * referendum `index`.
     * - `index`: The index of referendum of the vote to be removed.
     *
     * Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.
     * Weight is calculated for the maximum number of vote.
     *
     * @param {MultiAddressLike} target
     * @param {number} index
     **/
    removeOtherVote: GenericTxCall<
      Rv,
      (
        target: MultiAddressLike,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "RemoveOtherVote";
            params: { target: MultiAddressLike; index: number };
          };
        }
      >
    >;

    /**
     * Permanently place a proposal into the blacklist. This prevents it from ever being
     * proposed again.
     *
     * If called on a queued public or external proposal, then this will result in it being
     * removed. If the `ref_index` supplied is an active referendum with the proposal hash,
     * then it will be cancelled.
     *
     * The dispatch origin of this call must be `BlacklistOrigin`.
     *
     * - `proposal_hash`: The proposal hash to blacklist permanently.
     * - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be
     * cancelled.
     *
     * Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a
     * reasonable value).
     *
     * @param {H256} proposalHash
     * @param {number | undefined} maybeRefIndex
     **/
    blacklist: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        maybeRefIndex: number | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "Blacklist";
            params: { proposalHash: H256; maybeRefIndex: number | undefined };
          };
        }
      >
    >;

    /**
     * Remove a proposal.
     *
     * The dispatch origin of this call must be `CancelProposalOrigin`.
     *
     * - `prop_index`: The index of the proposal to cancel.
     *
     * Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`
     *
     * @param {number} propIndex
     **/
    cancelProposal: GenericTxCall<
      Rv,
      (propIndex: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "CancelProposal";
            params: { propIndex: number };
          };
        }
      >
    >;

    /**
     * Set or clear a metadata of a proposal or a referendum.
     *
     * Parameters:
     * - `origin`: Must correspond to the `MetadataOwner`.
     * - `ExternalOrigin` for an external proposal with the `SuperMajorityApprove`
     * threshold.
     * - `ExternalDefaultOrigin` for an external proposal with the `SuperMajorityAgainst`
     * threshold.
     * - `ExternalMajorityOrigin` for an external proposal with the `SimpleMajority`
     * threshold.
     * - `Signed` by a creator for a public proposal.
     * - `Signed` to clear a metadata for a finished referendum.
     * - `Root` to set a metadata for an ongoing referendum.
     * - `owner`: an identifier of a metadata owner.
     * - `maybe_hash`: The hash of an on-chain stored preimage. `None` to clear a metadata.
     *
     * @param {PalletDemocracyMetadataOwner} owner
     * @param {H256 | undefined} maybeHash
     **/
    setMetadata: GenericTxCall<
      Rv,
      (
        owner: PalletDemocracyMetadataOwner,
        maybeHash: H256 | undefined,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Democracy";
          palletCall: {
            name: "SetMetadata";
            params: {
              owner: PalletDemocracyMetadataOwner;
              maybeHash: H256 | undefined;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Council`'s transaction calls
   **/
  council: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId32Like>} newMembers
     * @param {AccountId32Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      Rv,
      (
        newMembers: Array<AccountId32Like>,
        prime: AccountId32Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "SetMembers";
            params: {
              newMembers: Array<AccountId32Like>;
              prime: AccountId32Like | undefined;
              oldCount: number;
            };
          };
        }
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {PolimecRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      Rv,
      (
        proposal: PolimecRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "Execute";
            params: {
              proposal: PolimecRuntimeRuntimeCallLike;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {number} threshold
     * @param {PolimecRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    propose: GenericTxCall<
      Rv,
      (
        threshold: number,
        proposal: PolimecRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "Propose";
            params: {
              threshold: number;
              proposal: PolimecRuntimeRuntimeCallLike;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "Vote";
            params: { proposal: H256; index: number; approve: boolean };
          };
        }
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "DisapproveProposal";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "Close";
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Disapprove the proposal and burn the cost held for storing this proposal.
     *
     * Parameters:
     * - `origin`: must be the `KillOrigin`.
     * - `proposal_hash`: The hash of the proposal that should be killed.
     *
     * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    kill: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "Kill";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Release the cost held for storing a proposal once the given proposal is completed.
     *
     * If there is no associated cost for the given proposal, this call will have no effect.
     *
     * Parameters:
     * - `origin`: must be `Signed` or `Root`.
     * - `proposal_hash`: The hash of the proposal.
     *
     * Emits `ProposalCostReleased` if any cost held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    releaseProposalCost: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Council";
          palletCall: {
            name: "ReleaseProposalCost";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `TechnicalCommittee`'s transaction calls
   **/
  technicalCommittee: {
    /**
     * Set the collective's membership.
     *
     * - `new_members`: The new member list. Be nice to the chain and provide it sorted.
     * - `prime`: The prime member whose vote sets the default.
     * - `old_count`: The upper bound for the previous number of members in storage. Used for
     * weight estimation.
     *
     * The dispatch of this call must be `SetMembersOrigin`.
     *
     * NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but
     * the weight estimations rely on it to estimate dispatchable weight.
     *
     * # WARNING:
     *
     * The `pallet-collective` can also be managed by logic outside of the pallet through the
     * implementation of the trait [`ChangeMembers`].
     * Any call to `set_members` must be careful that the member set doesn't get out of sync
     * with other logic managing the member set.
     *
     * ## Complexity:
     * - `O(MP + N)` where:
     * - `M` old-members-count (code- and governance-bounded)
     * - `N` new-members-count (code- and governance-bounded)
     * - `P` proposals-count (code-bounded)
     *
     * @param {Array<AccountId32Like>} newMembers
     * @param {AccountId32Like | undefined} prime
     * @param {number} oldCount
     **/
    setMembers: GenericTxCall<
      Rv,
      (
        newMembers: Array<AccountId32Like>,
        prime: AccountId32Like | undefined,
        oldCount: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "SetMembers";
            params: {
              newMembers: Array<AccountId32Like>;
              prime: AccountId32Like | undefined;
              oldCount: number;
            };
          };
        }
      >
    >;

    /**
     * Dispatch a proposal from a member using the `Member` origin.
     *
     * Origin must be a member of the collective.
     *
     * ## Complexity:
     * - `O(B + M + P)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` members-count (code-bounded)
     * - `P` complexity of dispatching `proposal`
     *
     * @param {PolimecRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    execute: GenericTxCall<
      Rv,
      (
        proposal: PolimecRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "Execute";
            params: {
              proposal: PolimecRuntimeRuntimeCallLike;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Add a new proposal to either be voted on or executed directly.
     *
     * Requires the sender to be member.
     *
     * `threshold` determines whether `proposal` is executed directly (`threshold < 2`)
     * or put up for voting.
     *
     * ## Complexity
     * - `O(B + M + P1)` or `O(B + M + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - branching is influenced by `threshold` where:
     * - `P1` is proposal execution complexity (`threshold < 2`)
     * - `P2` is proposals-count (code-bounded) (`threshold >= 2`)
     *
     * @param {number} threshold
     * @param {PolimecRuntimeRuntimeCallLike} proposal
     * @param {number} lengthBound
     **/
    propose: GenericTxCall<
      Rv,
      (
        threshold: number,
        proposal: PolimecRuntimeRuntimeCallLike,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "Propose";
            params: {
              threshold: number;
              proposal: PolimecRuntimeRuntimeCallLike;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Add an aye or nay vote for the sender to the given proposal.
     *
     * Requires the sender to be a member.
     *
     * Transaction fees will be waived if the member is voting on any particular proposal
     * for the first time and the call is successful. Subsequent vote changes will charge a
     * fee.
     * ## Complexity
     * - `O(M)` where `M` is members-count (code- and governance-bounded)
     *
     * @param {H256} proposal
     * @param {number} index
     * @param {boolean} approve
     **/
    vote: GenericTxCall<
      Rv,
      (
        proposal: H256,
        index: number,
        approve: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "Vote";
            params: { proposal: H256; index: number; approve: boolean };
          };
        }
      >
    >;

    /**
     * Disapprove a proposal, close, and remove it from the system, regardless of its current
     * state.
     *
     * Must be called by the Root origin.
     *
     * Parameters:
     * * `proposal_hash`: The hash of the proposal that should be disapproved.
     *
     * ## Complexity
     * O(P) where P is the number of max proposals
     *
     * @param {H256} proposalHash
     **/
    disapproveProposal: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "DisapproveProposal";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Close a vote that is either approved, disapproved or whose voting period has ended.
     *
     * May be called by any signed account in order to finish voting and close the proposal.
     *
     * If called before the end of the voting period it will only close the vote if it is
     * has enough votes to be approved or disapproved.
     *
     * If called after the end of the voting period abstentions are counted as rejections
     * unless there is a prime member set and the prime member cast an approval.
     *
     * If the close operation completes successfully with disapproval, the transaction fee will
     * be waived. Otherwise execution of the approved operation will be charged to the caller.
     *
     * + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed
     * proposal.
     * + `length_bound`: The upper bound for the length of the proposal in storage. Checked via
     * `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.
     *
     * ## Complexity
     * - `O(B + M + P1 + P2)` where:
     * - `B` is `proposal` size in bytes (length-fee-bounded)
     * - `M` is members-count (code- and governance-bounded)
     * - `P1` is the complexity of `proposal` preimage.
     * - `P2` is proposal-count (code-bounded)
     *
     * @param {H256} proposalHash
     * @param {number} index
     * @param {SpWeightsWeightV2Weight} proposalWeightBound
     * @param {number} lengthBound
     **/
    close: GenericTxCall<
      Rv,
      (
        proposalHash: H256,
        index: number,
        proposalWeightBound: SpWeightsWeightV2Weight,
        lengthBound: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "Close";
            params: {
              proposalHash: H256;
              index: number;
              proposalWeightBound: SpWeightsWeightV2Weight;
              lengthBound: number;
            };
          };
        }
      >
    >;

    /**
     * Disapprove the proposal and burn the cost held for storing this proposal.
     *
     * Parameters:
     * - `origin`: must be the `KillOrigin`.
     * - `proposal_hash`: The hash of the proposal that should be killed.
     *
     * Emits `Killed` and `ProposalCostBurned` if any cost was held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    kill: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "Kill";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Release the cost held for storing a proposal once the given proposal is completed.
     *
     * If there is no associated cost for the given proposal, this call will have no effect.
     *
     * Parameters:
     * - `origin`: must be `Signed` or `Root`.
     * - `proposal_hash`: The hash of the proposal.
     *
     * Emits `ProposalCostReleased` if any cost held for a given proposal.
     *
     * @param {H256} proposalHash
     **/
    releaseProposalCost: GenericTxCall<
      Rv,
      (proposalHash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "TechnicalCommittee";
          palletCall: {
            name: "ReleaseProposalCost";
            params: { proposalHash: H256 };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Elections`'s transaction calls
   **/
  elections: {
    /**
     * Vote for a set of candidates for the upcoming round of election. This can be called to
     * set the initial votes, or update already existing votes.
     *
     * Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is
     * reserved. The deposit is based on the number of votes and can be updated over time.
     *
     * The `votes` should:
     * - not be empty.
     * - be less than the number of possible candidates. Note that all current members and
     * runners-up are also automatically candidates for the next round.
     *
     * If `value` is more than `who`'s free balance, then the maximum of the two is used.
     *
     * The dispatch origin of this call must be signed.
     *
     * ### Warning
     *
     * It is the responsibility of the caller to **NOT** place all of their balance into the
     * lock and keep some for further operations.
     *
     * @param {Array<AccountId32Like>} votes
     * @param {bigint} value
     **/
    vote: GenericTxCall<
      Rv,
      (
        votes: Array<AccountId32Like>,
        value: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "Vote";
            params: { votes: Array<AccountId32Like>; value: bigint };
          };
        }
      >
    >;

    /**
     * Remove `origin` as a voter.
     *
     * This removes the lock and returns the deposit.
     *
     * The dispatch origin of this call must be signed and be a voter.
     *
     **/
    removeVoter: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "RemoveVoter";
          };
        }
      >
    >;

    /**
     * Submit oneself for candidacy. A fixed amount of deposit is recorded.
     *
     * All candidates are wiped at the end of the term. They either become a member/runner-up,
     * or leave the system while their deposit is slashed.
     *
     * The dispatch origin of this call must be signed.
     *
     * ### Warning
     *
     * Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]
     * to get their deposit back. Losing the spot in an election will always lead to a slash.
     *
     * The number of current candidates must be provided as witness data.
     * ## Complexity
     * O(C + log(C)) where C is candidate_count.
     *
     * @param {number} candidateCount
     **/
    submitCandidacy: GenericTxCall<
      Rv,
      (candidateCount: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "SubmitCandidacy";
            params: { candidateCount: number };
          };
        }
      >
    >;

    /**
     * Renounce one's intention to be a candidate for the next election round. 3 potential
     * outcomes exist:
     *
     * - `origin` is a candidate and not elected in any set. In this case, the deposit is
     * unreserved, returned and origin is removed as a candidate.
     * - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and
     * origin is removed as a runner-up.
     * - `origin` is a current member. In this case, the deposit is unreserved and origin is
     * removed as a member, consequently not being a candidate for the next round anymore.
     * Similar to [`remove_member`](Self::remove_member), if replacement runners exists, they
     * are immediately used. If the prime is renouncing, then no prime will exist until the
     * next round.
     *
     * The dispatch origin of this call must be signed, and have one of the above roles.
     * The type of renouncing must be provided as witness data.
     *
     * ## Complexity
     * - Renouncing::Candidate(count): O(count + log(count))
     * - Renouncing::Member: O(1)
     * - Renouncing::RunnerUp: O(1)
     *
     * @param {PalletElectionsPhragmenRenouncing} renouncing
     **/
    renounceCandidacy: GenericTxCall<
      Rv,
      (
        renouncing: PalletElectionsPhragmenRenouncing,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "RenounceCandidacy";
            params: { renouncing: PalletElectionsPhragmenRenouncing };
          };
        }
      >
    >;

    /**
     * Remove a particular member from the set. This is effective immediately and the bond of
     * the outgoing member is slashed.
     *
     * If a runner-up is available, then the best runner-up will be removed and replaces the
     * outgoing member. Otherwise, if `rerun_election` is `true`, a new phragmen election is
     * started, else, nothing happens.
     *
     * If `slash_bond` is set to true, the bond of the member being removed is slashed. Else,
     * it is returned.
     *
     * The dispatch origin of this call must be root.
     *
     * Note that this does not affect the designated block number of the next election.
     *
     * ## Complexity
     * - Check details of remove_and_replace_member() and do_phragmen().
     *
     * @param {MultiAddressLike} who
     * @param {boolean} slashBond
     * @param {boolean} rerunElection
     **/
    removeMember: GenericTxCall<
      Rv,
      (
        who: MultiAddressLike,
        slashBond: boolean,
        rerunElection: boolean,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "RemoveMember";
            params: {
              who: MultiAddressLike;
              slashBond: boolean;
              rerunElection: boolean;
            };
          };
        }
      >
    >;

    /**
     * Clean all voters who are defunct (i.e. they do not serve any purpose at all). The
     * deposit of the removed voters are returned.
     *
     * This is an root function to be used only for cleaning the state.
     *
     * The dispatch origin of this call must be root.
     *
     * ## Complexity
     * - Check is_defunct_voter() details.
     *
     * @param {number} numVoters
     * @param {number} numDefunct
     **/
    cleanDefunctVoters: GenericTxCall<
      Rv,
      (
        numVoters: number,
        numDefunct: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Elections";
          palletCall: {
            name: "CleanDefunctVoters";
            params: { numVoters: number; numDefunct: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Preimage`'s transaction calls
   **/
  preimage: {
    /**
     * Register a preimage on-chain.
     *
     * If the preimage was previously requested, no fees or deposits are taken for providing
     * the preimage. Otherwise, a deposit is taken proportional to the size of the preimage.
     *
     * @param {BytesLike} bytes
     **/
    notePreimage: GenericTxCall<
      Rv,
      (bytes: BytesLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "NotePreimage";
            params: { bytes: BytesLike };
          };
        }
      >
    >;

    /**
     * Clear an unrequested preimage from the runtime storage.
     *
     * If `len` is provided, then it will be a much cheaper operation.
     *
     * - `hash`: The hash of the preimage to be removed from the store.
     * - `len`: The length of the preimage of `hash`.
     *
     * @param {H256} hash
     **/
    unnotePreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "UnnotePreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Request a preimage be uploaded to the chain without paying any fees or deposits.
     *
     * If the preimage requests has already been provided on-chain, we unreserve any deposit
     * a user may have paid, and take the control of the preimage out of their hands.
     *
     * @param {H256} hash
     **/
    requestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "RequestPreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Clear a previously made request for a preimage.
     *
     * NOTE: THIS MUST NOT BE CALLED ON `hash` MORE TIMES THAN `request_preimage`.
     *
     * @param {H256} hash
     **/
    unrequestPreimage: GenericTxCall<
      Rv,
      (hash: H256) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "UnrequestPreimage";
            params: { hash: H256 };
          };
        }
      >
    >;

    /**
     * Ensure that the a bulk of pre-images is upgraded.
     *
     * The caller pays no fee if at least 90% of pre-images were successfully updated.
     *
     * @param {Array<H256>} hashes
     **/
    ensureUpdated: GenericTxCall<
      Rv,
      (hashes: Array<H256>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Preimage";
          palletCall: {
            name: "EnsureUpdated";
            params: { hashes: Array<H256> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Scheduler`'s transaction calls
   **/
  scheduler: {
    /**
     * Anonymously schedule a task.
     *
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    schedule: GenericTxCall<
      Rv,
      (
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "Schedule";
            params: {
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel an anonymously scheduled task.
     *
     * @param {number} when
     * @param {number} index
     **/
    cancel: GenericTxCall<
      Rv,
      (
        when: number,
        index: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "Cancel";
            params: { when: number; index: number };
          };
        }
      >
    >;

    /**
     * Schedule a named task.
     *
     * @param {FixedBytes<32>} id
     * @param {number} when
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    scheduleNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        when: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleNamed";
            params: {
              id: FixedBytes<32>;
              when: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Cancel a named scheduled task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelNamed";
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Anonymously schedule a task after a delay.
     *
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    scheduleAfter: GenericTxCall<
      Rv,
      (
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleAfter";
            params: {
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Schedule a named task after a delay.
     *
     * @param {FixedBytes<32>} id
     * @param {number} after
     * @param {[number, number] | undefined} maybePeriodic
     * @param {number} priority
     * @param {PolimecRuntimeRuntimeCallLike} call
     **/
    scheduleNamedAfter: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        after: number,
        maybePeriodic: [number, number] | undefined,
        priority: number,
        call: PolimecRuntimeRuntimeCallLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "ScheduleNamedAfter";
            params: {
              id: FixedBytes<32>;
              after: number;
              maybePeriodic: [number, number] | undefined;
              priority: number;
              call: PolimecRuntimeRuntimeCallLike;
            };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a task so that, in case its scheduled run fails, it will
     * be retried after `period` blocks, for a total amount of `retries` retries or until it
     * succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {[number, number]} task
     * @param {number} retries
     * @param {number} period
     **/
    setRetry: GenericTxCall<
      Rv,
      (
        task: [number, number],
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "SetRetry";
            params: { task: [number, number]; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Set a retry configuration for a named task so that, in case its scheduled run fails, it
     * will be retried after `period` blocks, for a total amount of `retries` retries or until
     * it succeeds.
     *
     * Tasks which need to be scheduled for a retry are still subject to weight metering and
     * agenda space, same as a regular task. If a periodic task fails, it will be scheduled
     * normally while the task is retrying.
     *
     * Tasks scheduled as a result of a retry for a periodic task are unnamed, non-periodic
     * clones of the original task. Their retry configuration will be derived from the
     * original task's configuration, but will have a lower value for `remaining` than the
     * original `total_retries`.
     *
     * @param {FixedBytes<32>} id
     * @param {number} retries
     * @param {number} period
     **/
    setRetryNamed: GenericTxCall<
      Rv,
      (
        id: FixedBytes<32>,
        retries: number,
        period: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "SetRetryNamed";
            params: { id: FixedBytes<32>; retries: number; period: number };
          };
        }
      >
    >;

    /**
     * Removes the retry configuration of a task.
     *
     * @param {[number, number]} task
     **/
    cancelRetry: GenericTxCall<
      Rv,
      (task: [number, number]) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelRetry";
            params: { task: [number, number] };
          };
        }
      >
    >;

    /**
     * Cancel the retry configuration of a named task.
     *
     * @param {FixedBytes<32>} id
     **/
    cancelRetryNamed: GenericTxCall<
      Rv,
      (id: FixedBytes<32>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Scheduler";
          palletCall: {
            name: "CancelRetryNamed";
            params: { id: FixedBytes<32> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Oracle`'s transaction calls
   **/
  oracle: {
    /**
     * Feed the external value.
     *
     * Require authorized operator.
     *
     * @param {Array<[StagingXcmV4Location, FixedU128]>} values
     **/
    feedValues: GenericTxCall<
      Rv,
      (
        values: Array<[StagingXcmV4Location, FixedU128]>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Oracle";
          palletCall: {
            name: "FeedValues";
            params: { values: Array<[StagingXcmV4Location, FixedU128]> };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `OracleProvidersMembership`'s transaction calls
   **/
  oracleProvidersMembership: {
    /**
     * Add a member `who` to the set.
     *
     * May only be called from `T::AddOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    addMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "AddMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove a member `who` from the set.
     *
     * May only be called from `T::RemoveOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    removeMember: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "RemoveMember";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Swap out one member `remove` for another `add`.
     *
     * May only be called from `T::SwapOrigin`.
     *
     * Prime membership is *not* passed from `remove` to `add`, if extant.
     *
     * @param {MultiAddressLike} remove
     * @param {MultiAddressLike} add
     **/
    swapMember: GenericTxCall<
      Rv,
      (
        remove: MultiAddressLike,
        add: MultiAddressLike,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "SwapMember";
            params: { remove: MultiAddressLike; add: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Change the membership to a new set, disregarding the existing membership. Be nice and
     * pass `members` pre-sorted.
     *
     * May only be called from `T::ResetOrigin`.
     *
     * @param {Array<AccountId32Like>} members
     **/
    resetMembers: GenericTxCall<
      Rv,
      (members: Array<AccountId32Like>) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "ResetMembers";
            params: { members: Array<AccountId32Like> };
          };
        }
      >
    >;

    /**
     * Swap out the sending member for some other key `new`.
     *
     * May only be called from `Signed` origin of a current member.
     *
     * Prime membership is passed from the origin account to `new`, if extant.
     *
     * @param {MultiAddressLike} new_
     **/
    changeKey: GenericTxCall<
      Rv,
      (new_: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "ChangeKey";
            params: { new: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Set the prime member. Must be a current member.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     * @param {MultiAddressLike} who
     **/
    setPrime: GenericTxCall<
      Rv,
      (who: MultiAddressLike) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "SetPrime";
            params: { who: MultiAddressLike };
          };
        }
      >
    >;

    /**
     * Remove the prime member if it exists.
     *
     * May only be called from `T::PrimeOrigin`.
     *
     **/
    clearPrime: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "OracleProvidersMembership";
          palletCall: {
            name: "ClearPrime";
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `Funding`'s transaction calls
   **/
  funding: {
    /**
     * Creates a project and assigns it to the `issuer` account.
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {PalletFundingStorageProjectMetadata} project
     **/
    createProject: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        project: PalletFundingStorageProjectMetadata,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "CreateProject";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              project: PalletFundingStorageProjectMetadata;
            };
          };
        }
      >
    >;

    /**
     * Removes a project that hasn't started the evaluation round yet
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     **/
    removeProject: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "RemoveProject";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
            };
          };
        }
      >
    >;

    /**
     * Change the metadata of a project
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     * @param {PalletFundingStorageProjectMetadata} newProjectMetadata
     **/
    editProject: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
        newProjectMetadata: PalletFundingStorageProjectMetadata,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "EditProject";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
              newProjectMetadata: PalletFundingStorageProjectMetadata;
            };
          };
        }
      >
    >;

    /**
     * Starts the evaluation round of a project.
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     **/
    startEvaluation: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "StartEvaluation";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
            };
          };
        }
      >
    >;

    /**
     * Bond PLMC for a project in the evaluation stage
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     * @param {bigint} usdAmount
     **/
    evaluate: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
        usdAmount: bigint,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "Evaluate";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
              usdAmount: bigint;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     * @param {bigint} usdAmount
     * @param {StagingXcmV4Junction} receivingAccount
     * @param {FixedBytes<65>} signatureBytes
     **/
    evaluateWithReceivingAccount: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
        usdAmount: bigint,
        receivingAccount: StagingXcmV4Junction,
        signatureBytes: FixedBytes<65>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "EvaluateWithReceivingAccount";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
              usdAmount: bigint;
              receivingAccount: StagingXcmV4Junction;
              signatureBytes: FixedBytes<65>;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    endEvaluation: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "EndEvaluation";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     * Bid for a project in the Auction round
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     * @param {bigint} ctAmount
     * @param {PalletFundingInnerParticipationMode} mode
     * @param {PolimecCommonAssetsAcceptedFundingAsset} fundingAsset
     **/
    bid: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
        ctAmount: bigint,
        mode: PalletFundingInnerParticipationMode,
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "Bid";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
              ctAmount: bigint;
              mode: PalletFundingInnerParticipationMode;
              fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     * @param {bigint} ctAmount
     * @param {PalletFundingInnerParticipationMode} mode
     * @param {PolimecCommonAssetsAcceptedFundingAsset} fundingAsset
     * @param {StagingXcmV4Junction} receivingAccount
     * @param {FixedBytes<65>} signatureBytes
     **/
    bidWithReceivingAccount: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
        ctAmount: bigint,
        mode: PalletFundingInnerParticipationMode,
        fundingAsset: PolimecCommonAssetsAcceptedFundingAsset,
        receivingAccount: StagingXcmV4Junction,
        signatureBytes: FixedBytes<65>,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "BidWithReceivingAccount";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
              ctAmount: bigint;
              mode: PalletFundingInnerParticipationMode;
              fundingAsset: PolimecCommonAssetsAcceptedFundingAsset;
              receivingAccount: StagingXcmV4Junction;
              signatureBytes: FixedBytes<65>;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    processNextOversubscribedBid: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "ProcessNextOversubscribedBid";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    endFunding: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "EndFunding";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    startSettlement: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "StartSettlement";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     * @param {AccountId32Like} evaluator
     * @param {number} evaluationId
     **/
    settleEvaluation: GenericTxCall<
      Rv,
      (
        projectId: number,
        evaluator: AccountId32Like,
        evaluationId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "SettleEvaluation";
            params: {
              projectId: number;
              evaluator: AccountId32Like;
              evaluationId: number;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     * @param {number} bidId
     **/
    settleBid: GenericTxCall<
      Rv,
      (
        projectId: number,
        bidId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "SettleBid";
            params: { projectId: number; bidId: number };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    markProjectAsSettled: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "MarkProjectAsSettled";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     *
     * @param {JwtCompactFrameTokenUntrustedToken} jwt
     * @param {number} projectId
     **/
    startOffchainMigration: GenericTxCall<
      Rv,
      (
        jwt: JwtCompactFrameTokenUntrustedToken,
        projectId: number,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "StartOffchainMigration";
            params: {
              jwt: JwtCompactFrameTokenUntrustedToken;
              projectId: number;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     * @param {AccountId32Like} participant
     **/
    confirmOffchainMigration: GenericTxCall<
      Rv,
      (
        projectId: number,
        participant: AccountId32Like,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "ConfirmOffchainMigration";
            params: { projectId: number; participant: AccountId32Like };
          };
        }
      >
    >;

    /**
     *
     * @param {number} projectId
     **/
    markProjectCtMigrationAsFinished: GenericTxCall<
      Rv,
      (projectId: number) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "Funding";
          palletCall: {
            name: "MarkProjectCtMigrationAsFinished";
            params: { projectId: number };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `LinearRelease`'s transaction calls
   **/
  linearRelease: {
    /**
     * Unlock any vested funds of the sender account, for the given `reason`.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {PolimecRuntimeRuntimeHoldReason} reason
     **/
    vest: GenericTxCall<
      Rv,
      (reason: PolimecRuntimeRuntimeHoldReason) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "Vest";
            params: { reason: PolimecRuntimeRuntimeHoldReason };
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of a `target` account, for the given `reason`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {AccountId32Like} target
     * @param {PolimecRuntimeRuntimeHoldReason} reason
     **/
    vestOther: GenericTxCall<
      Rv,
      (
        target: AccountId32Like,
        reason: PolimecRuntimeRuntimeHoldReason,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "VestOther";
            params: {
              target: AccountId32Like;
              reason: PolimecRuntimeRuntimeHoldReason;
            };
          };
        }
      >
    >;

    /**
     * Create a vested transfer.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account receiving the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {AccountId32Like} target
     * @param {PalletLinearReleaseVestingInfo} schedule
     * @param {PolimecRuntimeRuntimeHoldReason} reason
     **/
    vestedTransfer: GenericTxCall<
      Rv,
      (
        target: AccountId32Like,
        schedule: PalletLinearReleaseVestingInfo,
        reason: PolimecRuntimeRuntimeHoldReason,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "VestedTransfer";
            params: {
              target: AccountId32Like;
              schedule: PalletLinearReleaseVestingInfo;
              reason: PolimecRuntimeRuntimeHoldReason;
            };
          };
        }
      >
    >;

    /**
     * Force a vested transfer.
     *
     * The dispatch origin for this call must be _Root_.
     *
     * - `source`: The account whose funds should be transferred.
     * - `target`: The account that should be transferred the vested funds.
     * - `schedule`: The vesting schedule attached to the transfer.
     *
     * Emits `VestingCreated`.
     *
     * NOTE: This will unlock all schedules through the current block.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {AccountId32Like} source
     * @param {AccountId32Like} target
     * @param {PalletLinearReleaseVestingInfo} schedule
     * @param {PolimecRuntimeRuntimeHoldReason} reason
     **/
    forceVestedTransfer: GenericTxCall<
      Rv,
      (
        source: AccountId32Like,
        target: AccountId32Like,
        schedule: PalletLinearReleaseVestingInfo,
        reason: PolimecRuntimeRuntimeHoldReason,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "ForceVestedTransfer";
            params: {
              source: AccountId32Like;
              target: AccountId32Like;
              schedule: PalletLinearReleaseVestingInfo;
              reason: PolimecRuntimeRuntimeHoldReason;
            };
          };
        }
      >
    >;

    /**
     * Merge two vesting schedules together, creating a new vesting schedule that unlocks over
     * the highest possible start and end blocks. If both schedules have already started the
     * current block will be used as the schedule start; with the caveat that if one schedule
     * is finished by the current block, the other will be treated as the new merged schedule,
     * unmodified.
     *
     * NOTE: If `schedule1_index == schedule2_index` this is a no-op.
     * NOTE: This will unlock all schedules through the current block prior to merging.
     * NOTE: If both schedules have ended by the current block, no new schedule will be created
     * and both will be removed.
     *
     * Merged schedule attributes:
     * - `starting_block`: `MAX(schedule1.starting_block, scheduled2.starting_block,
     * current_block)`.
     * - `ending_block`: `MAX(schedule1.ending_block, schedule2.ending_block)`.
     * - `locked`: `schedule1.locked_at(current_block) + schedule2.locked_at(current_block)`.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `schedule1_index`: index of the first schedule to merge.
     * - `schedule2_index`: index of the second schedule to merge.
     *
     * @param {number} schedule1Index
     * @param {number} schedule2Index
     * @param {PolimecRuntimeRuntimeHoldReason} reason
     **/
    mergeSchedules: GenericTxCall<
      Rv,
      (
        schedule1Index: number,
        schedule2Index: number,
        reason: PolimecRuntimeRuntimeHoldReason,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "MergeSchedules";
            params: {
              schedule1Index: number;
              schedule2Index: number;
              reason: PolimecRuntimeRuntimeHoldReason;
            };
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of the sender account.
     *
     * The dispatch origin for this call must be _Signed_ and the sender must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     **/
    vestAll: GenericTxCall<
      Rv,
      () => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "VestAll";
          };
        }
      >
    >;

    /**
     * Unlock any vested funds of a `target` account.
     *
     * The dispatch origin for this call must be _Signed_.
     *
     * - `target`: The account whose vested funds should be unlocked. Must have funds still
     * locked under this pallet.
     *
     * Emits either `VestingCompleted` or `VestingUpdated`.
     *
     * ## Complexity
     * - `O(1)`.
     *
     * @param {AccountId32Like} target
     **/
    vestAllOther: GenericTxCall<
      Rv,
      (target: AccountId32Like) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "LinearRelease";
          palletCall: {
            name: "VestAllOther";
            params: { target: AccountId32Like };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
  /**
   * Pallet `ProxyBonding`'s transaction calls
   **/
  proxyBonding: {
    /**
     * If sub-account has all the tokens unbonded, it will transfer everything including ED back to the treasury
     *
     * @param {number} derivationPath
     * @param {PolimecRuntimeRuntimeHoldReason} holdReason
     **/
    transferBondsBackToTreasury: GenericTxCall<
      Rv,
      (
        derivationPath: number,
        holdReason: PolimecRuntimeRuntimeHoldReason,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ProxyBonding";
          palletCall: {
            name: "TransferBondsBackToTreasury";
            params: {
              derivationPath: number;
              holdReason: PolimecRuntimeRuntimeHoldReason;
            };
          };
        }
      >
    >;

    /**
     *
     * @param {number} derivationPath
     * @param {PolimecRuntimeRuntimeHoldReason} holdReason
     * @param {StagingXcmV4Location} feeAsset
     **/
    transferFeesToRecipient: GenericTxCall<
      Rv,
      (
        derivationPath: number,
        holdReason: PolimecRuntimeRuntimeHoldReason,
        feeAsset: StagingXcmV4Location,
      ) => ChainSubmittableExtrinsic<
        Rv,
        {
          pallet: "ProxyBonding";
          palletCall: {
            name: "TransferFeesToRecipient";
            params: {
              derivationPath: number;
              holdReason: PolimecRuntimeRuntimeHoldReason;
              feeAsset: StagingXcmV4Location;
            };
          };
        }
      >
    >;

    /**
     * Generic pallet tx call
     **/
    [callName: string]: GenericTxCall<Rv, TxCall<Rv>>;
  };
}
