// Generated by dedot cli

import type {
  GenericChainStorage,
  GenericStorageQuery,
  Callback,
  RpcVersion,
} from "dedot/types";
import type {
  AccountId32,
  AccountId32Like,
  H256,
  Bytes,
  Digest,
  Phase,
  FixedU128,
  FixedBytes,
  BytesLike,
  Perbill,
} from "dedot/codecs";
import type {
  FrameSystemAccountInfo,
  FrameSupportDispatchPerDispatchClass,
  FrameSystemEventRecord,
  FrameSystemLastRuntimeUpgradeInfo,
  FrameSystemCodeUpgradeAuthorization,
  CumulusPalletParachainSystemUnincludedSegmentAncestor,
  CumulusPalletParachainSystemUnincludedSegmentSegmentTracker,
  PolkadotPrimitivesV8PersistedValidationData,
  PolkadotPrimitivesV8UpgradeRestriction,
  PolkadotPrimitivesV8UpgradeGoAhead,
  SpTrieStorageProof,
  CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot,
  PolkadotPrimitivesV8AbridgedHostConfiguration,
  CumulusPrimitivesParachainInherentMessageQueueChain,
  PolkadotParachainPrimitivesPrimitivesId,
  PolkadotCorePrimitivesOutboundHrmpMessage,
  SpWeightsWeightV2Weight,
  PalletMultisigMultisig,
  PalletProxyProxyDefinition,
  PalletProxyAnnouncement,
  PalletBalancesAccountData,
  PalletBalancesBalanceLock,
  PalletBalancesReserveData,
  FrameSupportTokensMiscIdAmount,
  FrameSupportTokensMiscIdAmountRuntimeFreezeReason,
  PalletTransactionPaymentReleases,
  PalletVestingVestingInfo,
  PalletVestingReleases,
  PalletAssetsAssetDetails,
  PalletAssetsAssetAccount,
  PalletAssetsApproval,
  PalletAssetsAssetMetadata,
  StagingXcmV4Location,
  PolimecRuntimeSessionKeys,
  SpCoreCryptoKeyTypeId,
  SpConsensusAuraSr25519AppSr25519Public,
  SpConsensusSlotsSlot,
  PalletParachainStakingParachainBondConfig,
  PalletParachainStakingRoundInfo,
  PalletParachainStakingDelegator,
  PalletParachainStakingCandidateMetadata,
  PalletParachainStakingDelegationRequestsScheduledRequest,
  PalletParachainStakingAutoCompoundAutoCompoundConfig,
  PalletParachainStakingDelegations,
  PalletParachainStakingSetOrderedSet,
  PalletParachainStakingCollatorSnapshot,
  PalletParachainStakingDelayedPayout,
  PalletParachainStakingInflationInflationInfo,
  CumulusPalletXcmpQueueOutboundChannelDetails,
  CumulusPalletXcmpQueueQueueConfigData,
  PalletXcmQueryStatus,
  XcmVersionedLocation,
  PalletXcmVersionMigrationStage,
  PalletXcmRemoteLockedFungibleRecord,
  XcmVersionedAssetId,
  StagingXcmV5Xcm,
  PalletMessageQueueBookState,
  CumulusPrimitivesCoreAggregateMessageOrigin,
  PalletMessageQueuePage,
  PalletTreasuryProposal,
  PalletTreasurySpendStatus,
  FrameSupportPreimagesBounded,
  PalletDemocracyReferendumInfo,
  PalletDemocracyVoteVoting,
  PalletDemocracyVoteThreshold,
  PalletDemocracyMetadataOwner,
  PolimecRuntimeRuntimeCall,
  PalletCollectiveVotes,
  PalletElectionsPhragmenSeatHolder,
  PalletElectionsPhragmenVoter,
  PalletPreimageOldRequestStatus,
  PalletPreimageRequestStatus,
  PalletSchedulerScheduled,
  PalletSchedulerRetryConfig,
  OrmlOracleModuleTimestampedValue,
  OrmlUtilitiesOrderedSet,
  PalletFundingStorageProjectMetadata,
  PalletFundingStorageBucket,
  PalletFundingStorageProjectDetails,
  PalletFundingStorageEvaluationInfo,
  PalletFundingStorageBidInfo,
  PalletFundingStorageBidBucketBounds,
  PalletFundingStorageOutbidBidsCutoff,
  PolimecCommonMigrationTypesMigrationStatus,
  PolimecCommonMigrationTypesMigration,
  PalletLinearReleaseVestingInfo,
  PolimecRuntimeRuntimeHoldReason,
  PalletProxyBondingReleaseType,
} from "./types.js";

export interface ChainStorage<Rv extends RpcVersion>
  extends GenericChainStorage<Rv> {
  /**
   * Pallet `System`'s storage queries
   **/
  system: {
    /**
     * The full account information for a particular account ID.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<FrameSystemAccountInfo> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => FrameSystemAccountInfo,
      AccountId32
    >;

    /**
     * Total extrinsics count for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    extrinsicCount: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Whether all inherents have been applied.
     *
     * @param {Callback<boolean> =} callback
     **/
    inherentsApplied: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The current weight for the block.
     *
     * @param {Callback<FrameSupportDispatchPerDispatchClass> =} callback
     **/
    blockWeight: GenericStorageQuery<
      Rv,
      () => FrameSupportDispatchPerDispatchClass
    >;

    /**
     * Total length (in bytes) for all extrinsics put together, for the current block.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    allExtrinsicsLen: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Map of block numbers to block hashes.
     *
     * @param {number} arg
     * @param {Callback<H256> =} callback
     **/
    blockHash: GenericStorageQuery<Rv, (arg: number) => H256, number>;

    /**
     * Extrinsics data for the current block (maps an extrinsic's index to its data).
     *
     * @param {number} arg
     * @param {Callback<Bytes> =} callback
     **/
    extrinsicData: GenericStorageQuery<Rv, (arg: number) => Bytes, number>;

    /**
     * The current block number being processed. Set by `execute_block`.
     *
     * @param {Callback<number> =} callback
     **/
    number: GenericStorageQuery<Rv, () => number>;

    /**
     * Hash of the previous block.
     *
     * @param {Callback<H256> =} callback
     **/
    parentHash: GenericStorageQuery<Rv, () => H256>;

    /**
     * Digest of the current block, also part of the block header.
     *
     * @param {Callback<Digest> =} callback
     **/
    digest: GenericStorageQuery<Rv, () => Digest>;

    /**
     * Events deposited for the current block.
     *
     * NOTE: The item is unbound and should therefore never be read on chain.
     * It could otherwise inflate the PoV size of a block.
     *
     * Events have a large in-memory size. Box the events to not go out-of-memory
     * just in case someone still reads them from within the runtime.
     *
     * @param {Callback<Array<FrameSystemEventRecord>> =} callback
     **/
    events: GenericStorageQuery<Rv, () => Array<FrameSystemEventRecord>>;

    /**
     * The number of events in the `Events<T>` list.
     *
     * @param {Callback<number> =} callback
     **/
    eventCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Mapping between a topic (represented by T::Hash) and a vector of indexes
     * of events in the `<Events<T>>` list.
     *
     * All topic vectors have deterministic storage locations depending on the topic. This
     * allows light-clients to leverage the changes trie storage tracking mechanism and
     * in case of changes fetch the list of events of interest.
     *
     * The value has the type `(BlockNumberFor<T>, EventIndex)` because if we used only just
     * the `EventIndex` then in case if the topic has the same contents on the next block
     * no notification will be triggered thus the event might be lost.
     *
     * @param {H256} arg
     * @param {Callback<Array<[number, number]>> =} callback
     **/
    eventTopics: GenericStorageQuery<
      Rv,
      (arg: H256) => Array<[number, number]>,
      H256
    >;

    /**
     * Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
     *
     * @param {Callback<FrameSystemLastRuntimeUpgradeInfo | undefined> =} callback
     **/
    lastRuntimeUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemLastRuntimeUpgradeInfo | undefined
    >;

    /**
     * True if we have upgraded so that `type RefCount` is `u32`. False (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToU32RefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * True if we have upgraded so that AccountInfo contains three types of `RefCount`. False
     * (default) if not.
     *
     * @param {Callback<boolean> =} callback
     **/
    upgradedToTripleRefCount: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The execution phase of the block.
     *
     * @param {Callback<Phase | undefined> =} callback
     **/
    executionPhase: GenericStorageQuery<Rv, () => Phase | undefined>;

    /**
     * `Some` if a code upgrade has been authorized.
     *
     * @param {Callback<FrameSystemCodeUpgradeAuthorization | undefined> =} callback
     **/
    authorizedUpgrade: GenericStorageQuery<
      Rv,
      () => FrameSystemCodeUpgradeAuthorization | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ParachainSystem`'s storage queries
   **/
  parachainSystem: {
    /**
     * Latest included block descendants the runtime accepted. In other words, these are
     * ancestors of the currently executing block which have not been included in the observed
     * relay-chain state.
     *
     * The segment length is limited by the capacity returned from the [`ConsensusHook`] configured
     * in the pallet.
     *
     * @param {Callback<Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>> =} callback
     **/
    unincludedSegment: GenericStorageQuery<
      Rv,
      () => Array<CumulusPalletParachainSystemUnincludedSegmentAncestor>
    >;

    /**
     * Storage field that keeps track of bandwidth used by the unincluded segment along with the
     * latest HRMP watermark. Used for limiting the acceptance of new blocks with
     * respect to relay chain constraints.
     *
     * @param {Callback<CumulusPalletParachainSystemUnincludedSegmentSegmentTracker | undefined> =} callback
     **/
    aggregatedUnincludedSegment: GenericStorageQuery<
      Rv,
      () =>
        | CumulusPalletParachainSystemUnincludedSegmentSegmentTracker
        | undefined
    >;

    /**
     * In case of a scheduled upgrade, this storage field contains the validation code to be
     * applied.
     *
     * As soon as the relay chain gives us the go-ahead signal, we will overwrite the
     * [`:code`][sp_core::storage::well_known_keys::CODE] which will result the next block process
     * with the new validation code. This concludes the upgrade process.
     *
     * @param {Callback<Bytes> =} callback
     **/
    pendingValidationCode: GenericStorageQuery<Rv, () => Bytes>;

    /**
     * Validation code that is set by the parachain and is to be communicated to collator and
     * consequently the relay-chain.
     *
     * This will be cleared in `on_initialize` of each new block if no other pallet already set
     * the value.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    newValidationCode: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * The [`PersistedValidationData`] set for this block.
     * This value is expected to be set only once per block and it's never stored
     * in the trie.
     *
     * @param {Callback<PolkadotPrimitivesV8PersistedValidationData | undefined> =} callback
     **/
    validationData: GenericStorageQuery<
      Rv,
      () => PolkadotPrimitivesV8PersistedValidationData | undefined
    >;

    /**
     * Were the validation data set to notify the relay chain?
     *
     * @param {Callback<boolean> =} callback
     **/
    didSetValidationCode: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The relay chain block number associated with the last parachain block.
     *
     * This is updated in `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    lastRelayChainBlockNumber: GenericStorageQuery<Rv, () => number>;

    /**
     * An option which indicates if the relay-chain restricts signalling a validation code upgrade.
     * In other words, if this is `Some` and [`NewValidationCode`] is `Some` then the produced
     * candidate will be invalid.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeRestriction | undefined> =} callback
     **/
    upgradeRestrictionSignal: GenericStorageQuery<
      Rv,
      () => PolkadotPrimitivesV8UpgradeRestriction | undefined
    >;

    /**
     * Optional upgrade go-ahead signal from the relay-chain.
     *
     * This storage item is a mirror of the corresponding value for the current parachain from the
     * relay-chain. This value is ephemeral which means it doesn't hit the storage. This value is
     * set after the inherent.
     *
     * @param {Callback<PolkadotPrimitivesV8UpgradeGoAhead | undefined> =} callback
     **/
    upgradeGoAhead: GenericStorageQuery<
      Rv,
      () => PolkadotPrimitivesV8UpgradeGoAhead | undefined
    >;

    /**
     * The state proof for the last relay parent block.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<SpTrieStorageProof | undefined> =} callback
     **/
    relayStateProof: GenericStorageQuery<
      Rv,
      () => SpTrieStorageProof | undefined
    >;

    /**
     * The snapshot of some state related to messaging relevant to the current parachain as per
     * the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot | undefined> =} callback
     **/
    relevantMessagingState: GenericStorageQuery<
      Rv,
      () =>
        | CumulusPalletParachainSystemRelayStateSnapshotMessagingStateSnapshot
        | undefined
    >;

    /**
     * The parachain host configuration that was obtained from the relay parent.
     *
     * This field is meant to be updated each block with the validation data inherent. Therefore,
     * before processing of the inherent, e.g. in `on_initialize` this data may be stale.
     *
     * This data is also absent from the genesis.
     *
     * @param {Callback<PolkadotPrimitivesV8AbridgedHostConfiguration | undefined> =} callback
     **/
    hostConfiguration: GenericStorageQuery<
      Rv,
      () => PolkadotPrimitivesV8AbridgedHostConfiguration | undefined
    >;

    /**
     * The last downward message queue chain head we have observed.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<CumulusPrimitivesParachainInherentMessageQueueChain> =} callback
     **/
    lastDmqMqcHead: GenericStorageQuery<
      Rv,
      () => CumulusPrimitivesParachainInherentMessageQueueChain
    >;

    /**
     * The message queue chain heads we have observed per each channel incoming channel.
     *
     * This value is loaded before and saved after processing inbound downward messages carried
     * by the system inherent.
     *
     * @param {Callback<Array<[PolkadotParachainPrimitivesPrimitivesId, CumulusPrimitivesParachainInherentMessageQueueChain]>> =} callback
     **/
    lastHrmpMqcHeads: GenericStorageQuery<
      Rv,
      () => Array<
        [
          PolkadotParachainPrimitivesPrimitivesId,
          CumulusPrimitivesParachainInherentMessageQueueChain,
        ]
      >
    >;

    /**
     * Number of downward messages processed in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    processedDownwardMessages: GenericStorageQuery<Rv, () => number>;

    /**
     * HRMP watermark that was set in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<number> =} callback
     **/
    hrmpWatermark: GenericStorageQuery<Rv, () => number>;

    /**
     * HRMP messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<PolkadotCorePrimitivesOutboundHrmpMessage>> =} callback
     **/
    hrmpOutboundMessages: GenericStorageQuery<
      Rv,
      () => Array<PolkadotCorePrimitivesOutboundHrmpMessage>
    >;

    /**
     * Upward messages that were sent in a block.
     *
     * This will be cleared in `on_initialize` of each new block.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    upwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>;

    /**
     * Upward messages that are still pending and not yet send to the relay chain.
     *
     * @param {Callback<Array<Bytes>> =} callback
     **/
    pendingUpwardMessages: GenericStorageQuery<Rv, () => Array<Bytes>>;

    /**
     * The factor to multiply the base delivery fee by for UMP.
     *
     * @param {Callback<FixedU128> =} callback
     **/
    upwardDeliveryFeeFactor: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     * The number of HRMP messages we observed in `on_initialize` and thus used that number for
     * announcing the weight of `on_initialize` and `on_finalize`.
     *
     * @param {Callback<number> =} callback
     **/
    announcedHrmpMessagesPerCandidate: GenericStorageQuery<Rv, () => number>;

    /**
     * The weight we reserve at the beginning of the block for processing XCMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedXcmpWeightOverride: GenericStorageQuery<
      Rv,
      () => SpWeightsWeightV2Weight | undefined
    >;

    /**
     * The weight we reserve at the beginning of the block for processing DMP messages. This
     * overrides the amount set in the Config trait.
     *
     * @param {Callback<SpWeightsWeightV2Weight | undefined> =} callback
     **/
    reservedDmpWeightOverride: GenericStorageQuery<
      Rv,
      () => SpWeightsWeightV2Weight | undefined
    >;

    /**
     * A custom head data that should be returned as result of `validate_block`.
     *
     * See `Pallet::set_custom_validation_head_data` for more information.
     *
     * @param {Callback<Bytes | undefined> =} callback
     **/
    customValidationHeadData: GenericStorageQuery<Rv, () => Bytes | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Timestamp`'s storage queries
   **/
  timestamp: {
    /**
     * The current time for the current block.
     *
     * @param {Callback<bigint> =} callback
     **/
    now: GenericStorageQuery<Rv, () => bigint>;

    /**
     * Whether the timestamp has been updated in this block.
     *
     * This value is updated to `true` upon successful submission of a timestamp by a node.
     * It is then checked at the end of each block execution in the `on_finalize` hook.
     *
     * @param {Callback<boolean> =} callback
     **/
    didUpdate: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ParachainInfo`'s storage queries
   **/
  parachainInfo: {
    /**
     *
     * @param {Callback<PolkadotParachainPrimitivesPrimitivesId> =} callback
     **/
    parachainId: GenericStorageQuery<
      Rv,
      () => PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Multisig`'s storage queries
   **/
  multisig: {
    /**
     * The set of open multisig operations.
     *
     * @param {[AccountId32Like, FixedBytes<32>]} arg
     * @param {Callback<PalletMultisigMultisig | undefined> =} callback
     **/
    multisigs: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, FixedBytes<32>],
      ) => PalletMultisigMultisig | undefined,
      [AccountId32, FixedBytes<32>]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Proxy`'s storage queries
   **/
  proxy: {
    /**
     * The set of account proxies. Maps the account which has delegated to the accounts
     * which are being delegated to, together with the amount held on deposit.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyProxyDefinition>, bigint]> =} callback
     **/
    proxies: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyProxyDefinition>, bigint],
      AccountId32
    >;

    /**
     * The announcements made by the proxy (key).
     *
     * @param {AccountId32Like} arg
     * @param {Callback<[Array<PalletProxyAnnouncement>, bigint]> =} callback
     **/
    announcements: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => [Array<PalletProxyAnnouncement>, bigint],
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Balances`'s storage queries
   **/
  balances: {
    /**
     * The total units issued in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    totalIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The total units of outstanding deactivated balance in the system.
     *
     * @param {Callback<bigint> =} callback
     **/
    inactiveIssuance: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The Balances pallet example of storing the balance of an account.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = StorageMapShim<Self::Account<Runtime>, frame_system::Provider<Runtime>, AccountId, Self::AccountData<Balance>>
     * }
     * ```
     *
     * You can also store the balance of an account in the `System` pallet.
     *
     * # Example
     *
     * ```nocompile
     * impl pallet_balances::Config for Runtime {
     * type AccountStore = System
     * }
     * ```
     *
     * But this comes with tradeoffs, storing account balances in the system pallet stores
     * `frame_system` data alongside the account data contrary to storing account balances in the
     * `Balances` pallet, which uses a `StorageMap` to store balances data only.
     * NOTE: This is only used in the case that this pallet is used to store balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletBalancesAccountData> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletBalancesAccountData,
      AccountId32
    >;

    /**
     * Any liquidity locks on some account balances.
     * NOTE: Should only be accessed when setting, changing and freeing a lock.
     *
     * Use of locks is deprecated in favour of freezes. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesBalanceLock>> =} callback
     **/
    locks: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesBalanceLock>,
      AccountId32
    >;

    /**
     * Named reserves on some account balances.
     *
     * Use of reserves is deprecated in favour of holds. See `https://github.com/paritytech/substrate/pull/12951/`
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletBalancesReserveData>> =} callback
     **/
    reserves: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletBalancesReserveData>,
      AccountId32
    >;

    /**
     * Holds on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmount>> =} callback
     **/
    holds: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<FrameSupportTokensMiscIdAmount>,
      AccountId32
    >;

    /**
     * Freeze locks on account balances.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>> =} callback
     **/
    freezes: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<FrameSupportTokensMiscIdAmountRuntimeFreezeReason>,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TransactionPayment`'s storage queries
   **/
  transactionPayment: {
    /**
     *
     * @param {Callback<FixedU128> =} callback
     **/
    nextFeeMultiplier: GenericStorageQuery<Rv, () => FixedU128>;

    /**
     *
     * @param {Callback<PalletTransactionPaymentReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<
      Rv,
      () => PalletTransactionPaymentReleases
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Vesting`'s storage queries
   **/
  vesting: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletVestingVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => Array<PalletVestingVestingInfo> | undefined,
      AccountId32
    >;

    /**
     * Storage version of the pallet.
     *
     * New networks start with latest version, as determined by the genesis build.
     *
     * @param {Callback<PalletVestingReleases> =} callback
     **/
    storageVersion: GenericStorageQuery<Rv, () => PalletVestingReleases>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ContributionTokens`'s storage queries
   **/
  contributionTokens: {
    /**
     * Details of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<
      Rv,
      (arg: number) => PalletAssetsAssetDetails | undefined,
      number
    >;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => PalletAssetsAssetAccount | undefined,
      [number, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[number, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like, AccountId32Like],
      ) => PalletAssetsApproval | undefined,
      [number, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {number} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<
      Rv,
      (arg: number) => PalletAssetsAssetMetadata,
      number
    >;

    /**
     * The asset ID enforced for the next asset creation, if any present. Otherwise, this storage
     * item has no effect.
     *
     * This can be useful for setting up constraints for IDs of the new assets. For example, by
     * providing an initial [`NextAssetId`] and using the [`crate::AutoIncAssetId`] callback, an
     * auto-increment model can be applied to all new asset IDs.
     *
     * The initial next asset ID can be set using the [`GenesisConfig`] or the
     * [SetNextAssetId](`migration::next_asset_id::SetNextAssetId`) migration.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    nextAssetId: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ForeignAssets`'s storage queries
   **/
  foreignAssets: {
    /**
     * Details of an asset.
     *
     * @param {StagingXcmV4Location} arg
     * @param {Callback<PalletAssetsAssetDetails | undefined> =} callback
     **/
    asset: GenericStorageQuery<
      Rv,
      (arg: StagingXcmV4Location) => PalletAssetsAssetDetails | undefined,
      StagingXcmV4Location
    >;

    /**
     * The holdings of a specific account for a specific asset.
     *
     * @param {[StagingXcmV4Location, AccountId32Like]} arg
     * @param {Callback<PalletAssetsAssetAccount | undefined> =} callback
     **/
    account: GenericStorageQuery<
      Rv,
      (
        arg: [StagingXcmV4Location, AccountId32Like],
      ) => PalletAssetsAssetAccount | undefined,
      [StagingXcmV4Location, AccountId32]
    >;

    /**
     * Approved balance transfers. First balance is the amount approved for transfer. Second
     * is the amount of `T::Currency` reserved for storing this.
     * First key is the asset ID, second key is the owner and third key is the delegate.
     *
     * @param {[StagingXcmV4Location, AccountId32Like, AccountId32Like]} arg
     * @param {Callback<PalletAssetsApproval | undefined> =} callback
     **/
    approvals: GenericStorageQuery<
      Rv,
      (
        arg: [StagingXcmV4Location, AccountId32Like, AccountId32Like],
      ) => PalletAssetsApproval | undefined,
      [StagingXcmV4Location, AccountId32, AccountId32]
    >;

    /**
     * Metadata of an asset.
     *
     * @param {StagingXcmV4Location} arg
     * @param {Callback<PalletAssetsAssetMetadata> =} callback
     **/
    metadata: GenericStorageQuery<
      Rv,
      (arg: StagingXcmV4Location) => PalletAssetsAssetMetadata,
      StagingXcmV4Location
    >;

    /**
     * The asset ID enforced for the next asset creation, if any present. Otherwise, this storage
     * item has no effect.
     *
     * This can be useful for setting up constraints for IDs of the new assets. For example, by
     * providing an initial [`NextAssetId`] and using the [`crate::AutoIncAssetId`] callback, an
     * auto-increment model can be applied to all new asset IDs.
     *
     * The initial next asset ID can be set using the [`GenesisConfig`] or the
     * [SetNextAssetId](`migration::next_asset_id::SetNextAssetId`) migration.
     *
     * @param {Callback<StagingXcmV4Location | undefined> =} callback
     **/
    nextAssetId: GenericStorageQuery<
      Rv,
      () => StagingXcmV4Location | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Dispenser`'s storage queries
   **/
  dispenser: {
    /**
     *
     * @param {Callback<bigint> =} callback
     **/
    dispenseAmount: GenericStorageQuery<Rv, () => bigint>;

    /**
     *
     * @param {BytesLike} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    dispensed: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => [] | undefined,
      Bytes
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Authorship`'s storage queries
   **/
  authorship: {
    /**
     * Author of current block.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    author: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Session`'s storage queries
   **/
  session: {
    /**
     * The current set of validators.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    validators: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Current index of the session.
     *
     * @param {Callback<number> =} callback
     **/
    currentIndex: GenericStorageQuery<Rv, () => number>;

    /**
     * True if the underlying economic identities or weighting behind the validators
     * has changed in the queued validator set.
     *
     * @param {Callback<boolean> =} callback
     **/
    queuedChanged: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The queued keys for the next session. When the next session begins, these keys
     * will be used to determine the validator's session keys.
     *
     * @param {Callback<Array<[AccountId32, PolimecRuntimeSessionKeys]>> =} callback
     **/
    queuedKeys: GenericStorageQuery<
      Rv,
      () => Array<[AccountId32, PolimecRuntimeSessionKeys]>
    >;

    /**
     * Indices of disabled validators.
     *
     * The vec is always kept sorted so that we can find whether a given validator is
     * disabled using binary search. It gets cleared when `on_session_ending` returns
     * a new set of identities.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    disabledValidators: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The next session keys for a validator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PolimecRuntimeSessionKeys | undefined> =} callback
     **/
    nextKeys: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PolimecRuntimeSessionKeys | undefined,
      AccountId32
    >;

    /**
     * The owner of a key. The key is the `KeyTypeId` + the encoded key.
     *
     * @param {[SpCoreCryptoKeyTypeId, BytesLike]} arg
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    keyOwner: GenericStorageQuery<
      Rv,
      (arg: [SpCoreCryptoKeyTypeId, BytesLike]) => AccountId32 | undefined,
      [SpCoreCryptoKeyTypeId, Bytes]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Aura`'s storage queries
   **/
  aura: {
    /**
     * The current authority set.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<SpConsensusAuraSr25519AppSr25519Public>
    >;

    /**
     * The current slot of this block.
     *
     * This will be set in `on_initialize`.
     *
     * @param {Callback<SpConsensusSlotsSlot> =} callback
     **/
    currentSlot: GenericStorageQuery<Rv, () => SpConsensusSlotsSlot>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `AuraExt`'s storage queries
   **/
  auraExt: {
    /**
     * Serves as cache for the authorities.
     *
     * The authorities in AuRa are overwritten in `on_initialize` when we switch to a new session,
     * but we require the old authorities to verify the seal when validating a PoV. This will
     * always be updated to the latest AuRa authorities in `on_finalize`.
     *
     * @param {Callback<Array<SpConsensusAuraSr25519AppSr25519Public>> =} callback
     **/
    authorities: GenericStorageQuery<
      Rv,
      () => Array<SpConsensusAuraSr25519AppSr25519Public>
    >;

    /**
     * Current slot paired with a number of authored blocks.
     *
     * Updated on each block initialization.
     *
     * @param {Callback<[SpConsensusSlotsSlot, number] | undefined> =} callback
     **/
    slotInfo: GenericStorageQuery<
      Rv,
      () => [SpConsensusSlotsSlot, number] | undefined
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ParachainStaking`'s storage queries
   **/
  parachainStaking: {
    /**
     * Commission percent taken off of rewards for all collators
     *
     * @param {Callback<Perbill> =} callback
     **/
    collatorCommission: GenericStorageQuery<Rv, () => Perbill>;

    /**
     * The total candidates selected every round
     *
     * @param {Callback<number> =} callback
     **/
    totalSelected: GenericStorageQuery<Rv, () => number>;

    /**
     * Parachain bond config info { account, percent_of_inflation }
     *
     * @param {Callback<PalletParachainStakingParachainBondConfig> =} callback
     **/
    parachainBondInfo: GenericStorageQuery<
      Rv,
      () => PalletParachainStakingParachainBondConfig
    >;

    /**
     * Current round index and next round scheduled transition
     *
     * @param {Callback<PalletParachainStakingRoundInfo> =} callback
     **/
    round: GenericStorageQuery<Rv, () => PalletParachainStakingRoundInfo>;

    /**
     * Get delegator state associated with an account if account is delegating else None
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletParachainStakingDelegator | undefined> =} callback
     **/
    delegatorState: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletParachainStakingDelegator | undefined,
      AccountId32
    >;

    /**
     * Get collator candidate info associated with an account if account is candidate else None
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletParachainStakingCandidateMetadata | undefined> =} callback
     **/
    candidateInfo: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => PalletParachainStakingCandidateMetadata | undefined,
      AccountId32
    >;

    /**
     * Stores outstanding delegation requests per collator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletParachainStakingDelegationRequestsScheduledRequest>> =} callback
     **/
    delegationScheduledRequests: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<PalletParachainStakingDelegationRequestsScheduledRequest>,
      AccountId32
    >;

    /**
     * Stores auto-compounding configuration per collator.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<PalletParachainStakingAutoCompoundAutoCompoundConfig>> =} callback
     **/
    autoCompoundingDelegations: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<PalletParachainStakingAutoCompoundAutoCompoundConfig>,
      AccountId32
    >;

    /**
     * Top delegations for collator candidate
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletParachainStakingDelegations | undefined> =} callback
     **/
    topDelegations: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletParachainStakingDelegations | undefined,
      AccountId32
    >;

    /**
     * Bottom delegations for collator candidate
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletParachainStakingDelegations | undefined> =} callback
     **/
    bottomDelegations: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletParachainStakingDelegations | undefined,
      AccountId32
    >;

    /**
     * The collator candidates selected for the current round
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    selectedCandidates: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * Total capital locked by this staking pallet
     *
     * @param {Callback<bigint> =} callback
     **/
    total: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The pool of collator candidates, each with their total backing stake
     *
     * @param {Callback<PalletParachainStakingSetOrderedSet> =} callback
     **/
    candidatePool: GenericStorageQuery<
      Rv,
      () => PalletParachainStakingSetOrderedSet
    >;

    /**
     * Snapshot of collator delegation stake at the start of the round
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<PalletParachainStakingCollatorSnapshot> =} callback
     **/
    atStake: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) => PalletParachainStakingCollatorSnapshot,
      [number, AccountId32]
    >;

    /**
     * Delayed payouts
     *
     * @param {number} arg
     * @param {Callback<PalletParachainStakingDelayedPayout | undefined> =} callback
     **/
    delayedPayouts: GenericStorageQuery<
      Rv,
      (arg: number) => PalletParachainStakingDelayedPayout | undefined,
      number
    >;

    /**
     * Total counted stake for selected candidates in the round
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    staked: GenericStorageQuery<Rv, (arg: number) => bigint, number>;

    /**
     * Inflation configuration
     *
     * @param {Callback<PalletParachainStakingInflationInflationInfo> =} callback
     **/
    inflationConfig: GenericStorageQuery<
      Rv,
      () => PalletParachainStakingInflationInflationInfo
    >;

    /**
     * Total points awarded to collators for block production in the round
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    points: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * Points for each collator per round
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<number> =} callback
     **/
    awardedPts: GenericStorageQuery<
      Rv,
      (arg: [number, AccountId32Like]) => number,
      [number, AccountId32]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `XcmpQueue`'s storage queries
   **/
  xcmpQueue: {
    /**
     * The suspended inbound XCMP channels. All others are not suspended.
     *
     * This is a `StorageValue` instead of a `StorageMap` since we expect multiple reads per block
     * to different keys with a one byte payload. The access to `BoundedBTreeSet` will be cached
     * within the block and therefore only included once in the proof size.
     *
     * NOTE: The PoV benchmarking cannot know this and will over-estimate, but the actual proof
     * will be smaller.
     *
     * @param {Callback<Array<PolkadotParachainPrimitivesPrimitivesId>> =} callback
     **/
    inboundXcmpSuspended: GenericStorageQuery<
      Rv,
      () => Array<PolkadotParachainPrimitivesPrimitivesId>
    >;

    /**
     * The non-empty XCMP channels in order of becoming non-empty, and the index of the first
     * and last outbound message. If the two indices are equal, then it indicates an empty
     * queue and there must be a non-`Ok` `OutboundStatus`. We assume queues grow no greater
     * than 65535 items. Queue indices for normal messages begin at one; zero is reserved in
     * case of the need to send a high-priority signal message this block.
     * The bool is true if there is a signal message waiting to be sent.
     *
     * @param {Callback<Array<CumulusPalletXcmpQueueOutboundChannelDetails>> =} callback
     **/
    outboundXcmpStatus: GenericStorageQuery<
      Rv,
      () => Array<CumulusPalletXcmpQueueOutboundChannelDetails>
    >;

    /**
     * The messages outbound in a given XCMP channel.
     *
     * @param {[PolkadotParachainPrimitivesPrimitivesId, number]} arg
     * @param {Callback<Bytes> =} callback
     **/
    outboundXcmpMessages: GenericStorageQuery<
      Rv,
      (arg: [PolkadotParachainPrimitivesPrimitivesId, number]) => Bytes,
      [PolkadotParachainPrimitivesPrimitivesId, number]
    >;

    /**
     * Any signal messages waiting to be sent.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<Bytes> =} callback
     **/
    signalMessages: GenericStorageQuery<
      Rv,
      (arg: PolkadotParachainPrimitivesPrimitivesId) => Bytes,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * The configuration which controls the dynamics of the outbound queue.
     *
     * @param {Callback<CumulusPalletXcmpQueueQueueConfigData> =} callback
     **/
    queueConfig: GenericStorageQuery<
      Rv,
      () => CumulusPalletXcmpQueueQueueConfigData
    >;

    /**
     * Whether or not the XCMP queue is suspended from executing incoming XCMs or not.
     *
     * @param {Callback<boolean> =} callback
     **/
    queueSuspended: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The factor to multiply the base delivery fee by.
     *
     * @param {PolkadotParachainPrimitivesPrimitivesId} arg
     * @param {Callback<FixedU128> =} callback
     **/
    deliveryFeeFactor: GenericStorageQuery<
      Rv,
      (arg: PolkadotParachainPrimitivesPrimitivesId) => FixedU128,
      PolkadotParachainPrimitivesPrimitivesId
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `PolkadotXcm`'s storage queries
   **/
  polkadotXcm: {
    /**
     * The latest available query index.
     *
     * @param {Callback<bigint> =} callback
     **/
    queryCounter: GenericStorageQuery<Rv, () => bigint>;

    /**
     * The ongoing queries.
     *
     * @param {bigint} arg
     * @param {Callback<PalletXcmQueryStatus | undefined> =} callback
     **/
    queries: GenericStorageQuery<
      Rv,
      (arg: bigint) => PalletXcmQueryStatus | undefined,
      bigint
    >;

    /**
     * The existing asset traps.
     *
     * Key is the blake2 256 hash of (origin, versioned `Assets`) pair. Value is the number of
     * times this pair has been trapped (usually just 1 if it exists at all).
     *
     * @param {H256} arg
     * @param {Callback<number> =} callback
     **/
    assetTraps: GenericStorageQuery<Rv, (arg: H256) => number, H256>;

    /**
     * Default version to encode XCM when latest version of destination is unknown. If `None`,
     * then the destinations whose XCM version is unknown are considered unreachable.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    safeXcmVersion: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * The Latest versions that we know various locations support.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<number | undefined> =} callback
     **/
    supportedVersion: GenericStorageQuery<
      Rv,
      (arg: [number, XcmVersionedLocation]) => number | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * All locations that we have requested version notifications from.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<bigint | undefined> =} callback
     **/
    versionNotifiers: GenericStorageQuery<
      Rv,
      (arg: [number, XcmVersionedLocation]) => bigint | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * The target locations that are subscribed to our version changes, as well as the most recent
     * of our versions we informed them of.
     *
     * @param {[number, XcmVersionedLocation]} arg
     * @param {Callback<[bigint, SpWeightsWeightV2Weight, number] | undefined> =} callback
     **/
    versionNotifyTargets: GenericStorageQuery<
      Rv,
      (
        arg: [number, XcmVersionedLocation],
      ) => [bigint, SpWeightsWeightV2Weight, number] | undefined,
      [number, XcmVersionedLocation]
    >;

    /**
     * Destinations whose latest XCM version we would like to know. Duplicates not allowed, and
     * the `u32` counter is the number of times that a send to the destination has been attempted,
     * which is used as a prioritization.
     *
     * @param {Callback<Array<[XcmVersionedLocation, number]>> =} callback
     **/
    versionDiscoveryQueue: GenericStorageQuery<
      Rv,
      () => Array<[XcmVersionedLocation, number]>
    >;

    /**
     * The current migration's stage, if any.
     *
     * @param {Callback<PalletXcmVersionMigrationStage | undefined> =} callback
     **/
    currentMigration: GenericStorageQuery<
      Rv,
      () => PalletXcmVersionMigrationStage | undefined
    >;

    /**
     * Fungible assets which we know are locked on a remote chain.
     *
     * @param {[number, AccountId32Like, XcmVersionedAssetId]} arg
     * @param {Callback<PalletXcmRemoteLockedFungibleRecord | undefined> =} callback
     **/
    remoteLockedFungibles: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like, XcmVersionedAssetId],
      ) => PalletXcmRemoteLockedFungibleRecord | undefined,
      [number, AccountId32, XcmVersionedAssetId]
    >;

    /**
     * Fungible assets which we know are locked on this chain.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<Array<[bigint, XcmVersionedLocation]> | undefined> =} callback
     **/
    lockedFungibles: GenericStorageQuery<
      Rv,
      (
        arg: AccountId32Like,
      ) => Array<[bigint, XcmVersionedLocation]> | undefined,
      AccountId32
    >;

    /**
     * Global suspension state of the XCM executor.
     *
     * @param {Callback<boolean> =} callback
     **/
    xcmExecutionSuspended: GenericStorageQuery<Rv, () => boolean>;

    /**
     * Whether or not incoming XCMs (both executed locally and received) should be recorded.
     * Only one XCM program will be recorded at a time.
     * This is meant to be used in runtime APIs, and it's advised it stays false
     * for all other use cases, so as to not degrade regular performance.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<boolean> =} callback
     **/
    shouldRecordXcm: GenericStorageQuery<Rv, () => boolean>;

    /**
     * If [`ShouldRecordXcm`] is set to true, then the last XCM program executed locally
     * will be stored here.
     * Runtime APIs can fetch the XCM that was executed by accessing this value.
     *
     * Only relevant if this pallet is being used as the [`xcm_executor::traits::RecordXcm`]
     * implementation in the XCM executor configuration.
     *
     * @param {Callback<StagingXcmV5Xcm | undefined> =} callback
     **/
    recordedXcm: GenericStorageQuery<Rv, () => StagingXcmV5Xcm | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `MessageQueue`'s storage queries
   **/
  messageQueue: {
    /**
     * The index of the first and last (non-empty) pages.
     *
     * @param {CumulusPrimitivesCoreAggregateMessageOrigin} arg
     * @param {Callback<PalletMessageQueueBookState> =} callback
     **/
    bookStateFor: GenericStorageQuery<
      Rv,
      (
        arg: CumulusPrimitivesCoreAggregateMessageOrigin,
      ) => PalletMessageQueueBookState,
      CumulusPrimitivesCoreAggregateMessageOrigin
    >;

    /**
     * The origin at which we should begin servicing.
     *
     * @param {Callback<CumulusPrimitivesCoreAggregateMessageOrigin | undefined> =} callback
     **/
    serviceHead: GenericStorageQuery<
      Rv,
      () => CumulusPrimitivesCoreAggregateMessageOrigin | undefined
    >;

    /**
     * The map of page indices to pages.
     *
     * @param {[CumulusPrimitivesCoreAggregateMessageOrigin, number]} arg
     * @param {Callback<PalletMessageQueuePage | undefined> =} callback
     **/
    pages: GenericStorageQuery<
      Rv,
      (
        arg: [CumulusPrimitivesCoreAggregateMessageOrigin, number],
      ) => PalletMessageQueuePage | undefined,
      [CumulusPrimitivesCoreAggregateMessageOrigin, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Treasury`'s storage queries
   **/
  treasury: {
    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Number of proposals that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposals that have been made.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasuryProposal | undefined> =} callback
     **/
    proposals: GenericStorageQuery<
      Rv,
      (arg: number) => PalletTreasuryProposal | undefined,
      number
    >;

    /**
     * The amount which has been reported as inactive to Currency.
     *
     * @param {Callback<bigint> =} callback
     **/
    deactivated: GenericStorageQuery<Rv, () => bigint>;

    /**
     * DEPRECATED: associated with `spend_local` call and will be removed in May 2025.
     * Refer to <https://github.com/paritytech/polkadot-sdk/pull/5961> for migration to `spend`.
     *
     * Proposal indices that have been approved but not yet awarded.
     *
     * @param {Callback<Array<number>> =} callback
     **/
    approvals: GenericStorageQuery<Rv, () => Array<number>>;

    /**
     * The count of spends that have been made.
     *
     * @param {Callback<number> =} callback
     **/
    spendCount: GenericStorageQuery<Rv, () => number>;

    /**
     * Spends that have been approved and being processed.
     *
     * @param {number} arg
     * @param {Callback<PalletTreasurySpendStatus | undefined> =} callback
     **/
    spends: GenericStorageQuery<
      Rv,
      (arg: number) => PalletTreasurySpendStatus | undefined,
      number
    >;

    /**
     * The blocknumber for the last triggered spend period.
     *
     * @param {Callback<number | undefined> =} callback
     **/
    lastSpendPeriod: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Democracy`'s storage queries
   **/
  democracy: {
    /**
     * The number of (public) proposals that have been made so far.
     *
     * @param {Callback<number> =} callback
     **/
    publicPropCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The public proposals. Unsorted. The second item is the proposal.
     *
     * @param {Callback<Array<[number, FrameSupportPreimagesBounded, AccountId32]>> =} callback
     **/
    publicProps: GenericStorageQuery<
      Rv,
      () => Array<[number, FrameSupportPreimagesBounded, AccountId32]>
    >;

    /**
     * Those who have locked a deposit.
     *
     * TWOX-NOTE: Safe, as increasing integer keys are safe.
     *
     * @param {number} arg
     * @param {Callback<[Array<AccountId32>, bigint] | undefined> =} callback
     **/
    depositOf: GenericStorageQuery<
      Rv,
      (arg: number) => [Array<AccountId32>, bigint] | undefined,
      number
    >;

    /**
     * The next free referendum index, aka the number of referenda started so far.
     *
     * @param {Callback<number> =} callback
     **/
    referendumCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The lowest referendum index representing an unbaked referendum. Equal to
     * `ReferendumCount` if there isn't a unbaked referendum.
     *
     * @param {Callback<number> =} callback
     **/
    lowestUnbaked: GenericStorageQuery<Rv, () => number>;

    /**
     * Information concerning any given referendum.
     *
     * TWOX-NOTE: SAFE as indexes are not under an attacker’s control.
     *
     * @param {number} arg
     * @param {Callback<PalletDemocracyReferendumInfo | undefined> =} callback
     **/
    referendumInfoOf: GenericStorageQuery<
      Rv,
      (arg: number) => PalletDemocracyReferendumInfo | undefined,
      number
    >;

    /**
     * All votes for a particular voter. We store the balance for the number of votes that we
     * have recorded. The second item is the total amount of delegations, that will be added.
     *
     * TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletDemocracyVoteVoting> =} callback
     **/
    votingOf: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletDemocracyVoteVoting,
      AccountId32
    >;

    /**
     * True if the last referendum tabled was submitted externally. False if it was a public
     * proposal.
     *
     * @param {Callback<boolean> =} callback
     **/
    lastTabledWasExternal: GenericStorageQuery<Rv, () => boolean>;

    /**
     * The referendum to be tabled whenever it would be valid to table an external proposal.
     * This happens when a referendum needs to be tabled and one of two conditions are met:
     * - `LastTabledWasExternal` is `false`; or
     * - `PublicProps` is empty.
     *
     * @param {Callback<[FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold] | undefined> =} callback
     **/
    nextExternal: GenericStorageQuery<
      Rv,
      () =>
        | [FrameSupportPreimagesBounded, PalletDemocracyVoteThreshold]
        | undefined
    >;

    /**
     * A record of who vetoed what. Maps proposal hash to a possible existent block number
     * (until when it may not be resubmitted) and who vetoed it.
     *
     * @param {H256} arg
     * @param {Callback<[number, Array<AccountId32>] | undefined> =} callback
     **/
    blacklist: GenericStorageQuery<
      Rv,
      (arg: H256) => [number, Array<AccountId32>] | undefined,
      H256
    >;

    /**
     * Record of all proposals that have been subject to emergency cancellation.
     *
     * @param {H256} arg
     * @param {Callback<boolean> =} callback
     **/
    cancellations: GenericStorageQuery<Rv, (arg: H256) => boolean, H256>;

    /**
     * General information concerning any proposal or referendum.
     *
     * Consider a garbage collection for a metadata of finished referendums to `unrequest` (remove)
     * large preimages.
     *
     * @param {PalletDemocracyMetadataOwner} arg
     * @param {Callback<H256 | undefined> =} callback
     **/
    metadataOf: GenericStorageQuery<
      Rv,
      (arg: PalletDemocracyMetadataOwner) => H256 | undefined,
      PalletDemocracyMetadataOwner
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Council`'s storage queries
   **/
  council: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<PolimecRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<
      Rv,
      (arg: H256) => PolimecRuntimeRuntimeCall | undefined,
      H256
    >;

    /**
     * Consideration cost created for publishing and storing a proposal.
     *
     * Determined by [Config::Consideration] and may be not present for certain proposals (e.g. if
     * the proposal count at the time of creation was below threshold N).
     *
     * @param {H256} arg
     * @param {Callback<[AccountId32, []] | undefined> =} callback
     **/
    costOf: GenericStorageQuery<
      Rv,
      (arg: H256) => [AccountId32, []] | undefined,
      H256
    >;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletCollectiveVotes | undefined,
      H256
    >;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of abstentions.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `TechnicalCommittee`'s storage queries
   **/
  technicalCommittee: {
    /**
     * The hashes of the active proposals.
     *
     * @param {Callback<Array<H256>> =} callback
     **/
    proposals: GenericStorageQuery<Rv, () => Array<H256>>;

    /**
     * Actual proposal for a given hash, if it's current.
     *
     * @param {H256} arg
     * @param {Callback<PolimecRuntimeRuntimeCall | undefined> =} callback
     **/
    proposalOf: GenericStorageQuery<
      Rv,
      (arg: H256) => PolimecRuntimeRuntimeCall | undefined,
      H256
    >;

    /**
     * Consideration cost created for publishing and storing a proposal.
     *
     * Determined by [Config::Consideration] and may be not present for certain proposals (e.g. if
     * the proposal count at the time of creation was below threshold N).
     *
     * @param {H256} arg
     * @param {Callback<[AccountId32, []] | undefined> =} callback
     **/
    costOf: GenericStorageQuery<
      Rv,
      (arg: H256) => [AccountId32, []] | undefined,
      H256
    >;

    /**
     * Votes on a given proposal, if it is ongoing.
     *
     * @param {H256} arg
     * @param {Callback<PalletCollectiveVotes | undefined> =} callback
     **/
    voting: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletCollectiveVotes | undefined,
      H256
    >;

    /**
     * Proposals so far.
     *
     * @param {Callback<number> =} callback
     **/
    proposalCount: GenericStorageQuery<Rv, () => number>;

    /**
     * The current members of the collective. This is stored sorted (just by value).
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The prime member that helps determine the default vote behavior in case of abstentions.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Elections`'s storage queries
   **/
  elections: {
    /**
     * The current elected members.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    members: GenericStorageQuery<
      Rv,
      () => Array<PalletElectionsPhragmenSeatHolder>
    >;

    /**
     * The current reserved runners-up.
     *
     * Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the
     * last (i.e. _best_) runner-up will be replaced.
     *
     * @param {Callback<Array<PalletElectionsPhragmenSeatHolder>> =} callback
     **/
    runnersUp: GenericStorageQuery<
      Rv,
      () => Array<PalletElectionsPhragmenSeatHolder>
    >;

    /**
     * The present candidate list. A current member or runner-up can never enter this vector
     * and is always implicitly assumed to be a candidate.
     *
     * Second element is the deposit.
     *
     * Invariant: Always sorted based on account id.
     *
     * @param {Callback<Array<[AccountId32, bigint]>> =} callback
     **/
    candidates: GenericStorageQuery<Rv, () => Array<[AccountId32, bigint]>>;

    /**
     * The total number of vote rounds that have happened, excluding the upcoming one.
     *
     * @param {Callback<number> =} callback
     **/
    electionRounds: GenericStorageQuery<Rv, () => number>;

    /**
     * Votes and locked stake of a particular voter.
     *
     * TWOX-NOTE: SAFE as `AccountId` is a crypto hash.
     *
     * @param {AccountId32Like} arg
     * @param {Callback<PalletElectionsPhragmenVoter> =} callback
     **/
    voting: GenericStorageQuery<
      Rv,
      (arg: AccountId32Like) => PalletElectionsPhragmenVoter,
      AccountId32
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Preimage`'s storage queries
   **/
  preimage: {
    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageOldRequestStatus | undefined> =} callback
     **/
    statusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageOldRequestStatus | undefined,
      H256
    >;

    /**
     * The request status of a given hash.
     *
     * @param {H256} arg
     * @param {Callback<PalletPreimageRequestStatus | undefined> =} callback
     **/
    requestStatusFor: GenericStorageQuery<
      Rv,
      (arg: H256) => PalletPreimageRequestStatus | undefined,
      H256
    >;

    /**
     *
     * @param {[H256, number]} arg
     * @param {Callback<Bytes | undefined> =} callback
     **/
    preimageFor: GenericStorageQuery<
      Rv,
      (arg: [H256, number]) => Bytes | undefined,
      [H256, number]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Scheduler`'s storage queries
   **/
  scheduler: {
    /**
     *
     * @param {Callback<number | undefined> =} callback
     **/
    incompleteSince: GenericStorageQuery<Rv, () => number | undefined>;

    /**
     * Items to be executed, indexed by the block number that they should be executed on.
     *
     * @param {number} arg
     * @param {Callback<Array<PalletSchedulerScheduled | undefined>> =} callback
     **/
    agenda: GenericStorageQuery<
      Rv,
      (arg: number) => Array<PalletSchedulerScheduled | undefined>,
      number
    >;

    /**
     * Retry configurations for items to be executed, indexed by task address.
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletSchedulerRetryConfig | undefined> =} callback
     **/
    retries: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletSchedulerRetryConfig | undefined,
      [number, number]
    >;

    /**
     * Lookup from a name to the block number and index of the task.
     *
     * For v3 -> v4 the previously unbounded identities are Blake2-256 hashed to form the v4
     * identities.
     *
     * @param {FixedBytes<32>} arg
     * @param {Callback<[number, number] | undefined> =} callback
     **/
    lookup: GenericStorageQuery<
      Rv,
      (arg: FixedBytes<32>) => [number, number] | undefined,
      FixedBytes<32>
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Oracle`'s storage queries
   **/
  oracle: {
    /**
     * Raw values for each oracle operators
     *
     * @param {[AccountId32Like, StagingXcmV4Location]} arg
     * @param {Callback<OrmlOracleModuleTimestampedValue | undefined> =} callback
     **/
    rawValues: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, StagingXcmV4Location],
      ) => OrmlOracleModuleTimestampedValue | undefined,
      [AccountId32, StagingXcmV4Location]
    >;

    /**
     * Up to date combined value from Raw Values
     *
     * @param {StagingXcmV4Location} arg
     * @param {Callback<OrmlOracleModuleTimestampedValue | undefined> =} callback
     **/
    values: GenericStorageQuery<
      Rv,
      (
        arg: StagingXcmV4Location,
      ) => OrmlOracleModuleTimestampedValue | undefined,
      StagingXcmV4Location
    >;

    /**
     * If an oracle operator has fed a value in this block
     *
     * @param {Callback<OrmlUtilitiesOrderedSet> =} callback
     **/
    hasDispatched: GenericStorageQuery<Rv, () => OrmlUtilitiesOrderedSet>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `OracleProvidersMembership`'s storage queries
   **/
  oracleProvidersMembership: {
    /**
     * The current membership, stored as an ordered Vec.
     *
     * @param {Callback<Array<AccountId32>> =} callback
     **/
    members: GenericStorageQuery<Rv, () => Array<AccountId32>>;

    /**
     * The current prime member, if one exists.
     *
     * @param {Callback<AccountId32 | undefined> =} callback
     **/
    prime: GenericStorageQuery<Rv, () => AccountId32 | undefined>;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `Funding`'s storage queries
   **/
  funding: {
    /**
     * An increasing counter to assign a unique id to projects
     *
     * @param {Callback<number> =} callback
     **/
    nextProjectId: GenericStorageQuery<Rv, () => number>;

    /**
     * An increasing counter to assign a unique id to evaluations
     *
     * @param {Callback<number> =} callback
     **/
    nextEvaluationId: GenericStorageQuery<Rv, () => number>;

    /**
     * An increasing counter to assign a unique id to bids
     *
     * @param {Callback<number> =} callback
     **/
    nextBidId: GenericStorageQuery<Rv, () => number>;

    /**
     * A StorageMap containing the primary project information of projects
     *
     * @param {number} arg
     * @param {Callback<PalletFundingStorageProjectMetadata | undefined> =} callback
     **/
    projectsMetadata: GenericStorageQuery<
      Rv,
      (arg: number) => PalletFundingStorageProjectMetadata | undefined,
      number
    >;

    /**
     * A StorageMap containing the primary project information of projects
     *
     * @param {number} arg
     * @param {Callback<PalletFundingStorageBucket | undefined> =} callback
     **/
    buckets: GenericStorageQuery<
      Rv,
      (arg: number) => PalletFundingStorageBucket | undefined,
      number
    >;

    /**
     * StorageMap containing additional information for the projects, relevant for correctness of the protocol
     *
     * @param {number} arg
     * @param {Callback<PalletFundingStorageProjectDetails | undefined> =} callback
     **/
    projectsDetails: GenericStorageQuery<
      Rv,
      (arg: number) => PalletFundingStorageProjectDetails | undefined,
      number
    >;

    /**
     * Used to track which projects need the automatic processing of oversubscribed bids in on_idle
     *
     * @param {number} arg
     * @param {Callback<[] | undefined> =} callback
     **/
    projectsInAuctionRound: GenericStorageQuery<
      Rv,
      (arg: number) => [] | undefined,
      number
    >;

    /**
     * Keep track of the PLMC bonds made to each project by each evaluator
     *
     * @param {[number, AccountId32Like, number]} arg
     * @param {Callback<PalletFundingStorageEvaluationInfo | undefined> =} callback
     **/
    evaluations: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like, number],
      ) => PalletFundingStorageEvaluationInfo | undefined,
      [number, AccountId32, number]
    >;

    /**
     * Containins the bids for each project
     *
     * @param {[number, number]} arg
     * @param {Callback<PalletFundingStorageBidInfo | undefined> =} callback
     **/
    bids: GenericStorageQuery<
      Rv,
      (arg: [number, number]) => PalletFundingStorageBidInfo | undefined,
      [number, number]
    >;

    /**
     * StorageMap containing the first bid that should be settled at a certain price point, and the last bid available at that price point.
     * Bids should be settled from the higest price first, and then from the lowest index first. Both indexes are inclusive.
     *
     * @param {[number, FixedU128]} arg
     * @param {Callback<PalletFundingStorageBidBucketBounds | undefined> =} callback
     **/
    bidsBucketBounds: GenericStorageQuery<
      Rv,
      (
        arg: [number, FixedU128],
      ) => PalletFundingStorageBidBucketBounds | undefined,
      [number, FixedU128]
    >;

    /**
     * This map allows bidders to release their bid early if they were outbid.
     * The map contains the bucket price and bid index of the last bid to be outbid.
     * Indexes higher than the one stored here in the same bucket can be released.
     * All bids in buckets lower than the one stored here can also be released.
     * The last bid to be considered outbid might be partially rejected, and so that should be refunded by the new
     * bidder in the "bid" call.
     *
     * @param {number} arg
     * @param {Callback<PalletFundingStorageOutbidBidsCutoff | undefined> =} callback
     **/
    outbidBidsCutoffs: GenericStorageQuery<
      Rv,
      (arg: number) => PalletFundingStorageOutbidBidsCutoff | undefined,
      number
    >;

    /**
     * Used to knwo when to call `do_process_next_oversubscribed_bid`. When a new bid comes in on an oversubscribed project,
     * we add their bid amount to this value.
     *
     * @param {number} arg
     * @param {Callback<bigint> =} callback
     **/
    ctAmountOversubscribed: GenericStorageQuery<
      Rv,
      (arg: number) => bigint,
      number
    >;

    /**
     * Stores the total usd amount participated by a user on a project. Used to track the ticket sizes when its capped.
     *
     * @param {[number, BytesLike]} arg
     * @param {Callback<bigint> =} callback
     **/
    auctionBoughtUSD: GenericStorageQuery<
      Rv,
      (arg: [number, BytesLike]) => bigint,
      [number, Bytes]
    >;

    /**
     * Stores the CT amounts and vesting schedules for users with successful bids. Will be used by issuers to mint
     * their tokens on TGE
     *
     * @param {[number, AccountId32Like]} arg
     * @param {Callback<[PolimecCommonMigrationTypesMigrationStatus, Array<PolimecCommonMigrationTypesMigration>] | undefined> =} callback
     **/
    userMigrations: GenericStorageQuery<
      Rv,
      (
        arg: [number, AccountId32Like],
      ) =>
        | [
            PolimecCommonMigrationTypesMigrationStatus,
            Array<PolimecCommonMigrationTypesMigration>,
          ]
        | undefined,
      [number, AccountId32]
    >;

    /**
     * Counts how many participants have not yet migrated their CTs. Counter goes up on each settlement, and goes
     * down on each migration. Saves us a whole read over the full migration storage for transitioning to `ProjectStatus::CTMigrationFinished`
     *
     * @param {number} arg
     * @param {Callback<number> =} callback
     **/
    unmigratedCounter: GenericStorageQuery<Rv, (arg: number) => number, number>;

    /**
     * A map to keep track of what issuer's did has an active project. It prevents one issuer having multiple active projects
     *
     * @param {BytesLike} arg
     * @param {Callback<number | undefined> =} callback
     **/
    didWithActiveProjects: GenericStorageQuery<
      Rv,
      (arg: BytesLike) => number | undefined,
      Bytes
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `LinearRelease`'s storage queries
   **/
  linearRelease: {
    /**
     * Information regarding the vesting of a given account.
     *
     * @param {[AccountId32Like, PolimecRuntimeRuntimeHoldReason]} arg
     * @param {Callback<Array<PalletLinearReleaseVestingInfo> | undefined> =} callback
     **/
    vesting: GenericStorageQuery<
      Rv,
      (
        arg: [AccountId32Like, PolimecRuntimeRuntimeHoldReason],
      ) => Array<PalletLinearReleaseVestingInfo> | undefined,
      [AccountId32, PolimecRuntimeRuntimeHoldReason]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
  /**
   * Pallet `ProxyBonding`'s storage queries
   **/
  proxyBonding: {
    /**
     * Maps at which block can we release the bonds of a sub-account
     *
     * @param {[number, PolimecRuntimeRuntimeHoldReason]} arg
     * @param {Callback<PalletProxyBondingReleaseType | undefined> =} callback
     **/
    releases: GenericStorageQuery<
      Rv,
      (
        arg: [number, PolimecRuntimeRuntimeHoldReason],
      ) => PalletProxyBondingReleaseType | undefined,
      [number, PolimecRuntimeRuntimeHoldReason]
    >;

    /**
     * Generic pallet storage query
     **/
    [storage: string]: GenericStorageQuery<Rv>;
  };
}
